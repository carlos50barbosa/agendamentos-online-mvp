diff --git a/backend/src/lib/billing.js b/backend/src/lib/billing.js
index 62fa099..1e7895e 100644
--- a/backend/src/lib/billing.js
+++ b/backend/src/lib/billing.js
@@ -1,4 +1,4 @@
-?// backend/src/lib/billing.js
+// backend/src/lib/billing.js
 import { randomUUID } from 'node:crypto'
 import { MercadoPagoConfig, Payment } from 'mercadopago'
 import { config } from './config.js'
@@ -42,6 +42,7 @@ const mockPayments = new Map()
 
 let mercadoPagoClient = null
 let mercadoPagoPayment = null
+const mercadoPagoPaymentsByToken = new Map()
 
 function ensureMercadoPagoPayment() {
   if (MOCK_MP) {
@@ -53,7 +54,7 @@ function ensureMercadoPagoPayment() {
         const txData = {
           qr_code: `000201mock:${id}`,
           qr_code_base64: Buffer.from(`mock-qr:${id}`).toString('base64'),
-          ticket_url: body?.notification_url ? `${body.notification_url}/mock/${id}` : null,
+          ticket_url: body?.notification_url  `${body.notification_url}/mock/${id}` : null,
           expires_at: expires,
         }
         const payment = {
@@ -84,6 +85,19 @@ function ensureMercadoPagoPayment() {
   return mercadoPagoPayment
 }
 
+function resolveMercadoPagoPayment(accessToken) {
+  if (MOCK_MP) return ensureMercadoPagoPayment()
+  if (!accessToken) return ensureMercadoPagoPayment()
+  const tokenKey = String(accessToken)
+  if (mercadoPagoPaymentsByToken.has(tokenKey)) {
+    return mercadoPagoPaymentsByToken.get(tokenKey)
+  }
+  const client = new MercadoPagoConfig({ accessToken: tokenKey })
+  const paymentClient = new Payment(client)
+  mercadoPagoPaymentsByToken.set(tokenKey, paymentClient)
+  return paymentClient
+}
+
 function formatAmountString(priceCents) {
   const n = Number(priceCents || 0)
   return (n / 100).toFixed(2) // string com 2 casas decimais
@@ -96,7 +110,7 @@ function extractMpError(err) {
       message: err?.message,
       status: err?.status,
       response: err?.response?.data || null,
-      cause: Array.isArray(err?.cause) ? err.cause : undefined,
+      cause: Array.isArray(err?.cause)  err.cause : undefined,
     }
     return JSON.stringify(out)
   } catch { return String(err?.message || err) }
@@ -131,6 +145,11 @@ function pickValidUrl(...candidates) {
   return null
 }
 
+function resolveMpNotificationUrl(fallbackUrl) {
+  const envUrl = String(process.env.MP_NOTIFICATION_URL || '').trim()
+  return envUrl || fallbackUrl
+}
+
 // Mapeia status do Preapproval do Mercado Pago para os valores aceitos pela coluna
 // subscriptions.status (ENUM: 'initiated','pending','authorized','active','paused','past_due','canceled','expired')
 function mapMpToSubscriptionStatus(status) {
@@ -182,20 +201,21 @@ export async function createMercadoPagoPixCheckout({
 
   const FRONT_BASE = String(process.env.FRONTEND_BASE_URL || process.env.APP_URL || 'http://localhost:3001').replace(/\/$/, '')
   const isDevFront = /^(https?:\/\/)?(localhost|127\.0\.0\.1):3001$/i.test(FRONT_BASE)
-  const DEFAULT_API_BASE = isDevFront ? 'http://localhost:3002' : `${FRONT_BASE}/api`
+  const DEFAULT_API_BASE = isDevFront  'http://localhost:3002' : `${FRONT_BASE}/api`
   const API_BASE = String(process.env.API_BASE_URL || process.env.BACKEND_BASE_URL || DEFAULT_API_BASE).replace(/\/$/, '')
 
   const externalReference = buildExternalReference(estabelecimento.id, normalizedPlan, normalizedCycle)
   const metadata = { kind: 'pix_payment', plan: normalizedPlan, cycle: normalizedCycle, estabelecimento_id: String(estabelecimento.id) }
 
+  const notificationUrl = resolveMpNotificationUrl(`${API_BASE}/billing/webhook`)
   const paymentBody = {
     transaction_amount: amountNum,
     description: `Agendamentos Online - ${getPlanLabel(normalizedPlan)} (${normalizedCycle})`,
     payment_method_id: 'pix',
     external_reference: externalReference,
     metadata,
-    notification_url: `${API_BASE}/billing/webhook`,
-    payer: estabelecimento?.email ? { email: estabelecimento.email } : undefined,
+    notification_url: notificationUrl,
+    payer: estabelecimento?.email  { email: estabelecimento.email } : undefined,
   }
 
   let payment
@@ -258,7 +278,7 @@ export async function createMercadoPagoPixTopupCheckout({
 
   const FRONT_BASE = String(process.env.FRONTEND_BASE_URL || process.env.APP_URL || 'http://localhost:3001').replace(/\/$/, '')
   const isDevFront = /^(https?:\/\/)?(localhost|127\.0\.0\.1):3001$/i.test(FRONT_BASE)
-  const DEFAULT_API_BASE = isDevFront ? 'http://localhost:3002' : `${FRONT_BASE}/api`
+  const DEFAULT_API_BASE = isDevFront  'http://localhost:3002' : `${FRONT_BASE}/api`
   const API_BASE = String(process.env.API_BASE_URL || process.env.BACKEND_BASE_URL || DEFAULT_API_BASE).replace(/\/$/, '')
 
   const externalReference = buildExternalReferenceTopup(estabelecimento.id, pkg.messages, pkg.code)
@@ -268,21 +288,22 @@ export async function createMercadoPagoPixTopupCheckout({
     estabelecimento_id: String(estabelecimento.id),
     plan: planHint ? String(planHint).toLowerCase() : undefined,
     pack_code: pkg.code || null,
-    pack_id: pkg.id ?? null,
+    pack_id: pkg.id  null,
     pack_name: pkg.name || null,
     price_cents: pkg.priceCents,
   }
 
+  const notificationUrl = resolveMpNotificationUrl(`${API_BASE}/billing/webhook`)
   const paymentBody = {
     transaction_amount: amountNum,
     description: pkg.name
-      ? `Agendamentos Online - ${pkg.name}`
+       `Agendamentos Online - ${pkg.name}`
       : `Agendamentos Online - WhatsApp +${pkg.messages} mensagens`,
     payment_method_id: 'pix',
     external_reference: externalReference,
     metadata,
-    notification_url: `${API_BASE}/billing/webhook`,
-    payer: estabelecimento?.email ? { email: estabelecimento.email } : undefined,
+    notification_url: notificationUrl,
+    payer: estabelecimento?.email  { email: estabelecimento.email } : undefined,
   }
 
   let payment
@@ -307,12 +328,12 @@ export async function createMercadoPagoPixTopupCheckout({
     messages: pkg.messages,
     status: payment?.status || null,
     pack_code: pkg.code || null,
-    pack_id: pkg.id ?? null,
+    pack_id: pkg.id  null,
   }
 
   const planForRow = (() => {
     const p = String(planHint || 'starter').toLowerCase()
-    return PLAN_TIERS.includes(p) ? p : 'starter'
+    return PLAN_TIERS.includes(p)  p : 'starter'
   })()
 
   const subscription = await createSubscription({
@@ -329,7 +350,7 @@ export async function createMercadoPagoPixTopupCheckout({
   await appendSubscriptionEvent(subscription.id, {
     eventType: 'topup.create',
     gatewayEventId: String(payment.id),
-    payload: { payment, messages: pkg.messages, pack_code: pkg.code || null, pack_id: pkg.id ?? null },
+    payload: { payment, messages: pkg.messages, pack_code: pkg.code || null, pack_id: pkg.id  null },
   })
 
   const initPoint = transactionData.ticket_url || null
@@ -387,22 +408,23 @@ export async function syncMercadoPagoPayment(paymentId, eventPayload = null) {
       } else if (t === 'number' || t === 'boolean') {
         out[safeKey] = value
       } else {
-        out[safeKey] = Array.isArray(value) ? '[array]' : '[object]'
+        out[safeKey] = Array.isArray(value)  '[array]' : '[object]'
       }
     }
     return out
   }
   const logPaymentSnapshot = (paymentData) => {
+    const notificationUrl = sanitizeUrl(paymentData?.notification_url)
     const snapshot = {
       id: paymentData?.id ? String(paymentData.id) : String(paymentId),
       status: paymentData?.status || null,
       status_detail: paymentData?.status_detail || null,
-      live_mode: paymentData?.live_mode ?? null,
-      collector_id: paymentData?.collector_id ?? null,
-      transaction_amount: paymentData?.transaction_amount ?? null,
+      live_mode: paymentData?.live_mode  null,
+      collector_id: paymentData?.collector_id  null,
+      transaction_amount: paymentData?.transaction_amount  null,
       payment_method_id: paymentData?.payment_method_id || null,
       payment_type_id: paymentData?.payment_type_id || null,
-      notification_url: sanitizeUrl(paymentData?.notification_url),
+      notification_url: notificationUrl,
       external_reference: truncateText(paymentData?.external_reference, 200),
       description: truncateText(paymentData?.description, 200),
       metadata: summarizeMetadata(paymentData?.metadata),
@@ -410,6 +432,15 @@ export async function syncMercadoPagoPayment(paymentId, eventPayload = null) {
       date_approved: paymentData?.date_approved || null,
     }
     console.info('[billing:sync] payment_snapshot', snapshot)
+    if (paymentData?.live_mode === true) {
+      const normalizedUrl = String(notificationUrl || '').toLowerCase()
+      if (normalizedUrl.includes('ngrok')) {
+        console.warn('[billing:sync] live_payment_ngrok_notification', {
+          payment_id: snapshot.id,
+          notification_url: notificationUrl,
+        })
+      }
+    }
   }
   let payment = null
   const ignore = (reason, extra = null, resultExtra = null) => {
@@ -434,8 +465,15 @@ export async function syncMercadoPagoPayment(paymentId, eventPayload = null) {
   if (!payment?.id) throw new Error('Pagamento nao encontrado')
 
   const status = String(payment.status || '').toLowerCase()
+  const statusDetail = String(payment.status_detail || '').toLowerCase()
   const externalRef = String(payment.external_reference || '')
+  const externalRefLower = externalRef.toLowerCase()
   const metadataKind = String(payment?.metadata?.kind || '').toLowerCase()
+  const kindFromExternalRef = externalRefLower.startsWith('wallet:whatsapp_topup')
+     'whatsapp_topup'
+    : externalRefLower.startsWith('plan:')
+       'plan'
+      : ''
   // Tenta extrair tokens do external_reference
   const tokens = {}
   const parts = externalRef.split(':')
@@ -447,46 +485,44 @@ export async function syncMercadoPagoPayment(paymentId, eventPayload = null) {
   const estabId = Number(tokens.est || 0)
   const topupMessagesToken = Number(tokens.msgs || 0) || 0
   const packCodeToken = tokens.pack || null
-  const isTopup = metadataKind === 'whatsapp_topup' || String(tokens.wallet || '').toLowerCase() === 'whatsapp_topup'
+  const isTopup = kindFromExternalRef === 'whatsapp_topup' ||
+    metadataKind === 'whatsapp_topup' ||
+    String(tokens.wallet || '').toLowerCase() === 'whatsapp_topup'
   let topupMessages = Number(payment?.metadata?.messages || 0) || topupMessagesToken
   const packCode = payment?.metadata?.pack_code || packCodeToken || null
   const packIdRaw = payment?.metadata?.pack_id
-  const packId = Number.isFinite(Number(packIdRaw)) ? Number(packIdRaw) : null
+  const packId = Number.isFinite(Number(packIdRaw))  Number(packIdRaw) : null
   const packName = payment?.metadata?.pack_name || null
 
   // Recupera (se existir) a subscription criada ao gerar a preferência
   let subscription = null
-  if (payment.order?.id) {
-    // às vezes, o order.id não corresponde à preference, então mantemos fallback por external_reference
-  }
-  // fallback: tente localizar pelo external_reference (se já tivermos salvo)
-  if (!subscription) {
-    try {
-      const [rows] = await pool.query(
-        'SELECT * FROM subscriptions WHERE gateway_preference_id=? ORDER BY id DESC LIMIT 1',
-        [String(payment.id)]
-      )
-      subscription = rows?.[0]
-        ? {
-            id: rows[0].id,
-            estabelecimentoId: rows[0].estabelecimento_id,
-            plan: rows[0].plan,
-            amountCents: rows[0].amount_cents,
-            currency: rows[0].currency,
-            billingCycle: rows[0].billing_cycle,
-            gateway: rows[0].gateway,
-            gatewaySubscriptionId: rows[0].gateway_subscription_id,
-            gatewayPreferenceId: rows[0].gateway_preference_id,
-            status: rows[0].status,
-            lastEventId: rows[0].last_event_id,
-          }
-        : null
-    } catch {}
-  }
+  // prioridade: gateway_preference_id == payment.id
+  try {
+    const [rows] = await pool.query(
+      'SELECT * FROM subscriptions WHERE gateway_preference_id= ORDER BY id DESC LIMIT 1',
+      [String(payment.id)]
+    )
+    subscription = rows?.[0]
+       {
+          id: rows[0].id,
+          estabelecimentoId: rows[0].estabelecimento_id,
+          plan: rows[0].plan,
+          amountCents: rows[0].amount_cents,
+          currency: rows[0].currency,
+          billingCycle: rows[0].billing_cycle,
+          gateway: rows[0].gateway,
+          gatewaySubscriptionId: rows[0].gateway_subscription_id,
+          gatewayPreferenceId: rows[0].gateway_preference_id,
+          status: rows[0].status,
+          lastEventId: rows[0].last_event_id,
+        }
+      : null
+  } catch {}
+  // fallback: external_reference
   if (!subscription && externalRef) {
     try {
-      const [rows] = await pool.query('SELECT * FROM subscriptions WHERE external_reference=? ORDER BY id DESC LIMIT 1', [externalRef])
-      subscription = rows?.[0] ? {
+      const [rows] = await pool.query('SELECT * FROM subscriptions WHERE external_reference= ORDER BY id DESC LIMIT 1', [externalRef])
+      subscription = rows?.[0]  {
         id: rows[0].id,
         estabelecimentoId: rows[0].estabelecimento_id,
         plan: rows[0].plan,
@@ -503,10 +539,10 @@ export async function syncMercadoPagoPayment(paymentId, eventPayload = null) {
   }
 
   // Se não conseguimos inferir, mas temos tokens válidos, crie um registro minimamente coerente
-  if (!subscription && estabId && (PLAN_TIERS.includes(planToken) || isTopup)) {
+  if (!subscription && estabId && (PLAN_TIERS.includes(planToken) || kindFromExternalRef === 'plan' || isTopup)) {
     subscription = await createSubscription({
       estabelecimentoId: estabId,
-      plan: PLAN_TIERS.includes(planToken) ? planToken : 'starter',
+      plan: PLAN_TIERS.includes(planToken)  planToken : 'starter',
       amountCents: Math.round(Number(payment.transaction_amount || 0) * 100),
       currency: (payment.currency_id || BILLING_CURRENCY).toUpperCase(),
       status: 'pending',
@@ -517,6 +553,23 @@ export async function syncMercadoPagoPayment(paymentId, eventPayload = null) {
     })
   }
 
+  if (status === 'cancelled' && statusDetail === 'expired' && subscription?.id && String(subscription.status || '').toLowerCase() === 'pending') {
+    await pool.query(
+      `UPDATE subscriptions
+       SET status='canceled', canceled_at=NOW(), updated_at=NOW(), last_event_id=?
+       WHERE id= AND status='pending'`,
+      [String(payment.id), subscription.id]
+    )
+    if (subscription?.id) {
+      await appendSubscriptionEvent(subscription.id, {
+        eventType: 'payment.cancelled',
+        gatewayEventId: String(payment.id),
+        payload: { event: eventPayload, payment },
+      })
+    }
+    return { ok: true, action: 'canceled_expired', payment }
+  }
+
   if (subscription?.lastEventId && String(subscription.lastEventId) === String(payment.id)) {
     if (status === 'approved') {
       return { ok: true, payment, already_processed: true }
@@ -597,7 +650,7 @@ export async function syncMercadoPagoPayment(paymentId, eventPayload = null) {
   }
 
   // status approved: ativa plano por 1 ciclo a partir de hoje (PIX fallback)
-  const effectivePlan = (PLAN_TIERS.includes(planToken) ? planToken : (subscription?.plan || 'pro'))
+  const effectivePlan = (PLAN_TIERS.includes(planToken)  planToken : (subscription?.plan || 'pro'))
   const effectiveCycle = cycleToken || subscription?.billingCycle || 'mensal'
   const activeUntil = addCycle(new Date(), effectiveCycle)
 
@@ -620,10 +673,70 @@ export async function syncMercadoPagoPayment(paymentId, eventPayload = null) {
   // Atualiza o usuário
   if (subscription?.estabelecimentoId || estabId) {
     const estabelecimentoId = subscription?.estabelecimentoId || estabId
-    const sql = `UPDATE usuarios SET plan=?, plan_status='active', plan_cycle=?, plan_trial_ends_at=NULL, plan_active_until=?, plan_subscription_id=NULL WHERE id=? AND tipo='estabelecimento' LIMIT 1`
+    const sql = `UPDATE usuarios SET plan=?, plan_status='active', plan_cycle=?, plan_trial_ends_at=NULL, plan_active_until=?, plan_subscription_id=NULL WHERE id= AND tipo='estabelecimento' LIMIT 1`
     await pool.query(sql, [effectivePlan, effectiveCycle, activeUntil, estabelecimentoId])
     try { await getWhatsAppWalletSnapshot(estabelecimentoId) } catch {}
   }
 
   return { ok: true, payment, plan: effectivePlan, cycle: effectiveCycle, active_until: activeUntil }
 }
+
+export async function fetchMercadoPagoPayment(paymentId, { accessToken = null } = {}) {
+  if (!paymentId) throw new Error('paymentId ausente')
+  const client = resolveMercadoPagoPayment(accessToken)
+  return client.get({ id: String(paymentId) })
+}
+
+export async function createMercadoPagoPixPayment({
+  amountCents,
+  description,
+  externalReference,
+  metadata,
+  notificationUrl,
+  payerEmail,
+  expiresAt = null,
+  accessToken = null,
+}) {
+  const paymentClient = resolveMercadoPagoPayment(accessToken)
+  const amountNum = Number((Number(amountCents || 0) / 100).toFixed(2))
+
+  const paymentBody = {
+    transaction_amount: amountNum,
+    description: description || 'Agendamentos Online - Pagamento',
+    payment_method_id: 'pix',
+    external_reference: externalReference,
+    metadata,
+    notification_url: notificationUrl,
+    payer: payerEmail  { email: payerEmail } : undefined,
+  }
+
+  if (expiresAt) {
+    const exp = new Date(expiresAt)
+    if (Number.isFinite(exp.getTime())) {
+      paymentBody.date_of_expiration = exp.toISOString()
+    }
+  }
+
+  let payment
+  try {
+    payment = await paymentClient.create({ body: paymentBody })
+  } catch (e) {
+    const detail = extractMpError(e)
+    console.error('[mp][payment.create][deposit] error', detail)
+    throw new Error('mercadopago_payment_error: ' + detail)
+  }
+  if (!payment?.id) throw new Error('mercadopago_payment_error: pagamento sem id')
+
+  const txData = payment?.point_of_interaction?.transaction_data || {}
+  const pixPayload = {
+    payment_id: String(payment.id),
+    qr_code: txData.qr_code || null,
+    qr_code_base64: txData.qr_code_base64 || null,
+    copia_e_cola: txData.copia_e_cola || txData.qr_code || null,
+    ticket_url: txData.ticket_url || null,
+    expires_at: txData.expires_at || payment?.date_of_expiration || null,
+    amount_cents: amountCents,
+  }
+
+  return { payment, pix: pixPayload }
+}
diff --git a/backend/src/lib/notifications.js b/backend/src/lib/notifications.js
index 2680f12..a22973a 100644
--- a/backend/src/lib/notifications.js
+++ b/backend/src/lib/notifications.js
@@ -1,704 +1,747 @@
-// backend/src/lib/notifications.js
-import nodemailer from 'nodemailer';
-import { getWhatsAppLastInboundAt, isWhatsAppWindowOpen } from './whatsapp_contacts.js';
-import { decryptAccessToken } from '../services/waCrypto.js';
-import { extractWamid, sendWhatsAppMessage } from '../services/waGraph.js';
-import { buildConfirmacaoAgendamentoV2Components, isConfirmacaoAgendamentoV2 } from './whatsapp_templates.js';
-import { getWaAccountByEstabelecimentoId, recordWaMessage } from '../services/waTenant.js';
-
-/**
- * Configuração (via ENV)
- *
- * WA_PHONE_NUMBER_ID=...             // fallback/dev
- * WA_TOKEN=...                       // fallback/dev (legado)
- * WA_DEFAULT_TOKEN=...               // fallback/dev (opcional)
- * WA_API_VERSION=v23.0
- * WA_FORCE_TEMPLATE=true|false
- * WA_TEMPLATE_NAME=hello_world
- * WA_TEMPLATE_LANG=en_US
- * WA_TEMPLATE_HAS_BODY_PARAM=0|1          // 1 se seu template tiver {{1}} no corpo
- * WHATSAPP_ALLOWED_LIST=551199...,551198...  // dígitos; aceitamos com + também
- * WA_DEBUG_LOG=true|false
- *
- * SMTP_HOST=...
- * SMTP_PORT=587
- * SMTP_SECURE=false
- * SMTP_USER=...
- * SMTP_PASS=...
- * EMAIL_FROM="Agendamentos Online" <no-reply@seu-dominio>
- */
-
-const parseBool = (value) => /^(1|true|yes|on)$/i.test(String(value || '').trim());
-
-const cfg = {
-  defaultPhoneId: process.env.WA_PHONE_NUMBER_ID,
-  defaultToken: process.env.WA_DEFAULT_TOKEN || process.env.WA_TOKEN,
-  apiVersion: process.env.WA_API_VERSION || 'v23.0',
-
-  forceTemplate: parseBool(process.env.WA_FORCE_TEMPLATE),
-  templateName: process.env.WA_TEMPLATE_NAME || 'hello_world',
-  templateLang: process.env.WA_TEMPLATE_LANG || 'en_US',
-  templateHasBodyParam: parseBool(process.env.WA_TEMPLATE_HAS_BODY_PARAM),
-
-  allowedList: String(process.env.WHATSAPP_ALLOWED_LIST || '')
-    .split(',')
-    .map(s => s.trim())
-    .filter(Boolean)
-    .map(normalizePhoneDigits)
-    .filter(Boolean),
-
-  debug: parseBool(process.env.WA_DEBUG_LOG),
-};
-
-const toDigits = s => String(s || '').replace(/\D/g, '');
-
-function normalizePhoneDigits(value) {
-  let digits = toDigits(value);
-  if (!digits) return '';
-  digits = digits.replace(/^0+/, '');
-  if (digits.startsWith('55')) return digits;
-  if (digits.length >= 10 && digits.length <= 11) return `55${digits}`;
-  return digits;
-}
-
-function isAllowed(to) {
-  const n = normalizePhoneDigits(to);
-  if (!n) return false;
-  if (!cfg.allowedList.length) return true;
-  return cfg.allowedList.includes(n);
-}
-
-function maskPhone(phone) {
-  const digits = toDigits(phone);
-  if (!digits) return '';
-  if (digits.length <= 4) return '*'.repeat(digits.length);
-  return `${'*'.repeat(digits.length - 4)}${digits.slice(-4)}`;
-}
-
-function summarizePayload(payload) {
-  if (!payload || typeof payload !== 'object') return null;
-  const type = payload.type || 'unknown';
-  if (type === 'template') {
-    const template = payload.template || {};
-    const components = Array.isArray(template.components) ? template.components : [];
-    const templateSummary = {
-      name: template.name,
-      lang: template.language?.code,
-    };
-    if (components.length) {
-      templateSummary.components = components.map((comp) => ({
-        type: comp?.type,
-        params: Array.isArray(comp?.parameters) ? comp.parameters.length : 0,
-      }));
-    }
-    return {
-      type,
-      template: templateSummary,
-    };
-  }
-  if (type === 'text') {
-    const body = payload.text?.body || '';
-    return {
-      type,
-      text: {
-        length: String(body).length,
-        preview: Boolean(payload.text?.preview_url),
-      },
-    };
-  }
-  if (type === 'interactive') {
-    return { type, interactive: { hasBody: Boolean(payload.interactive?.body) } };
-  }
-  return { type };
-}
-
-function logSend({ phone, payload, context }) {
-  const summary = summarizePayload(payload);
-  const base = {
-    type: summary?.type || payload?.type || 'unknown',
-    to: maskPhone(phone),
-    payload: summary,
-  };
-  if (context) base.context = context;
-  console.log('[wa/send]', JSON.stringify(base));
-}
-
-function logSendResult({ phone, payloadType, wamid, context }) {
-  const base = { type: payloadType || 'unknown', to: maskPhone(phone), wamid: wamid || null };
-  if (context) base.context = context;
-  console.log('[wa/send/ok]', JSON.stringify(base));
-}
-
-function is24hWindowError(err) {
-  const msg = (err?.body && typeof err.body === 'object')
-    ? (err.body.error?.message || '')
-    : String(err?.body || err?.message || '');
-  const code = err?.body?.error?.code;
-  const sub = err?.body?.error?.error_subcode;
-  return code === 470 || sub === 2018028 || sub === 131047 || /24\s*h/i.test(msg) || err?.status === 400;
-}
-
-function buildTemplateParamError({ name, expected, provided }) {
-  const err = new Error(`WA template ${name} requires ${expected} params, provided ${provided}`);
-  err.code = 'wa_template_params_missing';
-  err.status = 400;
-  err.body = {
-    error: {
-      message: 'template_params_missing',
-      code: 'wa_template_params_missing',
-      error_data: { template: name, expected, provided },
-    },
-  };
-  return err;
-}
-
-function normalizeTemplateBodyParams({ name, bodyParams, phone, context }) {
-  const rawParams = Array.isArray(bodyParams) ? bodyParams : [];
-  if (isConfirmacaoAgendamentoV2(name)) {
-    if (rawParams.length !== 3) {
-      const base = {
-        template: name,
-        expected: 3,
-        provided: rawParams.length,
-        to: maskPhone(phone),
-      };
-      if (context) base.context = context;
-      console.warn('[wa/template] missing params, skip send', base);
-      throw buildTemplateParamError({ name, expected: 3, provided: rawParams.length });
-    }
-    return buildConfirmacaoAgendamentoV2Components({
-      serviceLabel: rawParams[0],
-      dataHoraLabel: rawParams[1],
-      estabelecimentoNome: rawParams[2],
-    });
-  }
-  if (cfg.templateHasBodyParam && rawParams.length === 0) {
-    const base = {
-      template: name,
-      expected: 1,
-      provided: 0,
-      to: maskPhone(phone),
-    };
-    if (context) base.context = context;
-    console.warn('[wa/template] missing params, skip send', base);
-    throw buildTemplateParamError({ name, expected: 1, provided: 0 });
-  }
-  return rawParams;
-}
-
-function buildTemplateComponents(params) {
-  if (!Array.isArray(params) || params.length === 0) return null;
-  return [{
-    type: 'body',
-    parameters: params.map((value) => ({ type: 'text', text: String(value) })),
-  }];
-}
-
-function countBodyParams(components) {
-  if (!Array.isArray(components)) return 0;
-  return components
-    .filter((comp) => comp?.type === 'body')
-    .reduce((sum, comp) => sum + (Array.isArray(comp?.parameters) ? comp.parameters.length : 0), 0);
-}
-
-async function resolveTenantConfig(context = {}) {
-  const estabelecimentoId = Number(context?.estabelecimentoId || 0) || null;
-  if (estabelecimentoId) {
-    try {
-      const account = await getWaAccountByEstabelecimentoId(estabelecimentoId);
-      if (
-        account &&
-        account.status === 'connected' &&
-        account.phone_number_id &&
-        account.access_token_enc
-      ) {
-        const token = decryptAccessToken(account.access_token_enc);
-        if (token) {
-          return {
-            token,
-            phoneId: account.phone_number_id,
-            estabelecimentoId: account.estabelecimento_id,
-            fallback: false,
-          };
-        }
-      }
-    } catch (err) {
-      console.warn('[wa][tenant] resolve failed', err?.message || err);
-    }
-  }
-
-  if (cfg.defaultToken && cfg.defaultPhoneId) {
-    return {
-      token: cfg.defaultToken,
-      phoneId: cfg.defaultPhoneId,
-      estabelecimentoId,
-      fallback: true,
-    };
-  }
-
-  return { token: null, phoneId: null, estabelecimentoId, fallback: false };
-}
-
-async function recordOutboundMessage({ tenant, phone, payload, resp }) {
-  if (!tenant?.estabelecimentoId) return;
-  try {
-    await recordWaMessage({
-      estabelecimentoId: tenant.estabelecimentoId,
-      direction: 'out',
-      waId: phone,
-      wamid: extractWamid(resp),
-      phoneNumberId: tenant.phoneId,
-      payload,
-      status: 'sent',
-    });
-  } catch (err) {
-    console.warn('[wa][outbound] record failed', err?.message || err);
-  }
-}
-
-async function sendText({ to, message, context, tenant }) {
-  const phone = normalizePhoneDigits(to);
-  if (!phone) {
-    if (cfg.debug) console.warn('[whatsapp] invalid phone -> %s', to);
-    return { invalid: true };
-  }
-  if (!isAllowed(phone)) {
-    if (cfg.debug) console.warn('[whatsapp] bloqueado por ALLOWED_LIST -> %s', phone);
-    return { blocked: true };
-  }
-  const resolved = tenant || await resolveTenantConfig(context);
-  if (!resolved.token || !resolved.phoneId) {
-    const err = new Error('WA config missing (token/phoneId)');
-    err.code = 'wa_not_connected';
-    throw err;
-  }
-
-  const payload = {
-    messaging_product: 'whatsapp',
-    to: phone,
-    type: 'text',
-    text: { preview_url: false, body: String(message || '') },
-  };
-  logSend({ phone, payload, context });
-  const resp = await sendWhatsAppMessage({
-    accessToken: resolved.token,
-    phoneNumberId: resolved.phoneId,
-    payload,
-  });
-  logSendResult({ phone, payloadType: payload.type, wamid: extractWamid(resp), context });
-  await recordOutboundMessage({ tenant: resolved, phone, payload, resp });
-  return resp;
-}
-
-// ============== WhatsApp: Template ==============
-export async function sendTemplate({
-  to,
-  name,
-  lang,
-  components,
-  bodyParams = [],
-  headerImageUrl,
-  headerDocumentUrl,
-  headerVideoUrl,
-  headerText,
-  context,
-  estabelecimentoId,
-  tenant,
-}) {
-  const phone = normalizePhoneDigits(to);
-  if (!phone) {
-    if (cfg.debug) console.warn('[whatsapp] invalid phone -> %s', to);
-    return { invalid: true };
-  }
-  if (!isAllowed(phone)) {
-    if (cfg.debug) console.warn('[whatsapp] bloqueado por ALLOWED_LIST -> %s', phone);
-    return { blocked: true };
-  }
-  const resolved = tenant || await resolveTenantConfig(context || { estabelecimentoId });
-  if (!resolved.token || !resolved.phoneId) {
-    const err = new Error('WA config missing (token/phoneId)');
-    err.code = 'wa_not_connected';
-    throw err;
-  }
-
-  const template = {
-    name: name || cfg.templateName,
-    language: { code: lang || cfg.templateLang },
-  };
-  const componentsOverride = Array.isArray(components) && components.length > 0 ? components : null;
-  let bodyParamsNormalized = [];
-  const componentsList = [];
-  if (!componentsOverride) {
-    bodyParamsNormalized = normalizeTemplateBodyParams({
-      name: template.name,
-      bodyParams,
-      phone,
-      context,
-    });
-  }
-
-  const nameLower = String(name || cfg.templateName || '').toLowerCase();
-
-  // Herdar header de imagem do .env quando nao for enviado via argumento
-  let headerImage = headerImageUrl || null;
-  if (!headerImage && /lembrete_agendamento_v2/.test(nameLower) && process.env.WA_TEMPLATE_REMINDER_HEADER_URL) {
-    headerImage = process.env.WA_TEMPLATE_REMINDER_HEADER_URL;
-  }
-  if (!headerImage && process.env.WA_TEMPLATE_HEADER_IMAGE_URL) {
-    headerImage = process.env.WA_TEMPLATE_HEADER_IMAGE_URL;
-  }
-  if (!headerImage && process.env.WA_TEMPLATE_HEADER_URL) {
-    headerImage = process.env.WA_TEMPLATE_HEADER_URL;
-  }
-
-  if (componentsOverride) {
-    componentsList.push(...componentsOverride);
-  } else {
-    // Header opcional (necessario se o template tiver header de imagem/documento/video/texto)
-    if (headerImage) {
-      componentsList.push({
-        type: 'header',
-        parameters: [{ type: 'image', image: { link: headerImage } }],
-      });
-    } else if (headerDocumentUrl) {
-      componentsList.push({
-        type: 'header',
-        parameters: [{ type: 'document', document: { link: headerDocumentUrl } }],
-      });
-    } else if (headerVideoUrl) {
-      componentsList.push({
-        type: 'header',
-        parameters: [{ type: 'video', video: { link: headerVideoUrl } }],
-      });
-    } else if (headerText) {
-      componentsList.push({
-        type: 'header',
-        parameters: [{ type: 'text', text: String(headerText) }],
-      });
-    }
-
-    // IMPORTANTE: so inclua components se houver params (evita erro 132000)
-    if (Array.isArray(bodyParamsNormalized) && bodyParamsNormalized.length > 0) {
-      componentsList.push({
-        type: 'body',
-        parameters: bodyParamsNormalized.map(t => ({ type: 'text', text: String(t) })),
-      });
-    }
-  }
-
-  if (componentsList.length) template.components = componentsList;
-
-  const payload = {
-    messaging_product: 'whatsapp',
-    to: phone,
-    type: 'template',
-    template,
-  };
-
-  const paramsCount = componentsOverride
-    ? countBodyParams(componentsList)
-    : bodyParamsNormalized.length;
-  if (cfg.debug) {
-    console.log('[wa/cloud/template] to=%s name=%s lang=%s params=%d',
-      phone, template.name, template.language?.code, paramsCount);
-  }
-  logSend({ phone, payload, context });
-  const resp = await sendWhatsAppMessage({
-    accessToken: resolved.token,
-    phoneNumberId: resolved.phoneId,
-    payload,
-  });
-  logSendResult({ phone, payloadType: payload.type, wamid: extractWamid(resp), context });
-  await recordOutboundMessage({ tenant: resolved, phone, payload, resp });
-  return resp;
-}
-// ============== WhatsApp: Texto (ou Template se forceTemplate=true) ==============
-export async function notifyWhatsapp(message, to, options = {}) {
-  const context = options?.context || (options?.estabelecimentoId ? { estabelecimentoId: options.estabelecimentoId } : undefined);
-  return sendWhatsAppSmart({ to, message, context });
-}
-
-export async function sendWhatsAppSmart({
-  to,
-  message,
-  text,
-  template,
-  templateName,
-  templateParams,
-  templateNameFallback,
-  templateLangFallback,
-  allowText = true,
-  forceTemplate,
-  context,
-  estabelecimentoId,
-  returnMeta = false,
-} = {}) {
+// backend/src/lib/notifications.js

+import nodemailer from 'nodemailer';
+import { getWhatsAppLastInboundAt, isWhatsAppWindowOpen } from './whatsapp_contacts.js';
+import { decryptAccessToken } from '../services/waCrypto.js';
+import { extractWamid, sendWhatsAppMessage } from '../services/waGraph.js';
+import { buildConfirmacaoAgendamentoV2Components, isConfirmacaoAgendamentoV2 } from './whatsapp_templates.js';
+import { getWaAccountByEstabelecimentoId, recordWaMessage } from '../services/waTenant.js';
+

+/**

+ * Configuração (via ENV)

+ *

+ * WA_PHONE_NUMBER_ID=...             // fallback/dev
+ * WA_TOKEN=...                       // fallback/dev (legado)
+ * WA_DEFAULT_TOKEN=...               // fallback/dev (opcional)
+ * WA_API_VERSION=v23.0

+ * WA_FORCE_TEMPLATE=true|false

+ * WA_TEMPLATE_NAME=hello_world

+ * WA_TEMPLATE_LANG=en_US

+ * WA_TEMPLATE_HAS_BODY_PARAM=0|1          // 1 se seu template tiver {{1}} no corpo

+ * WHATSAPP_ALLOWED_LIST=551199...,551198...  // dígitos; aceitamos com + também

+ * WA_DEBUG_LOG=true|false

+ *

+ * SMTP_HOST=...

+ * SMTP_PORT=587

+ * SMTP_SECURE=false

+ * SMTP_USER=...

+ * SMTP_PASS=...

+ * EMAIL_FROM="Agendamentos Online" <no-reply@seu-dominio>

+ */

+

+const parseBool = (value) => /^(1|true|yes|on)$/i.test(String(value || '').trim());
+
+const cfg = {
+  defaultPhoneId: process.env.WA_PHONE_NUMBER_ID,
+  defaultToken: process.env.WA_DEFAULT_TOKEN || process.env.WA_TOKEN,
+  apiVersion: process.env.WA_API_VERSION || 'v23.0',
+
+  forceTemplate: parseBool(process.env.WA_FORCE_TEMPLATE),
+  templateName: process.env.WA_TEMPLATE_NAME || 'hello_world',
+  templateLang: process.env.WA_TEMPLATE_LANG || 'en_US',
+  templateHasBodyParam: parseBool(process.env.WA_TEMPLATE_HAS_BODY_PARAM),
+

+  allowedList: String(process.env.WHATSAPP_ALLOWED_LIST || '')

+    .split(',')

+    .map(s => s.trim())

+    .filter(Boolean)

+    .map(normalizePhoneDigits)

+    .filter(Boolean),

+

+  debug: parseBool(process.env.WA_DEBUG_LOG),
+};
+

+const toDigits = s => String(s || '').replace(/\D/g, '');
+
+function normalizeAccessToken(value) {
+  const token = (value || '').toString().trim();
+  if (!token) return '';
+  const lower = token.toLowerCase();
+  if (lower === 'undefined' || lower === 'null') return '';
+  return token;
+}
+
+function logTokenDebug({ source, token, phoneNumberId }) {
+  if (!cfg.debug) return;
+  const safe = normalizeAccessToken(token);
+  console.log('[wa/token]', {
+    source,
+    tokenLen: safe.length,
+    tokenPrefix: safe.slice(0, 6),
+    phoneNumberId: phoneNumberId || null,
+  });
+}
+
+function normalizePhoneDigits(value) {
+  let digits = toDigits(value);
+  if (!digits) return '';
+  digits = digits.replace(/^0+/, '');

+  if (digits.startsWith('55')) return digits;

+  if (digits.length >= 10 && digits.length <= 11) return `55${digits}`;

+  return digits;

+}

+

+function isAllowed(to) {
+  const n = normalizePhoneDigits(to);
+  if (!n) return false;
+  if (!cfg.allowedList.length) return true;
+  return cfg.allowedList.includes(n);
+}
+
+function maskPhone(phone) {
+  const digits = toDigits(phone);
+  if (!digits) return '';
+  if (digits.length <= 4) return '*'.repeat(digits.length);
+  return `${'*'.repeat(digits.length - 4)}${digits.slice(-4)}`;
+}
+
+function summarizePayload(payload) {
+  if (!payload || typeof payload !== 'object') return null;
+  const type = payload.type || 'unknown';
+  if (type === 'template') {
+    const template = payload.template || {};
+    const components = Array.isArray(template.components)  template.components : [];
+    const templateSummary = {
+      name: template.name,
+      lang: template.language?.code,
+    };
+    if (components.length) {
+      templateSummary.components = components.map((comp) => ({
+        type: comp?.type,
+        params: Array.isArray(comp?.parameters)  comp.parameters.length : 0,
+      }));
+    }
+    return {
+      type,
+      template: templateSummary,
+    };
+  }
+  if (type === 'text') {
+    const body = payload.text?.body || '';
+    return {
+      type,
+      text: {
+        length: String(body).length,
+        preview: Boolean(payload.text?.preview_url),
+      },
+    };
+  }
+  if (type === 'interactive') {
+    return { type, interactive: { hasBody: Boolean(payload.interactive?.body) } };
+  }
+  return { type };
+}
+
+function logSend({ phone, payload, context }) {
+  const summary = summarizePayload(payload);
+  const base = {
+    type: summary?.type || payload?.type || 'unknown',
+    to: maskPhone(phone),
+    payload: summary,
+  };
+  if (context) base.context = context;
+  console.log('[wa/send]', JSON.stringify(base));
+}
+
+function logSendResult({ phone, payloadType, wamid, context }) {
+  const base = { type: payloadType || 'unknown', to: maskPhone(phone), wamid: wamid || null };
+  if (context) base.context = context;
+  console.log('[wa/send/ok]', JSON.stringify(base));
+}
+
+function is24hWindowError(err) {
+  const msg = (err?.body && typeof err.body === 'object')
+     (err.body.error?.message || '')
+    : String(err?.body || err?.message || '');
+  const code = err?.body?.error?.code;
+  const sub = err?.body?.error?.error_subcode;
+  return code === 470 || sub === 2018028 || sub === 131047 || /24\s*h/i.test(msg) || err?.status === 400;
+}
+
+function buildTemplateParamError({ name, expected, provided }) {
+  const err = new Error(`WA template ${name} requires ${expected} params, provided ${provided}`);
+  err.code = 'wa_template_params_missing';
+  err.status = 400;
+  err.body = {
+    error: {
+      message: 'template_params_missing',
+      code: 'wa_template_params_missing',
+      error_data: { template: name, expected, provided },
+    },
+  };
+  return err;
+}
+
+function normalizeTemplateBodyParams({ name, bodyParams, phone, context }) {
+  const rawParams = Array.isArray(bodyParams)  bodyParams : [];
+  if (isConfirmacaoAgendamentoV2(name)) {
+    if (rawParams.length !== 3) {
+      const base = {
+        template: name,
+        expected: 3,
+        provided: rawParams.length,
+        to: maskPhone(phone),
+      };
+      if (context) base.context = context;
+      console.warn('[wa/template] missing params, skip send', base);
+      throw buildTemplateParamError({ name, expected: 3, provided: rawParams.length });
+    }
+    return buildConfirmacaoAgendamentoV2Components({
+      serviceLabel: rawParams[0],
+      dataHoraLabel: rawParams[1],
+      estabelecimentoNome: rawParams[2],
+    });
+  }
+  if (cfg.templateHasBodyParam && rawParams.length === 0) {
+    const base = {
+      template: name,
+      expected: 1,
+      provided: 0,
+      to: maskPhone(phone),
+    };
+    if (context) base.context = context;
+    console.warn('[wa/template] missing params, skip send', base);
+    throw buildTemplateParamError({ name, expected: 1, provided: 0 });
+  }
+  return rawParams;
+}
+
+function buildTemplateComponents(params) {
+  if (!Array.isArray(params) || params.length === 0) return null;
+  return [{
+    type: 'body',
+    parameters: params.map((value) => ({ type: 'text', text: String(value) })),
+  }];
+}
+
+function countBodyParams(components) {
+  if (!Array.isArray(components)) return 0;
+  return components
+    .filter((comp) => comp?.type === 'body')
+    .reduce((sum, comp) => sum + (Array.isArray(comp?.parameters)  comp.parameters.length : 0), 0);
+}
+

+async function resolveTenantConfig(context = {}) {
+  const estabelecimentoId = Number(context?.estabelecimentoId || 0) || null;
+  if (estabelecimentoId) {
+    try {
+      const account = await getWaAccountByEstabelecimentoId(estabelecimentoId);
+      if (
+        account &&
+        account.status === 'connected' &&
+        account.phone_number_id &&
+        account.access_token_enc
+      ) {
+        const token = normalizeAccessToken(decryptAccessToken(account.access_token_enc));
+        if (token) {
+          logTokenDebug({ source: 'db', token, phoneNumberId: account.phone_number_id });
+          return {
+            token,
+            phoneId: account.phone_number_id,
+            estabelecimentoId: account.estabelecimento_id,
+            fallback: false,
+          };
+        }
+      }
+    } catch (err) {
+      console.warn('[wa][tenant] resolve failed', err?.message || err);
+    }
+  }
+
+  const fallbackToken = normalizeAccessToken(cfg.defaultToken);
+  const fallbackPhoneId = String(cfg.defaultPhoneId || '').trim();
+  if (fallbackToken && fallbackPhoneId) {
+    logTokenDebug({ source: 'env', token: fallbackToken, phoneNumberId: fallbackPhoneId });
+    return {
+      token: fallbackToken,
+      phoneId: fallbackPhoneId,
+      estabelecimentoId,
+      fallback: true,
+    };
+  }
+
+  return { token: null, phoneId: null, estabelecimentoId, fallback: false, reason: 'wa_not_connected' };
+}
+
+async function recordOutboundMessage({ tenant, phone, payload, resp }) {
+  if (!tenant?.estabelecimentoId) return;
+  try {
+    await recordWaMessage({
+      estabelecimentoId: tenant.estabelecimentoId,
+      direction: 'out',
+      waId: phone,
+      wamid: extractWamid(resp),
+      phoneNumberId: tenant.phoneId,
+      payload,
+      status: 'sent',
+    });
+  } catch (err) {
+    console.warn('[wa][outbound] record failed', err?.message || err);
+  }
+}
+
+async function sendText({ to, message, context, tenant }) {
+  const phone = normalizePhoneDigits(to);
+  if (!phone) {
+    if (cfg.debug) console.warn('[whatsapp] invalid phone -> %s', to);
+    return { invalid: true };
+  }
+  if (!isAllowed(phone)) {
+    if (cfg.debug) console.warn('[whatsapp] bloqueado por ALLOWED_LIST -> %s', phone);
+    return { blocked: true };
+  }
+  const resolved = tenant || await resolveTenantConfig(context);
+  const token = normalizeAccessToken(resolved?.token);
+  if (!token) {
+    console.warn('[wa/token] missing_access_token', {
+      estabelecimentoId: resolved?.estabelecimentoId || null,
+      phoneNumberId: resolved?.phoneId || null,
+      tokenLen: token.length,
+    });
+    return {
+      ok: false,
+      reason: 'missing_access_token',
+    };
+  }
+  if (!resolved?.phoneId) {
+    return { ok: false, reason: resolved?.reason || 'wa_not_connected' };
+  }
+
+  const payload = {
+    messaging_product: 'whatsapp',
+    to: phone,
+    type: 'text',
+    text: { preview_url: false, body: String(message || '') },
+  };
+  logSend({ phone, payload, context });
+  const resp = await sendWhatsAppMessage({
+    accessToken: token,
+    phoneNumberId: resolved.phoneId,
+    payload,
+  });
+  logSendResult({ phone, payloadType: payload.type, wamid: extractWamid(resp), context });
+  await recordOutboundMessage({ tenant: resolved, phone, payload, resp });
+  return resp;
+}
+
+// ============== WhatsApp: Template ==============
+export async function sendTemplate({
+  to,
+  name,
+  lang,
+  components,
+  bodyParams = [],
+  headerImageUrl,
+  headerDocumentUrl,
+  headerVideoUrl,
+  headerText,
+  context,
+  estabelecimentoId,
+  tenant,
+}) {
+  const phone = normalizePhoneDigits(to);
+  if (!phone) {
+    if (cfg.debug) console.warn('[whatsapp] invalid phone -> %s', to);
+    return { invalid: true };
+  }
+  if (!isAllowed(phone)) {
+    if (cfg.debug) console.warn('[whatsapp] bloqueado por ALLOWED_LIST -> %s', phone);
+    return { blocked: true };
+  }
+  const resolved = tenant || await resolveTenantConfig(context || { estabelecimentoId });
+  const token = normalizeAccessToken(resolved?.token);
+  if (!token) {
+    console.warn('[wa/token] missing_access_token', {
+      estabelecimentoId: resolved?.estabelecimentoId || null,
+      phoneNumberId: resolved?.phoneId || null,
+      tokenLen: token.length,
+    });
+    return {
+      ok: false,
+      reason: 'missing_access_token',
+    };
+  }
+  if (!resolved?.phoneId) {
+    return { ok: false, reason: resolved?.reason || 'wa_not_connected' };
+  }
+

+  const template = {
+    name: name || cfg.templateName,
+    language: { code: lang || cfg.templateLang },
+  };
+  const componentsOverride = Array.isArray(components) && components.length > 0  components : null;
+  let bodyParamsNormalized = [];
+  const componentsList = [];
+  if (!componentsOverride) {
+    bodyParamsNormalized = normalizeTemplateBodyParams({
+      name: template.name,
+      bodyParams,
+      phone,
+      context,
+    });
+  }
+
+  const nameLower = String(name || cfg.templateName || '').toLowerCase();
+
+  // Herdar header de imagem do .env quando nao for enviado via argumento
+  let headerImage = headerImageUrl || null;

+  if (!headerImage && /lembrete_agendamento_v2/.test(nameLower) && process.env.WA_TEMPLATE_REMINDER_HEADER_URL) {

+    headerImage = process.env.WA_TEMPLATE_REMINDER_HEADER_URL;

+  }

+  if (!headerImage && process.env.WA_TEMPLATE_HEADER_IMAGE_URL) {

+    headerImage = process.env.WA_TEMPLATE_HEADER_IMAGE_URL;

+  }

+  if (!headerImage && process.env.WA_TEMPLATE_HEADER_URL) {

+    headerImage = process.env.WA_TEMPLATE_HEADER_URL;

+  }

+

+  if (componentsOverride) {
+    componentsList.push(...componentsOverride);
+  } else {
+    // Header opcional (necessario se o template tiver header de imagem/documento/video/texto)
+    if (headerImage) {
+      componentsList.push({
+        type: 'header',
+        parameters: [{ type: 'image', image: { link: headerImage } }],
+      });
+    } else if (headerDocumentUrl) {
+      componentsList.push({
+        type: 'header',
+        parameters: [{ type: 'document', document: { link: headerDocumentUrl } }],
+      });
+    } else if (headerVideoUrl) {
+      componentsList.push({
+        type: 'header',
+        parameters: [{ type: 'video', video: { link: headerVideoUrl } }],
+      });
+    } else if (headerText) {
+      componentsList.push({
+        type: 'header',
+        parameters: [{ type: 'text', text: String(headerText) }],
+      });
+    }
+
+    // IMPORTANTE: so inclua components se houver params (evita erro 132000)
+    if (Array.isArray(bodyParamsNormalized) && bodyParamsNormalized.length > 0) {
+      componentsList.push({
+        type: 'body',
+        parameters: bodyParamsNormalized.map(t => ({ type: 'text', text: String(t) })),
+      });
+    }
+  }
+
+  if (componentsList.length) template.components = componentsList;
+
+  const payload = {
+    messaging_product: 'whatsapp',
+    to: phone,
+    type: 'template',

+    template,

+  };

+

+  const paramsCount = componentsOverride
+     countBodyParams(componentsList)
+    : bodyParamsNormalized.length;
+  if (cfg.debug) {
+    console.log('[wa/cloud/template] to=%s name=%s lang=%s params=%d',
+      phone, template.name, template.language?.code, paramsCount);
+  }
+  logSend({ phone, payload, context });
+  const resp = await sendWhatsAppMessage({
+    accessToken: token,
+    phoneNumberId: resolved.phoneId,
+    payload,
+  });
+  logSendResult({ phone, payloadType: payload.type, wamid: extractWamid(resp), context });
+  await recordOutboundMessage({ tenant: resolved, phone, payload, resp });
+  return resp;
+}
+// ============== WhatsApp: Texto (ou Template se forceTemplate=true) ==============
+export async function notifyWhatsapp(message, to, options = {}) {
+  const context = options?.context || (options?.estabelecimentoId  { estabelecimentoId: options.estabelecimentoId } : undefined);
+  return sendWhatsAppSmart({ to, message, context });
+}
+
+export async function sendWhatsAppSmart({
+  to,
+  message,
+  text,
+  template,
+  templateName,
+  templateParams,
+  templateNameFallback,
+  templateLangFallback,
+  allowText = true,
+  forceTemplate,
+  context,
+  estabelecimentoId,
+  returnMeta = false,
+} = {}) {
   const messageText = message != null ? String(message) : (text != null ? String(text) : '');
-  const templateDisabled = template === null || template === false;
-  const shouldForceTemplate = forceTemplate === true || cfg.forceTemplate;
-  const phone = normalizePhoneDigits(to);
-  if (!phone) {
-    if (cfg.debug) console.warn('[whatsapp] invalid phone -> %s', to);
-    if (!returnMeta) return { invalid: true };
-    return {
-      result: { invalid: true },
-      meta: {
-        decision: null,
-        window_open: false,
-        force_template: shouldForceTemplate,
-        wamid: null,
-      },
-    };
-  }
-  const ctx = estabelecimentoId ? { ...(context || {}), estabelecimentoId } : (context || {});
-  const tenant = await resolveTenantConfig(ctx);
-  const lastInbound = await getWhatsAppLastInboundAt(phone);
-  const windowOpen = isWhatsAppWindowOpen(lastInbound, new Date());
-
-  const fallbackName = templateNameFallback || cfg.templateName;
-  const fallbackLang = templateLangFallback || cfg.templateLang;
-  const templatePayload = template && template.name
-    ? template
-    : (templateDisabled ? null : {
-        name: fallbackName,
-        lang: fallbackLang,
-        bodyParams: cfg.templateHasBodyParam && messageText ? [messageText] : [],
-      });
-  const overrideName = templateName || 'confirmacao_agendamento_v2';
-  const overrideParams = Array.isArray(templateParams) ? templateParams : null;
-  const hasOverride = Boolean(templateName || overrideParams);
-  const overrideMissing = hasOverride
-    && isConfirmacaoAgendamentoV2(overrideName)
-    && !(Array.isArray(overrideParams)
-      && overrideParams.length === 3
-      && overrideParams.every((value) => String(value || '').trim()));
-  const canUseOverride = hasOverride && !overrideMissing;
-
-  let decision = null;
-  const finalize = (result) => {
-    if (!returnMeta) return result;
-    return {
-      result,
-      meta: {
-        decision,
-        window_open: windowOpen,
-        force_template: shouldForceTemplate,
-        wamid: extractWamid(result),
-      },
-    };
-  };
-  const overrideComponents = canUseOverride ? buildTemplateComponents(overrideParams) : null;
-  const sendTemplateSafely = async (payload) => {
-    try {
-      return await sendTemplate(payload);
-    } catch (err) {
-      const code = err?.code || err?.body?.error?.code;
-      if (code === 'wa_template_params_missing') {
-        return { ok: false, error: 'template_params_missing' };
-      }
-      throw err;
-    }
-  };
-  const sendTemplateWithOverrides = async () => {
-    if (overrideMissing) {
-      const base = {
-        template: overrideName,
-        expected: 3,
-        provided: Array.isArray(overrideParams) ? overrideParams.length : 0,
-        to: maskPhone(phone),
-      };
-      if (ctx) base.context = ctx;
-      console.warn('[wa/template] missing params, skip send', base);
-      return { ok: false, error: 'template_params_missing' };
-    }
-    if (canUseOverride) {
-      return sendTemplateSafely({
-        to: phone,
-        name: overrideName,
-        lang: 'pt_BR',
-        components: overrideComponents,
-        context: ctx,
-        tenant,
-      });
-    }
-    if (!templatePayload) {
-      const base = { to: maskPhone(phone) };
-      if (ctx) base.context = ctx;
-      console.warn('[wa/template] template disabled, skip send', base);
-      return { ok: false, error: 'template_missing' };
-    }
-    return sendTemplateSafely({
-      to: phone,
-      name: templatePayload.name,
-      lang: templatePayload.lang,
-      bodyParams: templatePayload.bodyParams || [],
-      headerImageUrl: templatePayload.headerImageUrl,
-      headerDocumentUrl: templatePayload.headerDocumentUrl,
-      headerVideoUrl: templatePayload.headerVideoUrl,
-      headerText: templatePayload.headerText,
-      context: ctx,
-      tenant,
-    });
-  };
-
-  if (shouldForceTemplate || !windowOpen) {
-    if (cfg.debug) {
-      console.log('[wa/cloud] smart-send template only (window closed or forced)');
-    }
-    decision = 'template';
-    const result = await sendTemplateWithOverrides();
-    return finalize(result);
-  }
-
-  if (allowText && messageText) {
-    try {
-      decision = 'text';
-      const result = await sendText({ to: phone, message: messageText, context: ctx, tenant });
-      return finalize(result);
-    } catch (err) {
-      if (is24hWindowError(err)) {
-        if (cfg.debug) console.log('[wa/cloud] text failed, fallback to template');
-        decision = 'template';
-        const result = await sendTemplateWithOverrides();
-        return finalize(result);
-      }
-      throw err;
-    }
-  }
-
-  if (template && template.name) {
-    decision = 'template';
-    const result = await sendTemplateWithOverrides();
-    return finalize(result);
-  }
-
-  if (message != null || text != null) {
-    decision = 'text';
-    const result = await sendText({ to: phone, message: messageText, context: ctx, tenant });
-    return finalize(result);
-  }
-
-  decision = 'text';
-  return finalize({ ok: false, error: 'missing_message' });
-}
-
-// ============== WhatsApp: Agendamento simples em memória ==============
-const timers = new Set();
-
-export async function scheduleWhatsApp({
-  to,
-  scheduledAt,
-  message,
-  metadata,
-  useTemplate,
-  bodyParams,
-  templateName,
-  templateLang,
-  estabelecimentoId,
-} = {}) {
-  const when = new Date(scheduledAt);
-  if (Number.isNaN(+when)) throw new Error('scheduledAt inválido');
-
-  const ms = +when - Date.now();
-  const phone = normalizePhoneDigits(to);
-
-  if (!phone) {
-    if (cfg.debug) console.warn('[whatsapp] invalid phone (schedule) -> %s', to);
-    return { invalid: true };
-  }
-  if (!isAllowed(phone)) {
-    if (cfg.debug) console.warn('[whatsapp] bloqueado por ALLOWED_LIST -> %s (schedule)', phone);
-    return { blocked: true };
-  }
-
-  const sendFn = async () => {
-    try {
-      if (cfg.forceTemplate || useTemplate) {
-        const params = Array.isArray(bodyParams) && bodyParams.length > 0
-          ? bodyParams
-          : (cfg.templateHasBodyParam ? [message] : []);
-        await sendTemplate({
-          to: phone,
-          name: templateName || cfg.templateName,
-          lang: templateLang || cfg.templateLang,
-          bodyParams: params,
-          estabelecimentoId,
-        });
-      } else {
-        const params = Array.isArray(bodyParams) && bodyParams.length > 0
-          ? bodyParams
-          : (cfg.templateHasBodyParam ? [message] : []);
-        await sendWhatsAppSmart({
-          to: phone,
-          message,
-          template: {
-            name: templateName || cfg.templateName,
-            lang: templateLang || cfg.templateLang,
-            bodyParams: params,
-          },
-          estabelecimentoId,
-        });
-      }
-    } catch (err) {
-      console.error('[scheduleWhatsApp/send]', err.status, err.body || err.message);
-    }
-  };
-
-  if (ms <= 0) {
-    await sendFn();
-    return { sent: true, immediate: true };
-  }
-
-  const t = setTimeout(async () => {
-    timers.delete(t);
-    await sendFn();
-  }, ms);
-  timers.add(t);
-
-  if (cfg.debug) {
-    console.log('[scheduleWhatsApp] to=%s at=%s (%d ms) meta=%s',
-      phone, when.toISOString(), ms, metadata ? JSON.stringify(metadata) : '-');
-  }
-  return { scheduled: true, at: when.toISOString() };
-}
-
-// ============== Email (Nodemailer) ==============
-const smtp = {
-  host: process.env.SMTP_HOST,
-  port: Number(process.env.SMTP_PORT || 587),
-  secure: /^true$/i.test(process.env.SMTP_SECURE || ''),
-  auth: (process.env.SMTP_USER && process.env.SMTP_PASS)
-    ? { user: process.env.SMTP_USER, pass: process.env.SMTP_PASS }
-    : undefined,
-};
-
-let transporter;
-if (smtp.host && smtp.auth?.user) {
-  transporter = nodemailer.createTransport(smtp);
-} else {
-  // Fallback: não envia de verdade, apenas log
-  transporter = nodemailer.createTransport({
-    streamTransport: true,
-    newline: 'unix',
-    buffer: true,
-  });
-  if (cfg.debug) console.warn('[email] SMTP não configurado  usando streamTransport (apenas log).');
-}
-
-
-export async function notifyEmail(to, subject, html) {
-  if (!to) return { ok: false, error: 'missing_to' };
-  try {
-    await transporter.sendMail({
-      from: process.env.EMAIL_FROM || `"Agendamentos Online" <${process.env.SMTP_USER || 'no-reply@localhost'}>`,
-      to,
-      subject,
-      html,
-    });
-    if (cfg.debug) console.log('? Email enviado para %s (%s)', to, subject);
-    return { ok: true };
-  } catch (err) {
-    console.error('[email] erro', err);
-    return { ok: false, error: err?.message || 'email_error' };
-  }
-}
+  const templateDisabled = template === null || template === false;
+  const shouldForceTemplate = forceTemplate === true || cfg.forceTemplate;
+  const phone = normalizePhoneDigits(to);
+  if (!phone) {
+    if (cfg.debug) console.warn('[whatsapp] invalid phone -> %s', to);
+    if (!returnMeta) return { invalid: true };
+    return {
+      result: { invalid: true },
+      meta: {
+        decision: null,
+        window_open: false,
+        force_template: shouldForceTemplate,
+        wamid: null,
+      },
+    };
+  }
+  const ctx = estabelecimentoId  { ...(context || {}), estabelecimentoId } : (context || {});
+  const tenant = await resolveTenantConfig(ctx);
+  const lastInbound = await getWhatsAppLastInboundAt(phone);
+  const windowOpen = isWhatsAppWindowOpen(lastInbound, new Date());
+
+  const fallbackName = templateNameFallback || cfg.templateName;
+  const fallbackLang = templateLangFallback || cfg.templateLang;
+  const templatePayload = template && template.name
+     template
+    : (templateDisabled  null : {
+        name: fallbackName,
+        lang: fallbackLang,
+        bodyParams: (cfg.templateHasBodyParam && messageText) ? [messageText] : [],
+      });
+  const overrideName = templateName || 'confirmacao_agendamento_v2';
+  const overrideParams = Array.isArray(templateParams)  templateParams : null;
+  const hasOverride = Boolean(templateName || overrideParams);
+  const overrideMissing = hasOverride
+    && isConfirmacaoAgendamentoV2(overrideName)
+    && !(Array.isArray(overrideParams)
+      && overrideParams.length === 3
+      && overrideParams.every((value) => String(value || '').trim()));
+  const canUseOverride = hasOverride && !overrideMissing;
+
+  let decision = null;
+  const finalize = (result) => {
+    if (!returnMeta) return result;
+    return {
+      result,
+      meta: {
+        decision,
+        window_open: windowOpen,
+        force_template: shouldForceTemplate,
+        wamid: extractWamid(result),
+      },
+    };
+  };
+  const overrideComponents = canUseOverride  buildTemplateComponents(overrideParams) : null;
+  const sendTemplateSafely = async (payload) => {
+    try {
+      return await sendTemplate(payload);
+    } catch (err) {
+      const code = err?.code || err?.body?.error?.code;
+      if (code === 'wa_template_params_missing') {
+        return { ok: false, error: 'template_params_missing' };
+      }
+      throw err;
+    }
+  };
+  const sendTemplateWithOverrides = async () => {
+    if (overrideMissing) {
+      const base = {
+        template: overrideName,
+        expected: 3,
+        provided: Array.isArray(overrideParams)  overrideParams.length : 0,
+        to: maskPhone(phone),
+      };
+      if (ctx) base.context = ctx;
+      console.warn('[wa/template] missing params, skip send', base);
+      return { ok: false, error: 'template_params_missing' };
+    }
+    if (canUseOverride) {
+      return sendTemplateSafely({
+        to: phone,
+        name: overrideName,
+        lang: 'pt_BR',
+        components: overrideComponents,
+        context: ctx,
+        tenant,
+      });
+    }
+    if (!templatePayload) {
+      const base = { to: maskPhone(phone) };
+      if (ctx) base.context = ctx;
+      console.warn('[wa/template] template disabled, skip send', base);
+      return { ok: false, error: 'template_missing' };
+    }
+    return sendTemplateSafely({
+      to: phone,
+      name: templatePayload.name,
+      lang: templatePayload.lang,
+      bodyParams: templatePayload.bodyParams || [],
+      headerImageUrl: templatePayload.headerImageUrl,
+      headerDocumentUrl: templatePayload.headerDocumentUrl,
+      headerVideoUrl: templatePayload.headerVideoUrl,
+      headerText: templatePayload.headerText,
+      context: ctx,
+      tenant,
+    });
+  };
+
+  if (shouldForceTemplate || !windowOpen) {
+    if (cfg.debug) {
+      console.log('[wa/cloud] smart-send template only (window closed or forced)');
+    }
+    decision = 'template';
+    const result = await sendTemplateWithOverrides();
+    return finalize(result);
+  }
+
+  if (allowText && messageText) {
+    try {
+      decision = 'text';
+      const result = await sendText({ to: phone, message: messageText, context: ctx, tenant });
+      return finalize(result);
+    } catch (err) {
+      if (is24hWindowError(err)) {
+        if (cfg.debug) console.log('[wa/cloud] text failed, fallback to template');
+        decision = 'template';
+        const result = await sendTemplateWithOverrides();
+        return finalize(result);
+      }
+      throw err;
+    }
+  }
+
+  if (template && template.name) {
+    decision = 'template';
+    const result = await sendTemplateWithOverrides();
+    return finalize(result);
+  }
+
+  if (message != null || text != null) {
+    decision = 'text';
+    const result = await sendText({ to: phone, message: messageText, context: ctx, tenant });
+    return finalize(result);
+  }
+
+  decision = 'text';
+  return finalize({ ok: false, error: 'missing_message' });
+}
+
+// ============== WhatsApp: Agendamento simples em memória ==============
+const timers = new Set();

+

+export async function scheduleWhatsApp({
+  to,
+  scheduledAt,
+  message,
+  metadata,
+  useTemplate,
+  bodyParams,
+  templateName,
+  templateLang,
+  estabelecimentoId,
+} = {}) {
+  const when = new Date(scheduledAt);

+  if (Number.isNaN(+when)) throw new Error('scheduledAt inválido');

+

+  const ms = +when - Date.now();

+  const phone = normalizePhoneDigits(to);

+

+  if (!phone) {

+    if (cfg.debug) console.warn('[whatsapp] invalid phone (schedule) -> %s', to);

+    return { invalid: true };

+  }

+  if (!isAllowed(phone)) {

+    if (cfg.debug) console.warn('[whatsapp] bloqueado por ALLOWED_LIST -> %s (schedule)', phone);

+    return { blocked: true };

+  }

+

+  const sendFn = async () => {
+    try {
+      if (cfg.forceTemplate || useTemplate) {
+        const params = Array.isArray(bodyParams) && bodyParams.length > 0
+           bodyParams
+          : (cfg.templateHasBodyParam  [message] : []);
+        await sendTemplate({
+          to: phone,
+          name: templateName || cfg.templateName,
+          lang: templateLang || cfg.templateLang,
+          bodyParams: params,
+          estabelecimentoId,
+        });
+      } else {
+        const params = Array.isArray(bodyParams) && bodyParams.length > 0
+           bodyParams
+          : (cfg.templateHasBodyParam  [message] : []);
+        await sendWhatsAppSmart({
+          to: phone,
+          message,
+          template: {
+            name: templateName || cfg.templateName,
+            lang: templateLang || cfg.templateLang,
+            bodyParams: params,
+          },
+          estabelecimentoId,
+        });
+      }
+    } catch (err) {
+      console.error('[scheduleWhatsApp/send]', err.status, err.body || err.message);
+    }
+  };
+

+  if (ms <= 0) {

+    await sendFn();

+    return { sent: true, immediate: true };

+  }

+

+  const t = setTimeout(async () => {

+    timers.delete(t);

+    await sendFn();

+  }, ms);

+  timers.add(t);

+

+  if (cfg.debug) {

+    console.log('[scheduleWhatsApp] to=%s at=%s (%d ms) meta=%s',

+      phone, when.toISOString(), ms, metadata  JSON.stringify(metadata) : '-');

+  }

+  return { scheduled: true, at: when.toISOString() };

+}

+

+// ============== Email (Nodemailer) ==============

+const smtp = {

+  host: process.env.SMTP_HOST,

+  port: Number(process.env.SMTP_PORT || 587),

+  secure: /^true$/i.test(process.env.SMTP_SECURE || ''),

+  auth: (process.env.SMTP_USER && process.env.SMTP_PASS)

+     { user: process.env.SMTP_USER, pass: process.env.SMTP_PASS }

+    : undefined,

+};

+

+let transporter;

+if (smtp.host && smtp.auth?.user) {

+  transporter = nodemailer.createTransport(smtp);

+} else {

+  // Fallback: não envia de verdade, apenas log

+  transporter = nodemailer.createTransport({

+    streamTransport: true,

+    newline: 'unix',

+    buffer: true,

+  });

+  if (cfg.debug) console.warn('[email] SMTP não configurado  usando streamTransport (apenas log).');

+}

+

+

+export async function notifyEmail(to, subject, html) {

+  if (!to) return { ok: false, error: 'missing_to' };

+  try {

+    await transporter.sendMail({

+      from: process.env.EMAIL_FROM || `"Agendamentos Online" <${process.env.SMTP_USER || 'no-reply@localhost'}>`,

+      to,

+      subject,

+      html,

+    });

+    if (cfg.debug) console.log('? Email enviado para %s (%s)', to, subject);

+    return { ok: true };

+  } catch (err) {

+    console.error('[email] erro', err);

+    return { ok: false, error: err?.message || 'email_error' };

+  }

+}

diff --git a/backend/src/lib/whatsapp.js b/backend/src/lib/whatsapp.js
index 52ad741..53f3c09 100644
--- a/backend/src/lib/whatsapp.js
+++ b/backend/src/lib/whatsapp.js
@@ -1,153 +1,153 @@
-// backend/src/lib/whatsapp.js
-import dotenv from 'dotenv'; dotenv.config();
-
-// Node 18+ já tem fetch global. Se quiser compatibilidade, descomente:
-// import fetch from 'node-fetch';
-
-const VERSION = process.env.WA_API_VERSION || 'v23.0';
-const PHONE_ID = process.env.WA_PHONE_NUMBER_ID;     // << use WA_* como no seu .env
-const TOKEN    = process.env.WA_TOKEN;
-
-if (!PHONE_ID) throw new Error('ENV WA_PHONE_NUMBER_ID ausente');
-if (!TOKEN)   throw new Error('ENV WA_TOKEN ausente');
-
-const API_URL = `https://graph.facebook.com/${VERSION}/${PHONE_ID}/messages`;
-const toDigits = (s) => String(s || '').replace(/\D/g, '');
-
-function maskPhone(phone) {
-  const digits = toDigits(phone);
-  if (!digits) return '';
-  if (digits.length <= 4) return '*'.repeat(digits.length);
-  return `${'*'.repeat(digits.length - 4)}${digits.slice(-4)}`;
-}
-
-function summarizePayload(payload) {
-  if (!payload || typeof payload !== 'object') return null;
-  const type = payload.type || 'unknown';
-  if (type === 'template') {
-    const tpl = payload.template || {};
-    const components = Array.isArray(tpl.components) ? tpl.components : [];
-    const templateSummary = {
-      name: tpl.name,
-      lang: tpl.language?.code,
-    };
-    if (components.length) {
-      templateSummary.components = components.map((comp) => ({
-        type: comp?.type,
-        params: Array.isArray(comp?.parameters) ? comp.parameters.length : 0,
-      }));
-    }
-    return {
-      type,
-      template: templateSummary,
-    };
-  }
-  if (type === 'text') {
-    const body = payload.text?.body || '';
-    return {
-      type,
-      text: { length: String(body).length },
-    };
-  }
-  return { type };
-}
-
-function extractWamid(resp) {
-  try {
-    const id = resp?.messages?.[0]?.id;
+// backend/src/lib/whatsapp.js

+import dotenv from 'dotenv'; dotenv.config();

+

+// Node 18+ já tem fetch global. Se quiser compatibilidade, descomente:

+// import fetch from 'node-fetch';

+

+const VERSION = process.env.WA_API_VERSION || 'v23.0';

+const PHONE_ID = process.env.WA_PHONE_NUMBER_ID;     // << use WA_* como no seu .env

+const TOKEN    = process.env.WA_TOKEN;

+

+if (!PHONE_ID) throw new Error('ENV WA_PHONE_NUMBER_ID ausente');

+if (!TOKEN)   throw new Error('ENV WA_TOKEN ausente');

+

+const API_URL = `https://graph.facebook.com/${VERSION}/${PHONE_ID}/messages`;

+const toDigits = (s) => String(s || '').replace(/\D/g, '');

+

+function maskPhone(phone) {

+  const digits = toDigits(phone);

+  if (!digits) return '';

+  if (digits.length <= 4) return '*'.repeat(digits.length);

+  return `${'*'.repeat(digits.length - 4)}${digits.slice(-4)}`;

+}

+

+function summarizePayload(payload) {

+  if (!payload || typeof payload !== 'object') return null;

+  const type = payload.type || 'unknown';

+  if (type === 'template') {

+    const tpl = payload.template || {};

+    const components = Array.isArray(tpl.components)  tpl.components : [];

+    const templateSummary = {

+      name: tpl.name,

+      lang: tpl.language?.code,

+    };

+    if (components.length) {

+      templateSummary.components = components.map((comp) => ({

+        type: comp?.type,

+        params: Array.isArray(comp?.parameters)  comp.parameters.length : 0,

+      }));

+    }

+    return {

+      type,

+      template: templateSummary,

+    };

+  }

+  if (type === 'text') {

+    const body = payload.text?.body || '';

+    return {

+      type,

+      text: { length: String(body).length },

+    };

+  }

+  return { type };

+}

+

+function extractWamid(resp) {

+  try {

+    const id = resp?.messages?.[0]?.id;

     return id ? String(id) : null;
-  } catch {
-    return null;
-  }
-}
-
-function isAllowed(to) {
-  // Em ambiente de teste, o número de remetente é o +1 555 140 5688 (phone_id do print).
-  // Garanta que só enviará para números da allowed list.
-  const list = String(process.env.WHATSAPP_ALLOWED_LIST || '')
-    .split(',')
-    .map(x => toDigits(x))
-    .filter(Boolean);
-  if (!list.length) return true; // se não configurar, não bloqueia
-  return list.includes(to);
-}
-
-async function postGraph(payload) {
-  console.log('[wa/send]', JSON.stringify({
-    type: payload?.type || 'unknown',
-    to: maskPhone(payload?.to),
-    payload: summarizePayload(payload),
-  }));
-  const res = await fetch(API_URL, {
-    method: 'POST',
-    headers: {
-      Authorization: `Bearer ${TOKEN}`,
-      'Content-Type': 'application/json'
-    },
-    body: JSON.stringify(payload)
-  });
-  const data = await res.json().catch(() => ({}));
-  if (!res.ok) {
-    const error = data?.error;
-    const logData = (error && typeof error === 'object')
-      ? {
-          message: error.message,
-          code: error.code,
-          error_data: error.error_data,
-          fbtrace_id: error.fbtrace_id,
-        }
-      : data;
-    console.error('[wa/graph/error]', { status: res.status, data: logData });
-    const msg = error?.message || `Graph HTTP ${res.status}`;
-    const err = new Error(msg);
-    err.status = res.status;
-    err.body = data;
-    err.graph = error;
-    throw err;
-  }
-  console.log('[wa/send/ok]', JSON.stringify({
-    type: payload?.type || 'unknown',
-    to: maskPhone(payload?.to),
-    wamid: extractWamid(data),
-  }));
-  return data;
-}
-
-export async function waSendText({ to, body }) {
-  const dest = toDigits(to || process.env.WHATSAPP_TO);
-  if (!dest) throw new Error('Destino (to) ausente');
-  if (!isAllowed(dest)) {
-    const e = new Error('Número não está na allowed list em modo de teste');
-    e.status = 400;
-    throw e;
-  }
-  return postGraph({
-    messaging_product: 'whatsapp',
-    to: dest,
-    type: 'text',
-    text: { body: String(body || 'Olá!') }
-  });
-}
-
-export async function waSendTemplate({ to, name, lang = 'en_US', components }) {
-  const dest = toDigits(to || process.env.WHATSAPP_TO);
-  if (!dest) throw new Error('Destino (to) ausente');
-  if (!isAllowed(dest)) {
-    const e = new Error('Número não está na allowed list em modo de teste');
-    e.status = 400;
-    throw e;
-  }
-  const template = {
-    name: name || process.env.WA_TEMPLATE_NAME || 'hello_world',
-    language: { code: lang || process.env.WA_TEMPLATE_LANG || 'en_US' },
-  };
-  if (Array.isArray(components) && components.length > 0) {
-    template.components = components;
-  }
-  return postGraph({
-    messaging_product: 'whatsapp',
-    to: dest,
-    type: 'template',
-    template,
-  });
-}
+  } catch {

+    return null;

+  }

+}

+

+function isAllowed(to) {

+  // Em ambiente de teste, o número de remetente é o +1 555 140 5688 (phone_id do print).

+  // Garanta que só enviará para números da allowed list.

+  const list = String(process.env.WHATSAPP_ALLOWED_LIST || '')

+    .split(',')

+    .map(x => toDigits(x))

+    .filter(Boolean);

+  if (!list.length) return true; // se não configurar, não bloqueia

+  return list.includes(to);

+}

+

+async function postGraph(payload) {

+  console.log('[wa/send]', JSON.stringify({

+    type: payload?.type || 'unknown',

+    to: maskPhone(payload?.to),

+    payload: summarizePayload(payload),

+  }));

+  const res = await fetch(API_URL, {

+    method: 'POST',

+    headers: {

+      Authorization: `Bearer ${TOKEN}`,

+      'Content-Type': 'application/json'

+    },

+    body: JSON.stringify(payload)

+  });

+  const data = await res.json().catch(() => ({}));

+  if (!res.ok) {

+    const error = data?.error;

+    const logData = (error && typeof error === 'object')

+       {

+          message: error.message,

+          code: error.code,

+          error_data: error.error_data,

+          fbtrace_id: error.fbtrace_id,

+        }

+      : data;

+    console.error('[wa/graph/error]', { status: res.status, data: logData });

+    const msg = error?.message || `Graph HTTP ${res.status}`;

+    const err = new Error(msg);

+    err.status = res.status;

+    err.body = data;

+    err.graph = error;

+    throw err;

+  }

+  console.log('[wa/send/ok]', JSON.stringify({

+    type: payload?.type || 'unknown',

+    to: maskPhone(payload?.to),

+    wamid: extractWamid(data),

+  }));

+  return data;

+}

+

+export async function waSendText({ to, body }) {

+  const dest = toDigits(to || process.env.WHATSAPP_TO);

+  if (!dest) throw new Error('Destino (to) ausente');

+  if (!isAllowed(dest)) {

+    const e = new Error('Número não está na allowed list em modo de teste');

+    e.status = 400;

+    throw e;

+  }

+  return postGraph({

+    messaging_product: 'whatsapp',

+    to: dest,

+    type: 'text',

+    text: { body: String(body || 'Olá!') }

+  });

+}

+

+export async function waSendTemplate({ to, name, lang = 'en_US', components }) {

+  const dest = toDigits(to || process.env.WHATSAPP_TO);

+  if (!dest) throw new Error('Destino (to) ausente');

+  if (!isAllowed(dest)) {

+    const e = new Error('Número não está na allowed list em modo de teste');

+    e.status = 400;

+    throw e;

+  }

+  const template = {
+    name: name || process.env.WA_TEMPLATE_NAME || 'hello_world',
+    language: { code: lang || process.env.WA_TEMPLATE_LANG || 'en_US' },
+  };
+  if (Array.isArray(components) && components.length > 0) {
+    template.components = components;
+  }
+  return postGraph({
+    messaging_product: 'whatsapp',
+    to: dest,
+    type: 'template',
+    template,
+  });
+}
diff --git a/backend/src/lib/whatsapp_outbox.js b/backend/src/lib/whatsapp_outbox.js
index 204fe89..33be950 100644
--- a/backend/src/lib/whatsapp_outbox.js
+++ b/backend/src/lib/whatsapp_outbox.js
@@ -74,7 +74,7 @@ async function loadConfirmacaoAgendamentoV2Context({ agendamentoId, estabelecime
 
 async function ensureConfirmacaoAgendamentoV2BodyParams(template, { agendamentoId, estabelecimentoId } = {}) {
   if (!template || !isConfirmacaoAgendamentoV2(template.name)) return template;
-  const rawParams = Array.isArray(template.bodyParams) ? template.bodyParams : [];
+  const rawParams = Array.isArray(template.bodyParams)  template.bodyParams : [];
   const hasThree = rawParams.length === 3 && rawParams.every((p) => String(p || '').trim());
   if (hasThree) {
     template.bodyParams = buildConfirmacaoAgendamentoV2Components({
@@ -86,9 +86,9 @@ async function ensureConfirmacaoAgendamentoV2BodyParams(template, { agendamentoI
   }
   const ctx = await loadConfirmacaoAgendamentoV2Context({ agendamentoId, estabelecimentoId });
   template.bodyParams = buildConfirmacaoAgendamentoV2Components({
-    serviceLabel: ctx?.serviceLabel ?? rawParams[0],
-    dataHoraLabel: ctx?.dataHoraLabel ?? rawParams[1],
-    estabelecimentoNome: ctx?.estabelecimentoNome ?? rawParams[2],
+    serviceLabel: ctx?.serviceLabel  rawParams[0],
+    dataHoraLabel: ctx?.dataHoraLabel  rawParams[1],
+    estabelecimentoNome: ctx?.estabelecimentoNome  rawParams[2],
   });
   return template;
 }
@@ -96,7 +96,7 @@ async function ensureConfirmacaoAgendamentoV2BodyParams(template, { agendamentoI
 async function getAppointmentWaCount(agendamentoId) {
   const id = toInt(agendamentoId, 0);
   if (!id) return null;
-  const [[row]] = await pool.query('SELECT wa_messages_sent FROM agendamentos WHERE id=? LIMIT 1', [id]);
+  const [[row]] = await pool.query('SELECT wa_messages_sent FROM agendamentos WHERE id= LIMIT 1', [id]);
   if (!row) return null;
   return toInt(row.wa_messages_sent, 0);
 }
@@ -104,7 +104,7 @@ async function getAppointmentWaCount(agendamentoId) {
 async function incrementAppointmentWaCount(agendamentoId) {
   const id = toInt(agendamentoId, 0);
   if (!id) return { ok: false };
-  await pool.query('UPDATE agendamentos SET wa_messages_sent=wa_messages_sent+1 WHERE id=? LIMIT 1', [id]);
+  await pool.query('UPDATE agendamentos SET wa_messages_sent=wa_messages_sent+1 WHERE id= LIMIT 1', [id]);
   return { ok: true };
 }
 
@@ -127,7 +127,7 @@ export async function sendAppointmentWhatsApp({
   metadata,
 }) {
   const estabId = toInt(estabelecimentoId, 0);
-  const agId = agendamentoId != null ? toInt(agendamentoId, 0) : null;
+  const agId = agendamentoId != null  toInt(agendamentoId, 0) : null;
   if (!estabId || !to) {
     return { ok: false, error: 'invalid_payload' };
   }
@@ -167,7 +167,7 @@ export async function sendAppointmentWhatsApp({
 
   let resp;
   try {
-    let templateToSend = template && template.name ? {
+    let templateToSend = template && template.name  {
       name: template.name,
       lang: template.lang,
       bodyParams: template.bodyParams || [],
@@ -189,7 +189,7 @@ export async function sendAppointmentWhatsApp({
       context: { kind, agendamentoId: agId, estabelecimentoId: estabId },
     });
   } catch (err) {
-    const errorCode = err?.code === 'wa_not_connected' ? 'wa_not_connected' : 'send_failed';
+    const errorCode = err?.code === 'wa_not_connected'  'wa_not_connected' : 'send_failed';
     return {
       ok: false,
       sent: false,
@@ -200,6 +200,14 @@ export async function sendAppointmentWhatsApp({
     };
   }
 
+  if (resp?.ok === false) {
+    return {
+      ok: false,
+      sent: false,
+      error: resp.reason || resp.error || 'send_failed',
+      detail: resp.detail || resp.reason || null,
+    };
+  }
   if (resp?.blocked) return { ok: true, sent: false, blocked: true, reason: 'blocked_allowed_list' };
   if (resp?.invalid) return { ok: true, sent: false, blocked: true, reason: 'invalid_phone' };
 
diff --git a/backend/src/lib/whatsapp_wallet.js b/backend/src/lib/whatsapp_wallet.js
index 7f35494..33d59bd 100644
--- a/backend/src/lib/whatsapp_wallet.js
+++ b/backend/src/lib/whatsapp_wallet.js
@@ -84,7 +84,7 @@ const toInt = (value, fallback = 0) => {
 };
 
 function ensureDate(input) {
-  const d = input instanceof Date ? new Date(input) : new Date(input);
+  const d = input instanceof Date  new Date(input) : new Date(input);
   if (Number.isNaN(d.getTime())) return new Date();
   return d;
 }
@@ -121,11 +121,11 @@ function resolveIncludedLimit(planContext) {
 
 function normalizeTopupPackage(pack) {
   if (!pack) return null;
-  const messages = toInt(pack.messages ?? pack.wa_messages ?? pack.waMessages, 0);
-  const priceCents = toInt(pack.priceCents ?? pack.price_cents ?? pack.price ?? 0, 0);
+  const messages = toInt(pack.messages  pack.wa_messages  pack.waMessages, 0);
+  const priceCents = toInt(pack.priceCents  pack.price_cents  pack.price  0, 0);
   if (!messages || priceCents < 0) return null;
   return {
-    id: pack.id != null ? toInt(pack.id, null) : null,
+    id: pack.id != null  toInt(pack.id, null) : null,
     code: pack.code || null,
     name: pack.name || null,
     messages,
@@ -136,7 +136,7 @@ function normalizeTopupPackage(pack) {
 function findTopup(messages, availablePacks = null) {
   const m = toInt(messages, 0);
   const candidates = Array.isArray(availablePacks) && availablePacks.length
-    ? availablePacks
+     availablePacks
     : WHATSAPP_TOPUP_PACKAGES;
   return candidates.map(normalizeTopupPackage).find((p) => p?.messages === m) || null;
 }
@@ -158,7 +158,7 @@ async function ensureWalletExists(conn, estabelecimentoId, cycle, includedLimit)
 
 async function ensureWalletCycleAndPlan(conn, estabelecimentoId, cycle, includedLimit, { lock = true } = {}) {
   // The lock flag lets snapshot paths skip FOR UPDATE while credit/debit still serialize wallet updates first.
-  const lockClause = lock ? '\n     FOR UPDATE' : '';
+  const lockClause = lock  '\n     FOR UPDATE' : '';
   const [[row]] = await conn.query(
     `SELECT estabelecimento_id, cycle_start, cycle_end, included_limit, included_balance, extra_balance
      FROM whatsapp_wallets
@@ -168,8 +168,8 @@ async function ensureWalletCycleAndPlan(conn, estabelecimentoId, cycle, included
   );
   if (!row) return null;
 
-  const currentStart = row.cycle_start ? new Date(row.cycle_start) : null;
-  const currentEnd = row.cycle_end ? new Date(row.cycle_end) : null;
+  const currentStart = row.cycle_start  new Date(row.cycle_start) : null;
+  const currentEnd = row.cycle_end  new Date(row.cycle_end) : null;
   const needsCycleReset =
     !currentStart ||
     !currentEnd ||
@@ -266,8 +266,8 @@ export async function getWhatsAppWalletSnapshot(estabelecimentoId, { now = new D
   return {
     estabelecimento_id: estId,
     month_label: cycle.label,
-    cycle_start: wallet.cycle_start ? new Date(wallet.cycle_start).toISOString() : null,
-    cycle_end: wallet.cycle_end ? new Date(wallet.cycle_end).toISOString() : null,
+    cycle_start: wallet.cycle_start  new Date(wallet.cycle_start).toISOString() : null,
+    cycle_end: wallet.cycle_end  new Date(wallet.cycle_end).toISOString() : null,
     included_limit: includedLimitOut,
     included_balance: includedBalance,
     extra_balance: extraBalance,
@@ -289,7 +289,7 @@ export async function recordWhatsAppBlocked({
     `INSERT INTO whatsapp_wallet_transactions
       (estabelecimento_id, kind, delta, included_delta, extra_delta, agendamento_id, reason, metadata)
      VALUES (?, 'blocked', 0, 0, 0, ?, ?, ?)`,
-    [estId, agendamentoId != null ? toInt(agendamentoId, 0) || null : null, String(reason || ''), safeJson(metadata)]
+    [estId, agendamentoId != null  toInt(agendamentoId, 0) || null : null, String(reason || ''), safeJson(metadata)]
   );
   return { ok: true };
 }
@@ -329,14 +329,14 @@ export async function creditWhatsAppTopup({
           estId,
           pkg.messages,
           pkg.messages,
-          subscriptionId != null ? toInt(subscriptionId, 0) || null : null,
+          subscriptionId != null  toInt(subscriptionId, 0) || null : null,
           String(paymentId),
           reason,
           safeJson({
             ...(metadata || {}),
           pack_code: pkg.code || metadata?.pack_code || null,
-          pack_id: pkg.id ?? metadata?.pack_id ?? null,
-          pack_name: (pkg.name || metadata?.pack_name) ?? null,
+          pack_id: pkg.id  metadata?.pack_id  null,
+          pack_name: (pkg.name || metadata?.pack_name)  null,
             messages: pkg.messages,
             price_cents: pkg.priceCents,
           }),
@@ -394,13 +394,13 @@ export async function debitWhatsAppMessage({
 
       const includedBalance = toInt(wallet.included_balance, 0);
       const extraBalance = toInt(wallet.extra_balance, 0);
-      const bucket = includedBalance > 0 ? 'included' : extraBalance > 0 ? 'extra' : null;
+      const bucket = includedBalance > 0  'included' : extraBalance > 0  'extra' : null;
       if (!bucket) {
         return { error: 'insufficient_balance' };
       }
 
-      const includedDelta = bucket === 'included' ? -1 : 0;
-      const extraDelta = bucket === 'extra' ? -1 : 0;
+      const includedDelta = bucket === 'included'  -1 : 0;
+      const extraDelta = bucket === 'extra'  -1 : 0;
 
       const [ins] = await conn.query(
         `INSERT IGNORE INTO whatsapp_wallet_transactions
@@ -410,7 +410,7 @@ export async function debitWhatsAppMessage({
           estId,
           includedDelta,
           extraDelta,
-          agendamentoId != null ? toInt(agendamentoId, 0) || null : null,
+          agendamentoId != null  toInt(agendamentoId, 0) || null : null,
           String(providerMessageId),
           safeJson(metadata),
         ]
@@ -461,7 +461,7 @@ export async function listWhatsAppTopups(estabelecimentoId, { limit = 5 } = {})
   const [rows] = await pool.query(
     `SELECT id, delta, included_delta, extra_delta, payment_id, metadata, created_at
      FROM whatsapp_wallet_transactions
-     WHERE estabelecimento_id=? AND kind='topup_credit'
+     WHERE estabelecimento_id= AND kind='topup_credit'
      ORDER BY id DESC
      LIMIT ?`,
     [estId, max]
@@ -478,7 +478,7 @@ export async function listWhatsAppTopups(estabelecimentoId, { limit = 5 } = {})
       extra_delta: toInt(row.extra_delta, 0),
       payment_id: row.payment_id ? String(row.payment_id) : null,
       metadata: parsed,
-      created_at: row.created_at ? new Date(row.created_at).toISOString() : null,
+      created_at: row.created_at  new Date(row.created_at).toISOString() : null,
     };
   });
 }
diff --git a/backend/src/routes/agendamentos.js b/backend/src/routes/agendamentos.js
index aae7313..f3a3acc 100644
--- a/backend/src/routes/agendamentos.js
+++ b/backend/src/routes/agendamentos.js
@@ -1,1639 +1,1826 @@
-// backend/src/routes/agendamentos.js
-import { Router } from 'express';
-import { pool } from '../lib/db.js';
-import { assertDentroExpediente, formatExpedienteMessage, getExpediente, getLocalRangeMinutes } from '../lib/expediente.js';
-import { getPlanContext, isDelinquentStatus, formatPlanLimitExceeded } from '../lib/plans.js';
-import { auth as authRequired, isCliente, isEstabelecimento } from '../middleware/auth.js';
-import { notifyEmail } from '../lib/notifications.js';
-import { sendAppointmentWhatsApp } from '../lib/whatsapp_outbox.js';
-import { buildConfirmacaoAgendamentoV2Components, isConfirmacaoAgendamentoV2 } from '../lib/whatsapp_templates.js';
-import bcrypt from 'bcryptjs';
-import { checkMonthlyAppointmentLimit, notifyAppointmentLimitReached } from '../lib/appointment_limits.js';
-import { estabNotificationsDisabled } from '../lib/estab_notifications.js';
-import { clientWhatsappDisabled, whatsappImmediateDisabled, whatsappConfirmationDisabled } from '../lib/client_notifications.js';
-
-const router = Router();
-
-const TZ = 'America/Sao_Paulo';
-const FRONTEND_BASE = String(process.env.FRONTEND_BASE_URL || process.env.APP_URL || 'http://localhost:3001').replace(/\/$/, '');
-const toDigits = (s) => String(s || '').replace(/\D/g, ''); // normaliza telefone para apenas digitos
-const normalizePhoneBR = (value) => {
-  let digits = toDigits(value);
-  if (!digits) return '';
-  digits = digits.replace(/^0+/, '');
-  if (digits.startsWith('55')) return digits;
-  if (digits.length >= 10 && digits.length <= 11) return `55${digits}`;
-  return digits;
-};
-const normalizeBirthdate = (value) => {
-  if (value === undefined || value === null) return null;
-  const raw = String(value).trim();
-  if (!raw) return null;
-  const match = raw.match(/^(\d{4})-(\d{2})-(\d{2})$/);
-  if (!match) return null;
-  const year = Number(match[1]);
-  const month = Number(match[2]);
-  const day = Number(match[3]);
-  const dt = new Date(year, month - 1, day);
-  if (
-    Number.isNaN(dt.getTime()) ||
-    dt.getFullYear() !== year ||
-    dt.getMonth() + 1 !== month ||
-    dt.getDate() !== day
-  ) {
-    return null;
-  }
-  return `${match[1]}-${match[2]}-${match[3]}`;
-};
-const boolPref = (value, fallback = true) => {
-  if (value === undefined || value === null) return fallback;
-  if (value === true || value === false) return Boolean(value);
-  const num = Number(value);
-  if (!Number.isNaN(num)) return num !== 0;
-  const norm = String(value).trim().toLowerCase();
-  if (['0', 'false', 'off', 'no', 'nao'].includes(norm)) return false;
-  if (['1', 'true', 'on', 'yes', 'sim'].includes(norm)) return true;
-  return fallback;
-};
-const CANCEL_MINUTES_CLIENT = (() => {
-  const raw = process.env.CANCEL_MINUTES_CLIENT;
-  if (raw === undefined || raw === null || String(raw).trim() === '') return 120;
-  const parsed = Number(raw);
-  return Number.isFinite(parsed) ? parsed : 120;
-})();
-const formatCancelLimitLabel = (minutes) => {
-  if (!Number.isFinite(minutes) || minutes <= 0) return '';
-  if (minutes % 60 === 0) {
-    const hours = minutes / 60;
-    return `${hours} hora${hours === 1 ? '' : 's'}`;
-  }
-  return `${minutes} minutos`;
-};
-const APPOINTMENT_BUFFER_MIN = (() => {
-  const raw = process.env.AGENDAMENTO_BUFFER_MIN ?? process.env.APPOINTMENT_BUFFER_MIN;
-  if (raw === undefined || raw === null || String(raw).trim() === '') return 0;
-  const parsed = Number(raw);
-  return Number.isFinite(parsed) && parsed > 0 ? Math.round(parsed) : 0;
-})();
-const normalizeServiceIds = (value) => {
-  const ids = [];
-  const pushId = (entry) => {
-    const num = Number(entry);
-    if (Number.isFinite(num) && num > 0) ids.push(num);
-  };
-  if (Array.isArray(value)) {
-    value.forEach((entry) => {
-      if (!entry) return;
-      if (typeof entry === 'object') {
-        pushId(entry.id ?? entry.servico_id ?? entry.service_id ?? entry.servicoId ?? entry.serviceId);
-      } else {
-        pushId(entry);
-      }
-    });
-  } else if (value !== undefined && value !== null && String(value).trim() !== '') {
-    String(value)
-      .split(',')
-      .map((part) => part.trim())
-      .filter(Boolean)
-      .forEach(pushId);
-  }
-  const seen = new Set();
-  return ids.filter((id) => {
-    if (seen.has(id)) return false;
-    seen.add(id);
-    return true;
-  });
-};
-
-const extractServiceIds = (body) => {
-  if (!body || typeof body !== 'object') return [];
-  const rawList =
-    body.servico_ids ??
-    body.servicos ??
-    body.service_ids ??
-    body.services ??
-    body.serviceIds ??
-    body.servicoIds ??
-    null;
-  const parsed = normalizeServiceIds(rawList);
-  if (parsed.length) return parsed;
-  if (body.servico_id != null) {
-    return normalizeServiceIds([body.servico_id]);
-  }
-  return [];
-};
-
-const summarizeServices = (items) => {
-  const serviceNames = items.map((item) => item?.nome).filter(Boolean);
-  const duracaoTotal = items.reduce((sum, item) => sum + Number(item?.duracao_min || 0), 0);
-  const precoTotal = items.reduce(
-    (sum, item) =>
-      sum +
-      Number(
-        item?.preco_centavos ??
-          item?.preco_centavos_snapshot ??
-          item?.preco_snapshot ??
-          0
-      ),
-    0
-  );
-  return {
-    serviceIds: items.map((item) => item.id),
-    serviceNames,
-    serviceLabel: serviceNames.join(' + '),
-    duracaoTotal,
-    precoTotal,
-  };
-};
-
-const fetchServicesForAppointment = async (db, estabelecimentoId, serviceIds) => {
-  if (!serviceIds.length) return { items: [], missing: serviceIds };
-  const placeholders = serviceIds.map(() => '?').join(', ');
-  const [rows] = await db.query(
-    `SELECT id, nome, duracao_min, preco_centavos
-       FROM servicos
-      WHERE id IN (${placeholders})
-        AND estabelecimento_id=?
-        AND ativo=1`,
-    [...serviceIds, estabelecimentoId]
-  );
-  const map = new Map(rows.map((row) => [Number(row.id), row]));
-  const missing = serviceIds.filter((id) => !map.has(Number(id)));
-  if (missing.length) return { items: [], missing };
-  const items = serviceIds.map((id) => {
-    const svc = map.get(Number(id));
-    return {
-      id: Number(svc.id),
-      nome: svc.nome,
-      duracao_min: Number(svc.duracao_min || 0),
-      preco_centavos: Number(svc.preco_centavos || 0),
-    };
-  });
-  return { items, missing: [] };
-};
-
-const fetchServiceProfessionalMap = async (db, serviceIds) => {
-  if (!serviceIds.length) return new Map();
-  const placeholders = serviceIds.map(() => '?').join(', ');
-  const [rows] = await db.query(
-    `SELECT servico_id, profissional_id
-       FROM servico_profissionais
-      WHERE servico_id IN (${placeholders})`,
-    serviceIds
-  );
-  const map = new Map();
-  rows.forEach((row) => {
-    const key = Number(row.servico_id);
-    if (!map.has(key)) map.set(key, new Set());
-    map.get(key).add(Number(row.profissional_id));
-  });
-  return map;
-};
-
-const fetchAppointmentItems = async (db, appointmentIds) => {
-  if (!appointmentIds.length) return new Map();
-  const placeholders = appointmentIds.map(() => '?').join(', ');
-  const [rows] = await db.query(
-    `SELECT ai.agendamento_id,
-            ai.servico_id,
-            ai.ordem,
-            ai.duracao_min,
-            ai.preco_snapshot,
-            s.nome AS servico_nome
-       FROM agendamento_itens ai
-       JOIN servicos s ON s.id = ai.servico_id
-      WHERE ai.agendamento_id IN (${placeholders})
-      ORDER BY ai.agendamento_id, ai.ordem`,
-    appointmentIds
-  );
-  const byAppointment = new Map();
-  rows.forEach((row) => {
-    const key = Number(row.agendamento_id);
-    if (!byAppointment.has(key)) byAppointment.set(key, []);
-    const precoCentavosSnapshot = Number(row.preco_snapshot || 0);
-    byAppointment.get(key).push({
-      id: Number(row.servico_id),
-      nome: row.servico_nome,
-      ordem: Number(row.ordem) || 0,
-      duracao_min: Number(row.duracao_min || 0),
-      preco_centavos_snapshot: precoCentavosSnapshot,
-      preco_snapshot: precoCentavosSnapshot,
-    });
-  });
-  return byAppointment;
-};
-
-const hydrateAppointmentsWithItems = async (db, rows) => {
-  const ids = (rows || [])
-    .map((row) => Number(row?.id))
-    .filter((id) => Number.isFinite(id) && id > 0);
-  if (!ids.length) return rows;
-  const itemsByAppointment = await fetchAppointmentItems(db, ids);
-  rows.forEach((row) => {
-    const items = itemsByAppointment.get(Number(row.id)) || [];
-    const summary = summarizeServices(items.map((item) => ({
-      id: item.id,
-      nome: item.nome,
-      duracao_min: item.duracao_min,
-      preco_centavos: item.preco_centavos_snapshot ?? item.preco_snapshot,
-    })));
-    row.servicos = items;
-    row.servico_ids = summary.serviceIds;
-    row.servico_nome = summary.serviceLabel || row.servico_nome || '';
-    row.duracao_total = summary.duracaoTotal;
-    row.preco_total = summary.precoTotal;
-  });
-  return rows;
-};
-
-function brDateTime(iso) {
-  return new Date(iso).toLocaleString('pt-BR', {
-    hour: '2-digit', minute: '2-digit', day: '2-digit', month: '2-digit', year: 'numeric',
-    timeZone: TZ
-  });
-}
-function brDate(iso) {
-  return new Date(iso).toLocaleDateString('pt-BR', { timeZone: TZ });
-}
-function brTime(iso) {
-  return new Date(iso).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit', timeZone: TZ });
-}
-
-// Utilitario: dispara funcao async em background sem nunca derrubar a rota
-function fireAndForget(fn) {
-  try {
-    const p = Promise.resolve().then(fn);
-    p.catch((e) => console.warn('[notify] erro (async):', e?.message || e));
-  } catch (e) {
-    console.warn('[notify] erro (sync):', e?.message || e);
-  }
-}
-
-/* =================== Listagens =================== */
-
-// Lista meus agendamentos (cliente)
-router.get('/', authRequired, isCliente, async (req, res) => {
-  const clienteId = req.user.id;
-  const [rows] = await pool.query(`
-    SELECT a.*,
-           u.nome AS estabelecimento_nome,
-           p.nome AS profissional_nome,
-           p.avatar_url AS profissional_avatar_url
-    FROM agendamentos a
-    JOIN usuarios u   ON u.id=a.estabelecimento_id
-    LEFT JOIN profissionais p ON p.id = a.profissional_id
-    WHERE a.cliente_id=?
-    ORDER BY a.inicio DESC
-  `, [clienteId]);
-  await hydrateAppointmentsWithItems(pool, rows);
-  res.json(rows);
-});
-
-// Lista agendamentos do estabelecimento (somente confirmados/pendentes)
-router.get('/estabelecimento', authRequired, isEstabelecimento, async (req, res) => {
-  const estId = req.user.id;
-  const status = String(req.query?.status || '').toLowerCase();
-
-  // Mapeia filtros: por padrao mantem confirmados+pendentes (comportamento atual)
-  // status=todos -> todos; status=confirmado|cancelado|pendente -> somente aquele
-  let where = 'a.estabelecimento_id=? AND a.status IN (\'confirmado\',\'pendente\')';
-  const params = [estId];
-  if (status === 'todos') {
-    where = 'a.estabelecimento_id=?';
-  } else if (['confirmado', 'cancelado', 'pendente'].includes(status)) {
-    where = 'a.estabelecimento_id=? AND a.status=?';
-    params.push(status);
-  }
-
-  const [rows] = await pool.query(
-    `SELECT a.*,
-            u.nome AS cliente_nome,
-            u.telefone AS cliente_telefone,
-            p.nome AS profissional_nome,
-            p.avatar_url AS profissional_avatar_url
-     FROM agendamentos a
-     JOIN usuarios u ON u.id=a.cliente_id
-     LEFT JOIN profissionais p ON p.id = a.profissional_id
-     WHERE ${where}
-     ORDER BY a.inicio DESC`,
-    params
-  );
-  await hydrateAppointmentsWithItems(pool, rows);
-  res.json(rows);
-});
-
-/* =================== Criacao =================== */
-
-// Criar agendamento (cliente)
-router.post('/', authRequired, isCliente, async (req, res) => {
-  let conn;
-  let txStarted = false;
-  try {
-    const { estabelecimento_id, inicio, profissional_id: profissionalIdRaw, profissionalId } = req.body || {};
-    const serviceIds = extractServiceIds(req.body || {});
-    const professionalCandidate = profissionalIdRaw != null ? profissionalIdRaw : profissionalId;
+// backend/src/routes/agendamentos.js

+import { Router } from 'express';

+import { pool } from '../lib/db.js';

+import { assertDentroExpediente, formatExpedienteMessage, getExpediente, getLocalRangeMinutes } from '../lib/expediente.js';

+import { getPlanContext, isDelinquentStatus, formatPlanLimitExceeded } from '../lib/plans.js';

+import { auth as authRequired, isCliente, isEstabelecimento } from '../middleware/auth.js';

+import { notifyEmail } from '../lib/notifications.js';
+import { sendAppointmentWhatsApp } from '../lib/whatsapp_outbox.js';
+import { buildConfirmacaoAgendamentoV2Components, isConfirmacaoAgendamentoV2 } from '../lib/whatsapp_templates.js';
+import { createMercadoPagoPixPayment } from '../lib/billing.js';
+import { resolveMpAccessToken } from '../services/mpAccounts.js';
+import bcrypt from 'bcryptjs';
+import { checkMonthlyAppointmentLimit, notifyAppointmentLimitReached } from '../lib/appointment_limits.js';
+import { estabNotificationsDisabled } from '../lib/estab_notifications.js';
+import { clientWhatsappDisabled, whatsappImmediateDisabled, whatsappConfirmationDisabled } from '../lib/client_notifications.js';
+

+const router = Router();

+

+const TZ = 'America/Sao_Paulo';

+const FRONTEND_BASE = String(process.env.FRONTEND_BASE_URL || process.env.APP_URL || 'http://localhost:3001').replace(/\/$/, '');

+const toDigits = (s) => String(s || '').replace(/\D/g, ''); // normaliza telefone para apenas digitos

+const normalizePhoneBR = (value) => {

+  let digits = toDigits(value);

+  if (!digits) return '';

+  digits = digits.replace(/^0+/, '');

+  if (digits.startsWith('55')) return digits;

+  if (digits.length >= 10 && digits.length <= 11) return `55${digits}`;

+  return digits;

+};

+const normalizeBirthdate = (value) => {

+  if (value === undefined || value === null) return null;

+  const raw = String(value).trim();

+  if (!raw) return null;

+  const match = raw.match(/^(\d{4})-(\d{2})-(\d{2})$/);

+  if (!match) return null;

+  const year = Number(match[1]);

+  const month = Number(match[2]);

+  const day = Number(match[3]);

+  const dt = new Date(year, month - 1, day);

+  if (

+    Number.isNaN(dt.getTime()) ||

+    dt.getFullYear() !== year ||

+    dt.getMonth() + 1 !== month ||

+    dt.getDate() !== day

+  ) {

+    return null;

+  }

+  return `${match[1]}-${match[2]}-${match[3]}`;

+};

+const boolPref = (value, fallback = true) => {

+  if (value === undefined || value === null) return fallback;

+  if (value === true || value === false) return Boolean(value);

+  const num = Number(value);

+  if (!Number.isNaN(num)) return num !== 0;

+  const norm = String(value).trim().toLowerCase();

+  if (['0', 'false', 'off', 'no', 'nao'].includes(norm)) return false;

+  if (['1', 'true', 'on', 'yes', 'sim'].includes(norm)) return true;

+  return fallback;

+};

+const CANCEL_MINUTES_CLIENT = (() => {

+  const raw = process.env.CANCEL_MINUTES_CLIENT;

+  if (raw === undefined || raw === null || String(raw).trim() === '') return 120;

+  const parsed = Number(raw);

+  return Number.isFinite(parsed)  parsed : 120;

+})();

+const formatCancelLimitLabel = (minutes) => {

+  if (!Number.isFinite(minutes) || minutes <= 0) return '';

+  if (minutes % 60 === 0) {

+    const hours = minutes / 60;

+    return `${hours} hora${hours === 1  '' : 's'}`;

+  }

+  return `${minutes} minutos`;

+};

+const APPOINTMENT_BUFFER_MIN = (() => {
+  const raw = process.env.AGENDAMENTO_BUFFER_MIN  process.env.APPOINTMENT_BUFFER_MIN;
+  if (raw === undefined || raw === null || String(raw).trim() === '') return 0;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) && parsed > 0  Math.round(parsed) : 0;
+})();
+const DEFAULT_DEPOSIT_HOLD_MINUTES = 15;
+const DEPOSIT_ALLOWED_PLANS = new Set(['pro', 'premium']);
+
+const safeJson = (payload) => {
+  try {
+    return JSON.stringify(payload);
+  } catch {
+    return null;
+  }
+};
+
+function resolveApiBaseUrl() {
+  const frontBase = String(process.env.FRONTEND_BASE_URL || process.env.APP_URL || 'http://localhost:3001').replace(/\/$/, '');
+  const isDevFront = /^(https?:\/\/)?(localhost|127\.0\.0\.1):3001$/i.test(frontBase);
+  const defaultApi = isDevFront  'http://localhost:3002' : `${frontBase}/api`;
+  return String(process.env.API_BASE_URL || process.env.BACKEND_BASE_URL || defaultApi).replace(/\/$/, '');
+}
+
+async function resolveDepositConfig(estabelecimentoId, planContext) {
+  const allowed = DEPOSIT_ALLOWED_PLANS.has(String(planContext?.plan || '').toLowerCase());
+  if (!allowed) {
+    return { allowed: false, enabled: false, percent: null, holdMinutes: DEFAULT_DEPOSIT_HOLD_MINUTES };
+  }
+  const [rows] = await pool.query(
+    'SELECT deposit_enabled, deposit_percent, deposit_hold_minutes FROM establishment_settings WHERE estabelecimento_id= LIMIT 1',
+    [estabelecimentoId]
+  );
+  const row = rows?.[0];
+  const enabledFlag = row  Number(row.deposit_enabled || 0) : 0;
+  const percent = row?.deposit_percent != null  Number(row.deposit_percent) : null;
+  const holdMinutes = Number(row?.deposit_hold_minutes || DEFAULT_DEPOSIT_HOLD_MINUTES) || DEFAULT_DEPOSIT_HOLD_MINUTES;
+  const enabled =
+    Boolean(enabledFlag) &&
+    Number.isFinite(percent) &&
+    percent >= 5 &&
+    percent <= 90;
+  return { allowed: true, enabled, percent, holdMinutes };
+}
+const normalizeServiceIds = (value) => {

+  const ids = [];

+  const pushId = (entry) => {

+    const num = Number(entry);

+    if (Number.isFinite(num) && num > 0) ids.push(num);

+  };

+  if (Array.isArray(value)) {

+    value.forEach((entry) => {

+      if (!entry) return;

+      if (typeof entry === 'object') {

+        pushId(entry.id  entry.servico_id  entry.service_id  entry.servicoId  entry.serviceId);

+      } else {

+        pushId(entry);

+      }

+    });

+  } else if (value !== undefined && value !== null && String(value).trim() !== '') {

+    String(value)

+      .split(',')

+      .map((part) => part.trim())

+      .filter(Boolean)

+      .forEach(pushId);

+  }

+  const seen = new Set();

+  return ids.filter((id) => {

+    if (seen.has(id)) return false;

+    seen.add(id);

+    return true;

+  });

+};

+

+const extractServiceIds = (body) => {

+  if (!body || typeof body !== 'object') return [];

+  const rawList =

+    body.servico_ids ?

+    body.servicos ?

+    body.service_ids ?

+    body.services ?

+    body.serviceIds ?

+    body.servicoIds ?

+    null;

+  const parsed = normalizeServiceIds(rawList);

+  if (parsed.length) return parsed;

+  if (body.servico_id != null) {

+    return normalizeServiceIds([body.servico_id]);

+  }

+  return [];

+};

+

+const summarizeServices = (items) => {

+  const serviceNames = items.map((item) => item?.nome).filter(Boolean);

+  const duracaoTotal = items.reduce((sum, item) => sum + Number(item?.duracao_min || 0), 0);

+  const precoTotal = items.reduce(

+    (sum, item) =>

+      sum +

+      Number(

+        item?.preco_centavos ?

+          item?.preco_centavos_snapshot ?

+          item?.preco_snapshot ?

+          0

+      ),

+    0

+  );

+  return {

+    serviceIds: items.map((item) => item.id),

+    serviceNames,

+    serviceLabel: serviceNames.join(' + '),

+    duracaoTotal,

+    precoTotal,

+  };

+};

+

+const fetchServicesForAppointment = async (db, estabelecimentoId, serviceIds) => {

+  if (!serviceIds.length) return { items: [], missing: serviceIds };

+  const placeholders = serviceIds.map(() => '?').join(', ');

+  const [rows] = await db.query(

+    `SELECT id, nome, duracao_min, preco_centavos

+       FROM servicos

+      WHERE id IN (${placeholders})

+        AND estabelecimento_id=?

+        AND ativo=1`,

+    [...serviceIds, estabelecimentoId]

+  );

+  const map = new Map(rows.map((row) => [Number(row.id), row]));

+  const missing = serviceIds.filter((id) => !map.has(Number(id)));

+  if (missing.length) return { items: [], missing };

+  const items = serviceIds.map((id) => {

+    const svc = map.get(Number(id));

+    return {

+      id: Number(svc.id),

+      nome: svc.nome,

+      duracao_min: Number(svc.duracao_min || 0),

+      preco_centavos: Number(svc.preco_centavos || 0),

+    };

+  });

+  return { items, missing: [] };

+};

+

+const fetchServiceProfessionalMap = async (db, serviceIds) => {

+  if (!serviceIds.length) return new Map();

+  const placeholders = serviceIds.map(() => '?').join(', ');

+  const [rows] = await db.query(

+    `SELECT servico_id, profissional_id

+       FROM servico_profissionais

+      WHERE servico_id IN (${placeholders})`,

+    serviceIds

+  );

+  const map = new Map();

+  rows.forEach((row) => {

+    const key = Number(row.servico_id);

+    if (!map.has(key)) map.set(key, new Set());

+    map.get(key).add(Number(row.profissional_id));

+  });

+  return map;

+};

+

+const fetchAppointmentItems = async (db, appointmentIds) => {

+  if (!appointmentIds.length) return new Map();

+  const placeholders = appointmentIds.map(() => '?').join(', ');

+  const [rows] = await db.query(

+    `SELECT ai.agendamento_id,

+            ai.servico_id,

+            ai.ordem,

+            ai.duracao_min,

+            ai.preco_snapshot,

+            s.nome AS servico_nome

+       FROM agendamento_itens ai

+       JOIN servicos s ON s.id = ai.servico_id

+      WHERE ai.agendamento_id IN (${placeholders})

+      ORDER BY ai.agendamento_id, ai.ordem`,

+    appointmentIds

+  );

+  const byAppointment = new Map();

+  rows.forEach((row) => {

+    const key = Number(row.agendamento_id);

+    if (!byAppointment.has(key)) byAppointment.set(key, []);

+    const precoCentavosSnapshot = Number(row.preco_snapshot || 0);

+    byAppointment.get(key).push({

+      id: Number(row.servico_id),

+      nome: row.servico_nome,

+      ordem: Number(row.ordem) || 0,

+      duracao_min: Number(row.duracao_min || 0),

+      preco_centavos_snapshot: precoCentavosSnapshot,

+      preco_snapshot: precoCentavosSnapshot,

+    });

+  });

+  return byAppointment;

+};

+

+const hydrateAppointmentsWithItems = async (db, rows) => {

+  const ids = (rows || [])

+    .map((row) => Number(row?.id))

+    .filter((id) => Number.isFinite(id) && id > 0);

+  if (!ids.length) return rows;

+  const itemsByAppointment = await fetchAppointmentItems(db, ids);

+  rows.forEach((row) => {

+    const items = itemsByAppointment.get(Number(row.id)) || [];

+    const summary = summarizeServices(items.map((item) => ({

+      id: item.id,

+      nome: item.nome,

+      duracao_min: item.duracao_min,

+      preco_centavos: item.preco_centavos_snapshot  item.preco_snapshot,

+    })));

+    row.servicos = items;

+    row.servico_ids = summary.serviceIds;

+    row.servico_nome = summary.serviceLabel || row.servico_nome || '';

+    row.duracao_total = summary.duracaoTotal;

+    row.preco_total = summary.precoTotal;

+  });

+  return rows;

+};

+

+function brDateTime(iso) {

+  return new Date(iso).toLocaleString('pt-BR', {

+    hour: '2-digit', minute: '2-digit', day: '2-digit', month: '2-digit', year: 'numeric',

+    timeZone: TZ

+  });

+}

+function brDate(iso) {

+  return new Date(iso).toLocaleDateString('pt-BR', { timeZone: TZ });

+}

+function brTime(iso) {

+  return new Date(iso).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit', timeZone: TZ });

+}

+

+// Utilitario: dispara funcao async em background sem nunca derrubar a rota

+function fireAndForget(fn) {

+  try {

+    const p = Promise.resolve().then(fn);

+    p.catch((e) => console.warn('[notify] erro (async):', e?.message || e));

+  } catch (e) {

+    console.warn('[notify] erro (sync):', e?.message || e);

+  }

+}

+

+/* =================== Listagens =================== */

+

+// Lista meus agendamentos (cliente)

+router.get('/', authRequired, isCliente, async (req, res) => {

+  const clienteId = req.user.id;

+  const [rows] = await pool.query(`

+    SELECT a.*,

+           u.nome AS estabelecimento_nome,

+           p.nome AS profissional_nome,

+           p.avatar_url AS profissional_avatar_url

+    FROM agendamentos a

+    JOIN usuarios u   ON u.id=a.estabelecimento_id

+    LEFT JOIN profissionais p ON p.id = a.profissional_id

+    WHERE a.cliente_id=?

+    ORDER BY a.inicio DESC

+  `, [clienteId]);

+  await hydrateAppointmentsWithItems(pool, rows);

+  res.json(rows);

+});

+

+// Lista agendamentos do estabelecimento (somente confirmados/pendentes)

+router.get('/estabelecimento', authRequired, isEstabelecimento, async (req, res) => {

+  const estId = req.user.id;

+  const status = String(req.query?.status || '').toLowerCase();

+

+  // Mapeia filtros: por padrao mantem confirmados+pendentes (inclui pendente_pagamento)
+  // status=todos -> todos; status=confirmado|cancelado|pendente|pendente_pagamento -> somente aquele
+  let where = 'a.estabelecimento_id= AND a.status IN (\'confirmado\',\'pendente\',\'pendente_pagamento\')';
+  const params = [estId];
+  if (status === 'todos') {
+    where = 'a.estabelecimento_id=?';
+  } else if (['confirmado', 'cancelado', 'pendente', 'pendente_pagamento'].includes(status)) {
+    where = 'a.estabelecimento_id= AND a.status=?';
+    params.push(status);
+  }
+

+  const [rows] = await pool.query(

+    `SELECT a.*,

+            u.nome AS cliente_nome,

+            u.telefone AS cliente_telefone,

+            p.nome AS profissional_nome,

+            p.avatar_url AS profissional_avatar_url

+     FROM agendamentos a

+     JOIN usuarios u ON u.id=a.cliente_id

+     LEFT JOIN profissionais p ON p.id = a.profissional_id

+     WHERE ${where}

+     ORDER BY a.inicio DESC`,

+    params

+  );

+  await hydrateAppointmentsWithItems(pool, rows);

+  res.json(rows);

+});

+

+/* =================== Criacao =================== */

+

+// Criar agendamento (cliente)

+router.post('/', authRequired, isCliente, async (req, res) => {
+  let conn;
+  let txStarted = false;
+  try {

+    const { estabelecimento_id, inicio, profissional_id: profissionalIdRaw, profissionalId } = req.body || {};

+    const serviceIds = extractServiceIds(req.body || {});

+    const professionalCandidate = profissionalIdRaw != null  profissionalIdRaw : profissionalId;

     const profissional_id = professionalCandidate == null ? null : Number(professionalCandidate);
-
-    if (profissional_id !== null && !Number.isFinite(profissional_id)) {
-      return res.status(400).json({ error: 'profissional_invalido', message: 'Profissional invalido.' });
-    }
-
-    // 1) validacao basica
-    if (!estabelecimento_id || !serviceIds.length || !inicio) {
-      return res.status(400).json({
-        error: 'invalid_payload',
-        message: 'Campos obrigatorios: estabelecimento_id, servico_ids, inicio (ISO).'
-      });
-    }
-
-    const inicioDate = new Date(inicio);
-    if (Number.isNaN(inicioDate.getTime())) {
-      return res.status(400).json({ error: 'invalid_date', message: 'Formato de data/hora invalido.' });
-    }
-    if (inicioDate.getTime() <= Date.now()) {
-      return res.status(400).json({ error: 'past_datetime', message: 'Não é possível agendar no passado.' });
-    }
-
-    // 2) valida servico e vinculo com estabelecimento
-    const planContext = await getPlanContext(estabelecimento_id);
-    if (!planContext) {
-      return res.status(404).json({ error: 'estabelecimento_inexistente' });
-    }
-    if (isDelinquentStatus(planContext.status)) {
-      return res.status(403).json({ error: 'plan_delinquent', message: 'Este estabelecimento esta com o plano em atraso. Agendamentos temporariamente suspensos.' });
-    }
-
-    const { items: serviceItems, missing } = await fetchServicesForAppointment(pool, estabelecimento_id, serviceIds);
-    if (missing.length) {
-      return res.status(400).json({ error: 'servico_invalido', message: 'Servico invalido ou inativo para este estabelecimento.' });
-    }
-    if (serviceItems.some((item) => !Number.isFinite(item.duracao_min) || item.duracao_min <= 0)) {
-      return res.status(400).json({ error: 'duracao_invalida', message: 'Duracao do servico invalida.' });
-    }
-    const summary = summarizeServices(serviceItems);
-    const primaryServiceId = summary.serviceIds[0] || serviceIds[0];
-    const serviceLabel = summary.serviceLabel || serviceItems[0]?.nome || 'servico';
-
-    const professionalMap = await fetchServiceProfessionalMap(pool, serviceIds);
-    const servicesRequiringProfessional = serviceIds.filter((id) => (professionalMap.get(id)?.size || 0) > 0);
-    const requiresProfessional = servicesRequiringProfessional.length > 0;
-    let profissionalRow = null;
-
-    if (requiresProfessional && profissional_id == null) {
-      return res.status(400).json({ error: 'profissional_obrigatorio', message: 'Escolha um profissional para estes servicos.' });
-    }
-
-    if (profissional_id != null) {
-      const [[profRow]] = await pool.query(
-        'SELECT id, nome, avatar_url, ativo FROM profissionais WHERE id=? AND estabelecimento_id=?',
-        [profissional_id, estabelecimento_id]
-      );
-      if (!profRow) {
-        return res.status(400).json({ error: 'profissional_invalido', message: 'Profissional nao encontrado para este estabelecimento.' });
-      }
-      if (!profRow.ativo) {
-        return res.status(400).json({ error: 'profissional_inativo', message: 'Profissional inativo.' });
-      }
-      if (requiresProfessional) {
-        const valid = servicesRequiringProfessional.every((id) => professionalMap.get(id)?.has(profissional_id));
-        if (!valid) {
-          return res.status(400).json({ error: 'profissional_servico', message: 'Profissional nao esta associado a todos os servicos selecionados.' });
-        }
-      }
-      profissionalRow = profRow;
-    }
-
-    const duracaoTotalComBuffer = summary.duracaoTotal + APPOINTMENT_BUFFER_MIN;
-    if (!Number.isFinite(duracaoTotalComBuffer) || duracaoTotalComBuffer <= 0) {
-      return res.status(400).json({ error: 'duracao_invalida', message: 'Duracao do servico invalida.' });
-    }
-    const fimDate = new Date(inicioDate.getTime() + duracaoTotalComBuffer * 60_000);
-    const expediente = await getExpediente({
-      db: conn || pool,
-      estabelecimentoId: estabelecimento_id,
-      dateUtc: inicioDate,
-    });
-    const { startMin, endMin, spansDays } = getLocalRangeMinutes(inicioDate, fimDate);
-    if (!assertDentroExpediente({
-      startMin,
-      endMin,
-      abre: expediente.abre,
-      fecha: expediente.fecha,
-      spansDays,
-      breaks: expediente.breaks,
-    })) {
-      if (conn) {
-        if (txStarted) {
-          await conn.rollback();
-        }
-        conn.release();
-        conn = null;
-      }
-      return res.status(400).json({ error: 'outside_business_hours', message: formatExpedienteMessage(expediente) });
-    }
-    const planConfig = planContext?.config;
-    const limitCheck = await checkMonthlyAppointmentLimit({
-      estabelecimentoId: estabelecimento_id,
-      planConfig,
-      appointmentDate: inicioDate,
-    });
-    if (!limitCheck.ok) {
-      fireAndForget(() => notifyAppointmentLimitReached({
-        estabelecimentoId: estabelecimento_id,
-        limit: limitCheck.limit,
-        total: limitCheck.total,
-        range: limitCheck.range,
-        planConfig,
-      }));
-      return res.status(403).json({
-        error: 'plan_limit_agendamentos',
-        message: formatPlanLimitExceeded(planConfig, 'appointments') || 'Limite de agendamentos atingido para este mês.',
-        details: {
-          limit: limitCheck.limit,
-          total: limitCheck.total,
-          month: limitCheck.range?.label || null,
-        },
-      });
-    }
-
-    // 3) transacao + checagem de conflito
-    conn = await pool.getConnection();
-    await conn.beginTransaction();
-    txStarted = true;
-
-    // Conflito por sobreposicao: a.inicio < novoFim AND a.fim > novoInicio
-    let conflictSql = `
-      SELECT id FROM agendamentos
-      WHERE estabelecimento_id = ? AND status IN ('confirmado','pendente')
-        AND (status <> 'pendente' OR public_confirm_expires_at IS NULL OR public_confirm_expires_at >= NOW())
-        AND (inicio < ? AND fim > ?)
-    `;
-    const conflictParams = [estabelecimento_id, fimDate, inicioDate];
-    if (profissional_id != null && requiresProfessional) {
-      conflictSql += ' AND (profissional_id IS NULL OR profissional_id=?)';
-      conflictParams.push(profissional_id);
-    }
-    conflictSql += ' FOR UPDATE';
-
-    const [conf] = await conn.query(conflictSql, conflictParams);
-
-    if (conf.length) {
-      if (txStarted && conn) {
-        await conn.rollback();
-      }
-      conn.release();
-      return res.status(409).json({ error: 'slot_ocupado', message: 'Horário indisponível.' });
-    }
-
-    // 4) insere (status usa default 'confirmado')
-    const [r] = await conn.query(
-      'INSERT INTO agendamentos (cliente_id, estabelecimento_id, servico_id, profissional_id, inicio, fim) VALUES (?,?,?,?,?,?)',
-      [req.user.id, estabelecimento_id, primaryServiceId, profissional_id || null, inicioDate, fimDate]
-    );
-    const itemValues = serviceItems.map((item, idx) => ([
-      r.insertId,
-      item.id,
-      idx + 1,
-      Math.max(0, Math.round(item.duracao_min || 0)),
-      Math.max(0, Math.round(item.preco_centavos || 0)),
-    ]));
-    if (itemValues.length) {
-      const placeholders = itemValues.map(() => '(?,?,?,?,?)').join(',');
-      await conn.query(
-        `INSERT INTO agendamento_itens (agendamento_id, servico_id, ordem, duracao_min, preco_snapshot) VALUES ${placeholders}`,
-        itemValues.flat()
-      );
-    }
-
-    // 5) le dados consistentes ainda na transacao
-    const [[novo]] = await conn.query('SELECT * FROM agendamentos WHERE id=?', [r.insertId]);
-    const [[cli]]  = await conn.query('SELECT email, telefone, nome FROM usuarios WHERE id=?', [req.user.id]);
-    const [[est]]  = await conn.query('SELECT email, telefone, nome, notify_email_estab, notify_whatsapp_estab FROM usuarios WHERE id=?', [estabelecimento_id]);
-
-    await conn.commit();
-    txStarted = false;
-    conn.release(); conn = null;
-
-    // 6) notificacao "best-effort" (NUNCA bloqueia a resposta)
-    const inicioISO = new Date(novo.inicio).toISOString();
-    const inicioBR  = brDateTime(inicioISO);
-    const hora      = brTime(inicioISO);
-    const data      = brDate(inicioISO);
-
-    const telCli = toDigits(cli?.telefone);
-    const telEst = toDigits(est?.telefone);
-    const canEmailEst = boolPref(est?.notify_email_estab, true);
-    const canWhatsappEst = boolPref(est?.notify_whatsapp_estab, true);
-    const blockEstabNotifications = estabNotificationsDisabled();
-    const blockClientWhatsapp = clientWhatsappDisabled();
-    const blockWhatsappImmediate = whatsappImmediateDisabled();
-    const blockWhatsappConfirmation = whatsappConfirmationDisabled();
-    const estNome = est?.nome || '';
-    const estNomeFriendly = estNome || 'nosso estabelecimento';
-    const profNome = profissionalRow?.nome || '';
-    const profLabel = profNome ? ` com ${profNome}` : '';
-    const appointmentLink = `${FRONTEND_BASE}/cliente?agendamento=${novo.id}`;
-    const appointmentLinkHtml = `<p><a href="${appointmentLink}">Ver agendamento</a></p>`;
-
-    // (a) Emails (background)
-    fireAndForget(async () => {
-      if (cli?.email) {
-        await notifyEmail(
-          cli.email,
-          'Agendamento confirmado',
-          `<p>Olá, <b>${cli?.nome ?? 'cliente'}</b>! Seu agendamento de <b>${serviceLabel}</b>${profLabel ? ` com <b>${profNome}</b>` : ''} foi confirmado para <b>${inicioBR}</b>.</p>${appointmentLinkHtml}`
-        );
-      }
-      if (!blockEstabNotifications && est?.email && canEmailEst) {
-        await notifyEmail(
-          est.email,
-          'Novo agendamento recebido',
-          `<p>Você recebeu um novo agendamento de <b>${serviceLabel}</b>${profLabel ? ` com <b>${profNome}</b>` : ''} em <b>${inicioBR}</b> para o cliente <b>${cli?.nome ?? ''}</b>.</p>`
-        );
-      }
-    });
-
-    // (b) WhatsApp imediato
-    fireAndForget(async () => {
-      if (blockWhatsappImmediate || blockWhatsappConfirmation) return; // WhatsApp imediato desativado via env ou confirmacao desativada
-      const paramMode = String(process.env.WA_TEMPLATE_PARAM_MODE || 'single').toLowerCase();
-      const tplName = process.env.WA_TEMPLATE_NAME_CONFIRM || process.env.WA_TEMPLATE_NAME || 'confirmacao_agendamento_v2';
-      const tplLang = process.env.WA_TEMPLATE_LANG || 'pt_BR';
-      const estNomeLabel = estNome || '';
-      const isConfirmV2 = isConfirmacaoAgendamentoV2(tplName);
-      const tplParams = isConfirmV2
-        ? buildConfirmacaoAgendamentoV2Components({
-            serviceLabel,
-            dataHoraLabel: inicioBR,
-            estabelecimentoNome: estNomeLabel,
-          })
-        : [serviceLabel, inicioBR, estNomeLabel];
-      const waMsg = `o. - Novo agendamento registrado: ${serviceLabel}${profNome ? ' / ' + profNome : ''} em ${inicioBR} ?" ${estNomeLabel}. ?" Obrigado!`;
-      const fallbackBodyParams = isConfirmV2 ? tplParams : [waMsg];
-      if (!blockClientWhatsapp && telCli) {
-        if (/^triple|3$/.test(paramMode)) {
-          await sendAppointmentWhatsApp({
-            estabelecimentoId: estabelecimento_id,
-            agendamentoId: novo.id,
-            to: telCli,
-            kind: 'confirm_cli',
-            template: { name: tplName, lang: tplLang, bodyParams: tplParams },
-          });
-        } else {
-          await sendAppointmentWhatsApp({
-            estabelecimentoId: estabelecimento_id,
-            agendamentoId: novo.id,
-            to: telCli,
-            kind: 'confirm_cli',
-            message: waMsg,
-            template: { name: tplName, lang: tplLang, bodyParams: fallbackBodyParams },
-          });
-        }
-      }
-      if (!blockEstabNotifications && canWhatsappEst && telEst && telEst !== telCli) {
-        if (/^triple|3$/.test(paramMode)) {
-          await sendAppointmentWhatsApp({
-            estabelecimentoId: estabelecimento_id,
-            agendamentoId: novo.id,
-            to: telEst,
-            kind: 'confirm_est',
-            template: { name: tplName, lang: tplLang, bodyParams: tplParams },
-          });
-        } else {
-          await sendAppointmentWhatsApp({
-            estabelecimentoId: estabelecimento_id,
-            agendamentoId: novo.id,
-            to: telEst,
-            kind: 'confirm_est',
-            message: waMsg,
-            template: { name: tplName, lang: tplLang, bodyParams: fallbackBodyParams },
-          });
-        }
-      }
-    });
-
-    // (c) Lembretes de 8h: agora gerenciados por um worker em background que reprocessa mesmo apos restart
-
-    // 7) resposta (NUNCA depende das notificacoes)
-    return res.status(201).json({
-      id: novo.id,
-      cliente_id: novo.cliente_id,
-      estabelecimento_id: novo.estabelecimento_id,
-      servico_id: novo.servico_id,
-      servico_ids: summary.serviceIds,
-      servico_nome: serviceLabel,
-      servicos: serviceItems.map((item, idx) => {
-        const precoCentavosSnapshot = Math.max(0, Math.round(item.preco_centavos || 0));
-        return {
-          id: item.id,
-          nome: item.nome,
-          duracao_min: item.duracao_min,
-          preco_centavos_snapshot: precoCentavosSnapshot,
-          preco_snapshot: precoCentavosSnapshot,
-          ordem: idx + 1,
-        };
-      }),
-      buffer_min: APPOINTMENT_BUFFER_MIN,
-      duracao_total: summary.duracaoTotal,
-      duracao_total_com_buffer: duracaoTotalComBuffer,
-      preco_total: summary.precoTotal,
-      profissional_id: novo.profissional_id,
-      profissional_nome: profissionalRow?.nome || null,
-      profissional_avatar_url: profissionalRow?.avatar_url || null,
-      inicio: novo.inicio,
-      fim: novo.fim,
-      status: novo.status
-    });
-
-  } catch (e) {
-    try { if (txStarted && conn) await conn.rollback(); } catch {}
-    if (conn) { try { conn.release(); } catch {} }
-    console.error('[agendamentos][POST] erro:', e);
-    // Se for erro de chave/unique/conflito que porventura escapou:
-    const msg = String(e?.message || '');
-    if (/duplicate|unique|constraint/i.test(msg)) {
-      return res.status(409).json({ error: 'slot_ocupado', message: 'Horário indisponível.' });
-    }
-    return res.status(500).json({ error: 'server_error' });
-  }
-});
-
-
-
-// Criar agendamento (estabelecimento)
-router.post('/estabelecimento', authRequired, isEstabelecimento, async (req, res) => {
-  let conn;
-  let txStarted = false;
-  try {
-    const {
-      estabelecimento_id: estabelecimentoIdRaw,
-      inicio,
-      nome,
-      email,
-      telefone,
-      profissional_id: profissionalIdRaw,
-      profissionalId,
-      cep,
-      endereco,
-      numero,
-      complemento,
-      bairro,
-      cidade,
-      estado,
-      data_nascimento,
-      dataNascimento,
-    } = req.body || {};
-    const serviceIds = extractServiceIds(req.body || {});
-
-    const estabelecimento_id = req.user?.id;
-    if (!estabelecimento_id) {
-      return res.status(403).json({ error: 'forbidden', message: 'Estabelecimento invalido.' });
-    }
-    if (estabelecimentoIdRaw && Number(estabelecimentoIdRaw) !== Number(estabelecimento_id)) {
-      return res.status(403).json({ error: 'forbidden', message: 'Estabelecimento invalido.' });
-    }
-
-    const professionalCandidate = profissionalIdRaw != null ? profissionalIdRaw : profissionalId;
+

+    if (profissional_id !== null && !Number.isFinite(profissional_id)) {

+      return res.status(400).json({ error: 'profissional_invalido', message: 'Profissional invalido.' });

+    }

+

+    // 1) validacao basica

+    if (!estabelecimento_id || !serviceIds.length || !inicio) {

+      return res.status(400).json({

+        error: 'invalid_payload',

+        message: 'Campos obrigatorios: estabelecimento_id, servico_ids, inicio (ISO).'

+      });

+    }

+

+    const inicioDate = new Date(inicio);

+    if (Number.isNaN(inicioDate.getTime())) {

+      return res.status(400).json({ error: 'invalid_date', message: 'Formato de data/hora invalido.' });

+    }

+    if (inicioDate.getTime() <= Date.now()) {

+      return res.status(400).json({ error: 'past_datetime', message: 'Não é possível agendar no passado.' });

+    }

+

+    // 2) valida servico e vinculo com estabelecimento

+    const planContext = await getPlanContext(estabelecimento_id);

+    if (!planContext) {

+      return res.status(404).json({ error: 'estabelecimento_inexistente' });

+    }

+    if (isDelinquentStatus(planContext.status)) {

+      return res.status(403).json({ error: 'plan_delinquent', message: 'Este estabelecimento esta com o plano em atraso. Agendamentos temporariamente suspensos.' });

+    }

+

+    const { items: serviceItems, missing } = await fetchServicesForAppointment(pool, estabelecimento_id, serviceIds);

+    if (missing.length) {

+      return res.status(400).json({ error: 'servico_invalido', message: 'Servico invalido ou inativo para este estabelecimento.' });

+    }

+    if (serviceItems.some((item) => !Number.isFinite(item.duracao_min) || item.duracao_min <= 0)) {

+      return res.status(400).json({ error: 'duracao_invalida', message: 'Duracao do servico invalida.' });

+    }

+    const summary = summarizeServices(serviceItems);
+    const primaryServiceId = summary.serviceIds[0] || serviceIds[0];
+    const serviceLabel = summary.serviceLabel || serviceItems[0]?.nome || 'servico';
+    const totalCentavos = Math.max(0, Math.round(summary.precoTotal || 0));
+    const depositConfig = await resolveDepositConfig(estabelecimento_id, planContext);
+    const depositCandidate = depositConfig.allowed && depositConfig.enabled && req.user?.tipo === 'cliente';
+    const depositPercent = depositCandidate  Number(depositConfig.percent || 0) : null;
+    let depositCentavos = depositCandidate  Math.round(totalCentavos * (depositPercent || 0) / 100) : null;
+    const depositRequired = depositCandidate && totalCentavos > 0 && Number.isFinite(depositCentavos) && depositCentavos > 0;
+    if (!depositRequired) depositCentavos = null;
+    const depositHoldMinutes = depositRequired  depositConfig.holdMinutes : DEFAULT_DEPOSIT_HOLD_MINUTES;
+    const depositExpiresAt = depositRequired
+       new Date(Date.now() + Number(depositHoldMinutes || DEFAULT_DEPOSIT_HOLD_MINUTES) * 60_000)
+      : null;
+    let mpAccessToken = null;
+    if (depositRequired) {
+      const mpAccess = await resolveMpAccessToken(estabelecimento_id);
+      mpAccessToken = mpAccess.accessToken || null;
+      if (!mpAccessToken) {
+        if (!mpAccess.allowFallback) {
+          return res.status(409).json({
+            error: 'mp_not_connected',
+            message: 'Conecte seu Mercado Pago para receber o sinal.',
+          });
+        }
+        console.warn('[agendamentos][deposit] mp fallback', {
+          estabelecimento_id,
+          reason: mpAccess.reason || 'missing_token',
+        });
+      }
+    }
+

+    const professionalMap = await fetchServiceProfessionalMap(pool, serviceIds);

+    const servicesRequiringProfessional = serviceIds.filter((id) => (professionalMap.get(id)?.size || 0) > 0);

+    const requiresProfessional = servicesRequiringProfessional.length > 0;

+    let profissionalRow = null;

+

+    if (requiresProfessional && profissional_id == null) {

+      return res.status(400).json({ error: 'profissional_obrigatorio', message: 'Escolha um profissional para estes servicos.' });

+    }

+

+    if (profissional_id != null) {

+      const [[profRow]] = await pool.query(

+        'SELECT id, nome, avatar_url, ativo FROM profissionais WHERE id= AND estabelecimento_id=?',

+        [profissional_id, estabelecimento_id]

+      );

+      if (!profRow) {

+        return res.status(400).json({ error: 'profissional_invalido', message: 'Profissional nao encontrado para este estabelecimento.' });

+      }

+      if (!profRow.ativo) {

+        return res.status(400).json({ error: 'profissional_inativo', message: 'Profissional inativo.' });

+      }

+      if (requiresProfessional) {

+        const valid = servicesRequiringProfessional.every((id) => professionalMap.get(id)?.has(profissional_id));

+        if (!valid) {

+          return res.status(400).json({ error: 'profissional_servico', message: 'Profissional nao esta associado a todos os servicos selecionados.' });

+        }

+      }

+      profissionalRow = profRow;

+    }

+

+    const duracaoTotalComBuffer = summary.duracaoTotal + APPOINTMENT_BUFFER_MIN;

+    if (!Number.isFinite(duracaoTotalComBuffer) || duracaoTotalComBuffer <= 0) {

+      return res.status(400).json({ error: 'duracao_invalida', message: 'Duracao do servico invalida.' });

+    }

+    const fimDate = new Date(inicioDate.getTime() + duracaoTotalComBuffer * 60_000);

+    const expediente = await getExpediente({

+      db: conn || pool,

+      estabelecimentoId: estabelecimento_id,

+      dateUtc: inicioDate,

+    });

+    const { startMin, endMin, spansDays } = getLocalRangeMinutes(inicioDate, fimDate);

+    if (!assertDentroExpediente({
+      startMin,
+      endMin,
+      abre: expediente.abre,
+      fecha: expediente.fecha,
+      spansDays,
+      breaks: expediente.breaks,
+    })) {
+      if (conn) {
+        if (txStarted) {
+          await conn.rollback();
+        }
+        conn.release();
+        conn = null;
+      }
+      return res.status(400).json({ error: 'outside_business_hours', message: formatExpedienteMessage(expediente) });
+    }
+    const planConfig = planContext?.config;

+    const limitCheck = await checkMonthlyAppointmentLimit({

+      estabelecimentoId: estabelecimento_id,

+      planConfig,

+      appointmentDate: inicioDate,

+    });

+    if (!limitCheck.ok) {

+      fireAndForget(() => notifyAppointmentLimitReached({

+        estabelecimentoId: estabelecimento_id,

+        limit: limitCheck.limit,

+        total: limitCheck.total,

+        range: limitCheck.range,

+        planConfig,

+      }));

+      return res.status(403).json({

+        error: 'plan_limit_agendamentos',

+        message: formatPlanLimitExceeded(planConfig, 'appointments') || 'Limite de agendamentos atingido para este mês.',

+        details: {

+          limit: limitCheck.limit,

+          total: limitCheck.total,

+          month: limitCheck.range?.label || null,

+        },

+      });

+    }

+

+    // 3) transacao + checagem de conflito

+    conn = await pool.getConnection();

+    await conn.beginTransaction();
+    txStarted = true;
+

+    // Conflito por sobreposicao: a.inicio < novoFim AND a.fim > novoInicio

+    let conflictSql = `
+      SELECT id FROM agendamentos
+      WHERE estabelecimento_id = ?
+        AND status IN ('confirmado','pendente','pendente_pagamento')
+        AND (
+          status = 'confirmado'
+          OR (status = 'pendente' AND (public_confirm_expires_at IS NULL OR public_confirm_expires_at >= NOW()))
+          OR (status = 'pendente_pagamento' AND (deposit_expires_at IS NULL OR deposit_expires_at >= NOW()))
+        )
+        AND (inicio <  AND fim > ?)
+    `;
+    const conflictParams = [estabelecimento_id, fimDate, inicioDate];

+    if (profissional_id != null && requiresProfessional) {

+      conflictSql += ' AND (profissional_id IS NULL OR profissional_id=?)';

+      conflictParams.push(profissional_id);

+    }

+    conflictSql += ' FOR UPDATE';

+

+    const [conf] = await conn.query(conflictSql, conflictParams);

+

+    if (conf.length) {
+      if (txStarted && conn) {
+        await conn.rollback();
+      }
+      conn.release();
+      return res.status(409).json({ error: 'slot_ocupado', message: 'Horário indisponível.' });

+    }

+

+    // 4) insere (status usa default 'confirmado')
+    let appointmentId = null;
+    let depositPaymentId = null;
+    if (depositRequired) {
+      const [r] = await conn.query(
+        `INSERT INTO agendamentos
+          (cliente_id, estabelecimento_id, servico_id, profissional_id, inicio, fim, status, total_centavos,
+           deposit_required, deposit_percent, deposit_centavos, deposit_expires_at)
+         VALUES (?,?,?,?,?,?,'pendente_pagamento',?,?,?,?,?)`,
+        [
+          req.user.id,
+          estabelecimento_id,
+          primaryServiceId,
+          profissional_id || null,
+          inicioDate,
+          fimDate,
+          totalCentavos,
+          1,
+          depositPercent,
+          depositCentavos,
+          depositExpiresAt,
+        ]
+      );
+      appointmentId = r.insertId;
+      const [payIns] = await conn.query(
+        `INSERT INTO appointment_payments
+          (agendamento_id, estabelecimento_id, type, status, amount_centavos, percent, expires_at)
+         VALUES (?,?,?,?,?,?,?)`,
+        [
+          appointmentId,
+          estabelecimento_id,
+          'deposit',
+          'pending',
+          depositCentavos,
+          depositPercent,
+          depositExpiresAt,
+        ]
+      );
+      depositPaymentId = payIns.insertId;
+    } else {
+      const [r] = await conn.query(
+        'INSERT INTO agendamentos (cliente_id, estabelecimento_id, servico_id, profissional_id, inicio, fim, total_centavos) VALUES (?,?,?,?,?,?,?)',
+        [req.user.id, estabelecimento_id, primaryServiceId, profissional_id || null, inicioDate, fimDate, totalCentavos]
+      );
+      appointmentId = r.insertId;
+    }
+    const itemValues = serviceItems.map((item, idx) => ([
+      appointmentId,
+      item.id,
+      idx + 1,
+      Math.max(0, Math.round(item.duracao_min || 0)),
+      Math.max(0, Math.round(item.preco_centavos || 0)),
+    ]));
+    if (itemValues.length) {

+      const placeholders = itemValues.map(() => '(?,?,?,?,?)').join(',');

+      await conn.query(

+        `INSERT INTO agendamento_itens (agendamento_id, servico_id, ordem, duracao_min, preco_snapshot) VALUES ${placeholders}`,

+        itemValues.flat()

+      );

+    }

+

+    // 5) le dados consistentes ainda na transacao

+    const [[novo]] = await conn.query('SELECT * FROM agendamentos WHERE id=?', [appointmentId]);
+    const [[cli]]  = await conn.query('SELECT email, telefone, nome FROM usuarios WHERE id=?', [req.user.id]);

+    const [[est]]  = await conn.query('SELECT email, telefone, nome, notify_email_estab, notify_whatsapp_estab FROM usuarios WHERE id=?', [estabelecimento_id]);

+

+    await conn.commit();
+    txStarted = false;
+    conn.release(); conn = null;
+
+    if (depositRequired) {
+      const expiresIso = depositExpiresAt  depositExpiresAt.toISOString() : null;
+      const apiBase = resolveApiBaseUrl();
+      const externalReference = `dep:ag:${novo.id}:pay:${depositPaymentId}:est:${estabelecimento_id}`;
+      const metadata = {
+        agendamento_id: String(novo.id),
+        estabelecimento_id: String(estabelecimento_id),
+        type: 'deposit',
+      };
+        try {
+          const { payment, pix } = await createMercadoPagoPixPayment({
+            amountCents: depositCentavos,
+            description: `Sinal - ${serviceLabel}`,
+            externalReference,
+            metadata,
+            notificationUrl: `${apiBase}/payments/webhook`,
+            payerEmail: cli?.email || null,
+            expiresAt: depositExpiresAt,
+            accessToken: mpAccessToken,
+          });
+        await pool.query(
+          'UPDATE appointment_payments SET provider_payment_id=?, provider_reference=?, raw_payload= WHERE id=?',
+          [String(payment.id), externalReference, safeJson(payment), depositPaymentId]
+        );
+        return res.status(201).json({
+          id: novo.id,
+          agendamentoId: novo.id,
+          status: novo.status,
+          total_centavos: totalCentavos,
+          deposit_required: 1,
+          deposit_percent: depositPercent,
+          deposit_centavos: depositCentavos,
+          deposit_expires_at: expiresIso,
+          paymentId: depositPaymentId,
+          expiresAt: expiresIso,
+          pix_qr: pix?.qr_code_base64 || null,
+          pix_qr_raw: pix?.qr_code || null,
+          pix_copia_cola: pix?.copia_e_cola || pix?.qr_code || null,
+          pix_ticket_url: pix?.ticket_url || null,
+          amount_centavos: depositCentavos,
+          pix,
+        });
+      } catch (err) {
+        console.error('[agendamentos][deposit] erro ao criar PIX:', err?.message || err);
+        const payload = safeJson({ error: err?.message || String(err) });
+        await pool.query(
+          'UPDATE appointment_payments SET status=?, raw_payload= WHERE id=?',
+          ['failed', payload, depositPaymentId]
+        );
+        await pool.query(
+          "UPDATE agendamentos SET status='cancelado', deposit_expires_at=NOW() WHERE id= AND status='pendente_pagamento'",
+          [novo.id]
+        );
+        return res.status(502).json({
+          error: 'payment_create_failed',
+          message: 'Nao foi possivel gerar o PIX do sinal. Tente novamente.',
+        });
+      }
+    }
+
+    // 6) notificacao "best-effort" (NUNCA bloqueia a resposta)
+    const inicioISO = new Date(novo.inicio).toISOString();

+    const inicioBR  = brDateTime(inicioISO);

+    const hora      = brTime(inicioISO);

+    const data      = brDate(inicioISO);

+

+    const telCli = toDigits(cli?.telefone);

+    const telEst = toDigits(est?.telefone);

+    const canEmailEst = boolPref(est?.notify_email_estab, true);

+    const canWhatsappEst = boolPref(est?.notify_whatsapp_estab, true);

+    const blockEstabNotifications = estabNotificationsDisabled();

+    const blockClientWhatsapp = clientWhatsappDisabled();

+    const blockWhatsappImmediate = whatsappImmediateDisabled();

+    const blockWhatsappConfirmation = whatsappConfirmationDisabled();

+    const estNome = est?.nome || '';

+    const estNomeFriendly = estNome || 'nosso estabelecimento';

+    const profNome = profissionalRow?.nome || '';

+    const profLabel = profNome  ` com ${profNome}` : '';

+    const appointmentLink = `${FRONTEND_BASE}/cliente?agendamento=${novo.id}`;

+    const appointmentLinkHtml = `<p><a href="${appointmentLink}">Ver agendamento</a></p>`;

+

+    // (a) Emails (background)

+    fireAndForget(async () => {

+      if (cli?.email) {

+        await notifyEmail(

+          cli.email,

+          'Agendamento confirmado',

+          `<p>Olá, <b>${cli?.nome  'cliente'}</b>! Seu agendamento de <b>${serviceLabel}</b>${profLabel  ` com <b>${profNome}</b>` : ''} foi confirmado para <b>${inicioBR}</b>.</p>${appointmentLinkHtml}`

+        );

+      }

+      if (!blockEstabNotifications && est?.email && canEmailEst) {

+        await notifyEmail(

+          est.email,

+          'Novo agendamento recebido',

+          `<p>Você recebeu um novo agendamento de <b>${serviceLabel}</b>${profLabel  ` com <b>${profNome}</b>` : ''} em <b>${inicioBR}</b> para o cliente <b>${cli?.nome  ''}</b>.</p>`

+        );

+      }

+    });

+

+    // (b) WhatsApp imediato

+    fireAndForget(async () => {

+      if (blockWhatsappImmediate || blockWhatsappConfirmation) return; // WhatsApp imediato desativado via env ou confirmacao desativada

+      const paramMode = String(process.env.WA_TEMPLATE_PARAM_MODE || 'single').toLowerCase();

+      const tplName = process.env.WA_TEMPLATE_NAME_CONFIRM || process.env.WA_TEMPLATE_NAME || 'confirmacao_agendamento_v2';

+      const tplLang = process.env.WA_TEMPLATE_LANG || 'pt_BR';

+      const estNomeLabel = estNome || '';

+      const isConfirmV2 = isConfirmacaoAgendamentoV2(tplName);

+      const tplParams = isConfirmV2

+         buildConfirmacaoAgendamentoV2Components({

+            serviceLabel,

+            dataHoraLabel: inicioBR,

+            estabelecimentoNome: estNomeLabel,

+          })

+        : [serviceLabel, inicioBR, estNomeLabel];

+      const waMsg = `o. - Novo agendamento registrado: ${serviceLabel}${profNome  ' / ' + profNome : ''} em ${inicioBR} ?" ${estNomeLabel}. ?" Obrigado!`;

+      const fallbackBodyParams = isConfirmV2  tplParams : [waMsg];

+      if (!blockClientWhatsapp && telCli) {

+        if (/^triple|3$/.test(paramMode)) {

+          await sendAppointmentWhatsApp({

+            estabelecimentoId: estabelecimento_id,

+            agendamentoId: novo.id,

+            to: telCli,

+            kind: 'confirm_cli',

+            template: { name: tplName, lang: tplLang, bodyParams: tplParams },

+          });

+        } else {

+          await sendAppointmentWhatsApp({

+            estabelecimentoId: estabelecimento_id,

+            agendamentoId: novo.id,

+            to: telCli,

+            kind: 'confirm_cli',

+            message: waMsg,

+            template: { name: tplName, lang: tplLang, bodyParams: fallbackBodyParams },

+          });

+        }

+      }

+      if (!blockEstabNotifications && canWhatsappEst && telEst && telEst !== telCli) {

+        if (/^triple|3$/.test(paramMode)) {

+          await sendAppointmentWhatsApp({

+            estabelecimentoId: estabelecimento_id,

+            agendamentoId: novo.id,

+            to: telEst,

+            kind: 'confirm_est',

+            template: { name: tplName, lang: tplLang, bodyParams: tplParams },

+          });

+        } else {

+          await sendAppointmentWhatsApp({

+            estabelecimentoId: estabelecimento_id,

+            agendamentoId: novo.id,

+            to: telEst,

+            kind: 'confirm_est',

+            message: waMsg,

+            template: { name: tplName, lang: tplLang, bodyParams: fallbackBodyParams },

+          });

+        }

+      }

+    });

+

+    // (c) Lembretes de 8h: agora gerenciados por um worker em background que reprocessa mesmo apos restart

+

+    // 7) resposta (NUNCA depende das notificacoes)

+    return res.status(201).json({

+      id: novo.id,

+      cliente_id: novo.cliente_id,

+      estabelecimento_id: novo.estabelecimento_id,

+      servico_id: novo.servico_id,

+      servico_ids: summary.serviceIds,

+      servico_nome: serviceLabel,

+      servicos: serviceItems.map((item, idx) => {

+        const precoCentavosSnapshot = Math.max(0, Math.round(item.preco_centavos || 0));

+        return {

+          id: item.id,

+          nome: item.nome,

+          duracao_min: item.duracao_min,

+          preco_centavos_snapshot: precoCentavosSnapshot,

+          preco_snapshot: precoCentavosSnapshot,

+          ordem: idx + 1,

+        };

+      }),

+      buffer_min: APPOINTMENT_BUFFER_MIN,
+      duracao_total: summary.duracaoTotal,
+      duracao_total_com_buffer: duracaoTotalComBuffer,
+      preco_total: summary.precoTotal,
+      total_centavos: totalCentavos,
+      profissional_id: novo.profissional_id,
+      profissional_nome: profissionalRow?.nome || null,

+      profissional_avatar_url: profissionalRow?.avatar_url || null,

+      inicio: novo.inicio,

+      fim: novo.fim,

+      status: novo.status

+    });

+

+  } catch (e) {

+    try { if (txStarted && conn) await conn.rollback(); } catch {}
+    if (conn) { try { conn.release(); } catch {} }

+    console.error('[agendamentos][POST] erro:', e);

+    // Se for erro de chave/unique/conflito que porventura escapou:

+    const msg = String(e?.message || '');

+    if (/duplicate|unique|constraint/i.test(msg)) {

+      return res.status(409).json({ error: 'slot_ocupado', message: 'Horário indisponível.' });

+    }

+    return res.status(500).json({ error: 'server_error' });

+  }

+});

+

+

+

+// Criar agendamento (estabelecimento)

+router.post('/estabelecimento', authRequired, isEstabelecimento, async (req, res) => {
+  let conn;
+  let txStarted = false;
+  try {

+    const {

+      estabelecimento_id: estabelecimentoIdRaw,

+      inicio,

+      nome,

+      email,

+      telefone,

+      profissional_id: profissionalIdRaw,

+      profissionalId,

+      cep,

+      endereco,

+      numero,

+      complemento,

+      bairro,

+      cidade,

+      estado,

+      data_nascimento,

+      dataNascimento,

+    } = req.body || {};

+    const serviceIds = extractServiceIds(req.body || {});

+

+    const estabelecimento_id = req.user?.id;

+    if (!estabelecimento_id) {

+      return res.status(403).json({ error: 'forbidden', message: 'Estabelecimento invalido.' });

+    }

+    if (estabelecimentoIdRaw && Number(estabelecimentoIdRaw) !== Number(estabelecimento_id)) {

+      return res.status(403).json({ error: 'forbidden', message: 'Estabelecimento invalido.' });

+    }

+

+    const professionalCandidate = profissionalIdRaw != null  profissionalIdRaw : profissionalId;

     const profissional_id = professionalCandidate == null ? null : Number(professionalCandidate);
-    if (profissional_id !== null && !Number.isFinite(profissional_id)) {
-      return res.status(400).json({ error: 'profissional_invalido', message: 'Profissional invalido.' });
-    }
-
-    if (!serviceIds.length || !inicio || !nome || !email || !telefone) {
-      return res.status(400).json({
-        error: 'invalid_payload',
-        message: 'Campos obrigatorios: servico_ids, inicio, nome, email, telefone.'
-      });
-    }
-
-    const cepDigits = (cep ? String(cep) : '').replace(/[^0-9]/g, '').slice(0, 8);
-    const enderecoTrim = endereco ? String(endereco).trim() : '';
-    const numeroTrim = numero ? String(numero).trim() : '';
-    const complementoTrim = complemento ? String(complemento).trim() : '';
-    const bairroTrim = bairro ? String(bairro).trim() : '';
-    const cidadeTrim = cidade ? String(cidade).trim() : '';
-    const estadoTrim = estado ? String(estado).trim().toUpperCase() : '';
-    const dataNascimentoRaw = data_nascimento ?? dataNascimento;
-    const dataNascimentoValue = normalizeBirthdate(dataNascimentoRaw);
-    if (dataNascimentoRaw && String(dataNascimentoRaw).trim() && !dataNascimentoValue) {
-      return res.status(400).json({ error: 'data_nascimento_invalida', message: 'Informe uma data de nascimento valida.' });
-    }
-    if (cepDigits && cepDigits.length !== 8) {
-      return res.status(400).json({ error: 'cep_invalido', message: 'Informe um CEP valido com 8 digitos.' });
-    }
-    if (estadoTrim && !/^[A-Z]{2}$/.test(estadoTrim)) {
-      return res.status(400).json({ error: 'estado_invalido', message: 'Informe a UF com 2 letras.' });
-    }
-
-    const inicioDate = new Date(inicio);
-    if (Number.isNaN(inicioDate.getTime())) {
-      return res.status(400).json({ error: 'invalid_date', message: 'Formato de data/hora invalido.' });
-    }
-    if (inicioDate.getTime() <= Date.now()) {
-      return res.status(400).json({ error: 'past_datetime', message: 'Não é possível agendar no passado.' });
-    }
-
-    const planContext = await getPlanContext(estabelecimento_id);
-    if (!planContext) {
-      return res.status(404).json({ error: 'estabelecimento_inexistente' });
-    }
-    if (isDelinquentStatus(planContext.status)) {
-      return res.status(403).json({ error: 'plan_delinquent', message: 'Este estabelecimento esta com o plano em atraso. Agendamentos temporariamente suspensos.' });
-    }
-
-    const { items: serviceItems, missing } = await fetchServicesForAppointment(pool, estabelecimento_id, serviceIds);
-    if (missing.length) return res.status(400).json({ error: 'servico_invalido' });
-    if (serviceItems.some((item) => !Number.isFinite(item.duracao_min) || item.duracao_min <= 0)) {
-      return res.status(400).json({ error: 'duracao_invalida' });
-    }
-    const summary = summarizeServices(serviceItems);
-    const primaryServiceId = summary.serviceIds[0] || serviceIds[0];
-    const serviceLabel = summary.serviceLabel || serviceItems[0]?.nome || 'servico';
-
-    const professionalMap = await fetchServiceProfessionalMap(pool, serviceIds);
-    const servicesRequiringProfessional = serviceIds.filter((id) => (professionalMap.get(id)?.size || 0) > 0);
-    const requiresProfessional = servicesRequiringProfessional.length > 0;
-    let profissionalRow = null;
-
-    if (requiresProfessional && profissional_id == null) {
-      return res.status(400).json({ error: 'profissional_obrigatorio', message: 'Escolha um profissional para estes servicos.' });
-    }
-
-    if (profissional_id != null) {
-      const [[profRow]] = await pool.query(
-        'SELECT id, nome, avatar_url, ativo FROM profissionais WHERE id=? AND estabelecimento_id=?',
-        [profissional_id, estabelecimento_id]
-      );
-      if (!profRow) {
-        return res.status(400).json({ error: 'profissional_invalido', message: 'Profissional nao encontrado para este estabelecimento.' });
-      }
-      if (!profRow.ativo) {
-        return res.status(400).json({ error: 'profissional_inativo', message: 'Profissional inativo.' });
-      }
-      if (requiresProfessional) {
-        const valid = servicesRequiringProfessional.every((id) => professionalMap.get(id)?.has(profissional_id));
-        if (!valid) {
-          return res.status(400).json({ error: 'profissional_servico', message: 'Profissional nao esta associado a todos os servicos selecionados.' });
-        }
-      }
-      profissionalRow = profRow;
-    }
-
-    const duracaoTotalComBuffer = summary.duracaoTotal + APPOINTMENT_BUFFER_MIN;
-    if (!Number.isFinite(duracaoTotalComBuffer) || duracaoTotalComBuffer <= 0) return res.status(400).json({ error: 'duracao_invalida' });
-    const fimDate = new Date(inicioDate.getTime() + duracaoTotalComBuffer * 60_000);
-    const expediente = await getExpediente({
-      db: conn || pool,
-      estabelecimentoId: estabelecimento_id,
-      dateUtc: inicioDate,
-    });
-    const { startMin, endMin, spansDays } = getLocalRangeMinutes(inicioDate, fimDate);
-    if (!assertDentroExpediente({
-      startMin,
-      endMin,
-      abre: expediente.abre,
-      fecha: expediente.fecha,
-      spansDays,
-      breaks: expediente.breaks,
-    })) {
-      if (conn) {
-        if (txStarted) {
-          await conn.rollback();
-        }
-        conn.release();
-        conn = null;
-      }
-      return res.status(400).json({ error: 'outside_business_hours', message: formatExpedienteMessage(expediente) });
-    }
-    const planConfig = planContext?.config;
-    const limitCheck = await checkMonthlyAppointmentLimit({
-      estabelecimentoId: estabelecimento_id,
-      planConfig,
-      appointmentDate: inicioDate,
-    });
-    if (!limitCheck.ok) {
-      fireAndForget(() => notifyAppointmentLimitReached({
-        estabelecimentoId: estabelecimento_id,
-        limit: limitCheck.limit,
-        total: limitCheck.total,
-        range: limitCheck.range,
-        planConfig,
-      }));
-      return res.status(403).json({
-        error: 'plan_limit_agendamentos',
-        message: formatPlanLimitExceeded(planConfig, 'appointments') || 'Limite de agendamentos atingido para este mes.',
-        details: {
-          limit: limitCheck.limit,
-          total: limitCheck.total,
-          month: limitCheck.range?.label || null,
-        },
-      });
-    }
-
-    const emailNorm = String(email).trim().toLowerCase();
-    const telDigits = toDigits(telefone);
-    const telNorm = normalizePhoneBR(telefone);
-
-    let userId = null;
-    let userByEmail = null;
-    let userByPhone = null;
-    {
-      const [urows] = await pool.query(
-        'SELECT id, nome, email, telefone FROM usuarios WHERE LOWER(email)=? LIMIT 1',
-        [emailNorm]
-      );
-      if (urows.length) userByEmail = urows[0];
-    }
-    if (telNorm || telDigits) {
-      const candidates = [];
-      if (telNorm) candidates.push(telNorm);
-      if (telDigits && telDigits !== telNorm) candidates.push(telDigits);
-      for (const candidate of candidates) {
-        const [urows] = await pool.query(
-          'SELECT id, nome, email, telefone FROM usuarios WHERE telefone=? LIMIT 1',
-          [candidate]
-        );
-        if (urows.length) {
-          userByPhone = urows[0];
-          break;
-        }
-      }
-    }
-    if (userByEmail && userByPhone && userByEmail.id !== userByPhone.id) {
-      return res.status(409).json({
-        error: 'cliente_conflito',
-        message: 'Ja existe cliente com este email ou telefone. Revise os dados antes de continuar.',
-      });
-    }
-    const existingUser = userByEmail || userByPhone;
-    if (existingUser) {
+    if (profissional_id !== null && !Number.isFinite(profissional_id)) {

+      return res.status(400).json({ error: 'profissional_invalido', message: 'Profissional invalido.' });

+    }

+

+    if (!serviceIds.length || !inicio || !nome || !email || !telefone) {

+      return res.status(400).json({

+        error: 'invalid_payload',

+        message: 'Campos obrigatorios: servico_ids, inicio, nome, email, telefone.'

+      });

+    }

+

+    const cepDigits = (cep == null ? '' : String(cep))
+      .replace(/[^0-9]/g, '')
+      .slice(0, 8);
+    const enderecoTrim = endereco == null ? '' : String(endereco).trim();
+    const numeroTrim = numero == null ? '' : String(numero).trim();
+    const complementoTrim = complemento == null ? '' : String(complemento).trim();
+    const bairroTrim = bairro == null ? '' : String(bairro).trim();
+    const cidadeTrim = cidade == null ? '' : String(cidade).trim();
+    const estadoTrim = estado == null ? '' : String(estado).trim().toUpperCase();
+    const dataNascimentoRaw = data_nascimento  dataNascimento;

+    const dataNascimentoValue = normalizeBirthdate(dataNascimentoRaw);

+    if (dataNascimentoRaw && String(dataNascimentoRaw).trim() && !dataNascimentoValue) {

+      return res.status(400).json({ error: 'data_nascimento_invalida', message: 'Informe uma data de nascimento valida.' });

+    }

+    if (cepDigits && cepDigits.length !== 8) {

+      return res.status(400).json({ error: 'cep_invalido', message: 'Informe um CEP valido com 8 digitos.' });

+    }

+    if (estadoTrim && !/^[A-Z]{2}$/.test(estadoTrim)) {

+      return res.status(400).json({ error: 'estado_invalido', message: 'Informe a UF com 2 letras.' });

+    }

+

+    const inicioDate = new Date(inicio);

+    if (Number.isNaN(inicioDate.getTime())) {

+      return res.status(400).json({ error: 'invalid_date', message: 'Formato de data/hora invalido.' });

+    }

+    if (inicioDate.getTime() <= Date.now()) {

+      return res.status(400).json({ error: 'past_datetime', message: 'Não é possível agendar no passado.' });

+    }

+

+    const planContext = await getPlanContext(estabelecimento_id);

+    if (!planContext) {

+      return res.status(404).json({ error: 'estabelecimento_inexistente' });

+    }

+    if (isDelinquentStatus(planContext.status)) {

+      return res.status(403).json({ error: 'plan_delinquent', message: 'Este estabelecimento esta com o plano em atraso. Agendamentos temporariamente suspensos.' });

+    }

+

+    const { items: serviceItems, missing } = await fetchServicesForAppointment(pool, estabelecimento_id, serviceIds);

+    if (missing.length) return res.status(400).json({ error: 'servico_invalido' });

+    if (serviceItems.some((item) => !Number.isFinite(item.duracao_min) || item.duracao_min <= 0)) {

+      return res.status(400).json({ error: 'duracao_invalida' });

+    }

+    const summary = summarizeServices(serviceItems);

+    const primaryServiceId = summary.serviceIds[0] || serviceIds[0];

+    const serviceLabel = summary.serviceLabel || serviceItems[0]?.nome || 'servico';

+

+    const professionalMap = await fetchServiceProfessionalMap(pool, serviceIds);

+    const servicesRequiringProfessional = serviceIds.filter((id) => (professionalMap.get(id)?.size || 0) > 0);

+    const requiresProfessional = servicesRequiringProfessional.length > 0;

+    let profissionalRow = null;

+

+    if (requiresProfessional && profissional_id == null) {

+      return res.status(400).json({ error: 'profissional_obrigatorio', message: 'Escolha um profissional para estes servicos.' });

+    }

+

+    if (profissional_id != null) {

+      const [[profRow]] = await pool.query(

+        'SELECT id, nome, avatar_url, ativo FROM profissionais WHERE id= AND estabelecimento_id=?',

+        [profissional_id, estabelecimento_id]

+      );

+      if (!profRow) {

+        return res.status(400).json({ error: 'profissional_invalido', message: 'Profissional nao encontrado para este estabelecimento.' });

+      }

+      if (!profRow.ativo) {

+        return res.status(400).json({ error: 'profissional_inativo', message: 'Profissional inativo.' });

+      }

+      if (requiresProfessional) {

+        const valid = servicesRequiringProfessional.every((id) => professionalMap.get(id)?.has(profissional_id));

+        if (!valid) {

+          return res.status(400).json({ error: 'profissional_servico', message: 'Profissional nao esta associado a todos os servicos selecionados.' });

+        }

+      }

+      profissionalRow = profRow;

+    }

+

+    const duracaoTotalComBuffer = summary.duracaoTotal + APPOINTMENT_BUFFER_MIN;

+    if (!Number.isFinite(duracaoTotalComBuffer) || duracaoTotalComBuffer <= 0) return res.status(400).json({ error: 'duracao_invalida' });

+    const fimDate = new Date(inicioDate.getTime() + duracaoTotalComBuffer * 60_000);

+    const expediente = await getExpediente({

+      db: conn || pool,

+      estabelecimentoId: estabelecimento_id,

+      dateUtc: inicioDate,

+    });

+    const { startMin, endMin, spansDays } = getLocalRangeMinutes(inicioDate, fimDate);

+    if (!assertDentroExpediente({
+      startMin,
+      endMin,
+      abre: expediente.abre,
+      fecha: expediente.fecha,
+      spansDays,
+      breaks: expediente.breaks,
+    })) {
+      if (conn) {
+        if (txStarted) {
+          await conn.rollback();
+        }
+        conn.release();
+        conn = null;
+      }
+      return res.status(400).json({ error: 'outside_business_hours', message: formatExpedienteMessage(expediente) });
+    }
+    const planConfig = planContext?.config;

+    const limitCheck = await checkMonthlyAppointmentLimit({

+      estabelecimentoId: estabelecimento_id,

+      planConfig,

+      appointmentDate: inicioDate,

+    });

+    if (!limitCheck.ok) {

+      fireAndForget(() => notifyAppointmentLimitReached({

+        estabelecimentoId: estabelecimento_id,

+        limit: limitCheck.limit,

+        total: limitCheck.total,

+        range: limitCheck.range,

+        planConfig,

+      }));

+      return res.status(403).json({

+        error: 'plan_limit_agendamentos',

+        message: formatPlanLimitExceeded(planConfig, 'appointments') || 'Limite de agendamentos atingido para este mes.',

+        details: {

+          limit: limitCheck.limit,

+          total: limitCheck.total,

+          month: limitCheck.range?.label || null,

+        },

+      });

+    }

+

+    const emailNorm = String(email).trim().toLowerCase();

+    const telDigits = toDigits(telefone);

+    const telNorm = normalizePhoneBR(telefone);

+

+    let userId = null;

+    let userByEmail = null;

+    let userByPhone = null;

+    {

+      const [urows] = await pool.query(

+        'SELECT id, nome, email, telefone FROM usuarios WHERE LOWER(email)= LIMIT 1',

+        [emailNorm]

+      );

+      if (urows.length) userByEmail = urows[0];

+    }

+    if (telNorm || telDigits) {

+      const candidates = [];

+      if (telNorm) candidates.push(telNorm);

+      if (telDigits && telDigits !== telNorm) candidates.push(telDigits);

+      for (const candidate of candidates) {

+        const [urows] = await pool.query(

+          'SELECT id, nome, email, telefone FROM usuarios WHERE telefone= LIMIT 1',

+          [candidate]

+        );

+        if (urows.length) {

+          userByPhone = urows[0];

+          break;

+        }

+      }

+    }

+    if (userByEmail && userByPhone && userByEmail.id !== userByPhone.id) {

+      return res.status(409).json({

+        error: 'cliente_conflito',

+        message: 'Ja existe cliente com este email ou telefone. Revise os dados antes de continuar.',

+      });

+    }

+    const existingUser = userByEmail || userByPhone;

+    if (existingUser) {

       const existingEmail = existingUser.email ? String(existingUser.email).trim().toLowerCase() : '';
-      const existingPhone = existingUser.telefone ? normalizePhoneBR(existingUser.telefone) : '';
-      const emailMismatch = existingEmail && emailNorm && existingEmail !== emailNorm;
-      const phoneMismatch = existingPhone && telNorm && existingPhone !== telNorm;
-      if (emailMismatch || phoneMismatch) {
-        return res.status(409).json({
-          error: 'cliente_conflito',
-          message: 'Ja existe cliente com este email ou telefone. Revise os dados antes de continuar.',
-        });
-      }
-      userId = existingUser.id;
-    }
-    if (!userId) {
-      const hash = await bcrypt.hash(Math.random().toString(36), 10);
-      const [r] = await pool.query(
-        "INSERT INTO usuarios (nome, email, telefone, data_nascimento, cep, endereco, numero, complemento, bairro, cidade, estado, senha_hash, tipo) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,'cliente')",
-        [
-          String(nome).slice(0,120),
-          emailNorm,
-          telNorm || null,
-          dataNascimentoValue,
-          cepDigits || null,
-          enderecoTrim || null,
-          numeroTrim || null,
-          complementoTrim || null,
-          bairroTrim || null,
-          cidadeTrim || null,
-          estadoTrim || null,
-          hash,
-        ]
-      );
-      userId = r.insertId;
-    } else {
-      try {
-        const updates = ['nome=COALESCE(nome,?)'];
-        const params = [String(nome).slice(0,120)];
-        if (telNorm) {
-          updates.push('telefone=?');
-          params.push(telNorm);
-        }
-        if (dataNascimentoValue) {
-          updates.push('data_nascimento=COALESCE(data_nascimento,?)');
-          params.push(dataNascimentoValue);
-        }
-        if (cepDigits) {
-          updates.push('cep=COALESCE(cep,?)');
-          params.push(cepDigits);
-        }
-        if (enderecoTrim) {
-          updates.push('endereco=COALESCE(endereco,?)');
-          params.push(enderecoTrim);
-        }
-        if (numeroTrim) {
-          updates.push('numero=COALESCE(numero,?)');
-          params.push(numeroTrim);
-        }
-        if (complementoTrim) {
-          updates.push('complemento=COALESCE(complemento,?)');
-          params.push(complementoTrim);
-        }
-        if (bairroTrim) {
-          updates.push('bairro=COALESCE(bairro,?)');
-          params.push(bairroTrim);
-        }
-        if (cidadeTrim) {
-          updates.push('cidade=COALESCE(cidade,?)');
-          params.push(cidadeTrim);
-        }
-        if (estadoTrim) {
-          updates.push('estado=COALESCE(estado,?)');
-          params.push(estadoTrim);
-        }
-        if (updates.length) {
-          await pool.query(`UPDATE usuarios SET ${updates.join(', ')} WHERE id=?`, [...params, userId]);
-        }
-      } catch {}
-    }
-
-    conn = await pool.getConnection();
-    await conn.beginTransaction();
-    txStarted = true;
-
-    let conflictSql = `SELECT id FROM agendamentos
-       WHERE estabelecimento_id=? AND status IN ('confirmado','pendente')
-         AND (status <> 'pendente' OR public_confirm_expires_at IS NULL OR public_confirm_expires_at >= NOW())
-         AND (inicio < ? AND fim > ?)`;
-    const conflictParams = [estabelecimento_id, fimDate, inicioDate];
-    if (profissional_id != null && requiresProfessional) {
-      conflictSql += ' AND (profissional_id IS NULL OR profissional_id=?)';
-      conflictParams.push(profissional_id);
-    }
-    conflictSql += ' FOR UPDATE';
-    const [conf] = await conn.query(conflictSql, conflictParams);
-    if (conf.length) {
-      if (txStarted && conn) {
-        await conn.rollback();
-      }
-      conn.release();
-      return res.status(409).json({ error: 'slot_ocupado' });
-    }
-
-    const [ins] = await conn.query(
-      'INSERT INTO agendamentos (cliente_id, estabelecimento_id, servico_id, profissional_id, inicio, fim) VALUES (?,?,?,?,?,?)',
-      [userId, estabelecimento_id, primaryServiceId, profissional_id || null, inicioDate, fimDate]
-    );
-    const itemValues = serviceItems.map((item, idx) => ([
-      ins.insertId,
-      item.id,
-      idx + 1,
-      Math.max(0, Math.round(item.duracao_min || 0)),
-      Math.max(0, Math.round(item.preco_centavos || 0)),
-    ]));
-    if (itemValues.length) {
-      const placeholders = itemValues.map(() => '(?,?,?,?,?)').join(',');
-      await conn.query(
-        `INSERT INTO agendamento_itens (agendamento_id, servico_id, ordem, duracao_min, preco_snapshot) VALUES ${placeholders}`,
-        itemValues.flat()
-      );
-    }
-
-    const [[novo]] = await conn.query('SELECT * FROM agendamentos WHERE id=?', [ins.insertId]);
-    const [[cli]] = await conn.query('SELECT email, telefone, nome FROM usuarios WHERE id=?', [userId]);
-    const [[est]] = await conn.query('SELECT email, telefone, nome, notify_email_estab, notify_whatsapp_estab FROM usuarios WHERE id=?', [estabelecimento_id]);
-
-    await conn.commit();
-    txStarted = false;
-    conn.release(); conn = null;
-
-    const inicioISO = new Date(novo.inicio).toISOString();
-    const inicioBR  = brDateTime(inicioISO);
-    const telCli = toDigits(cli?.telefone);
-    const telEst = toDigits(est?.telefone);
-    const canEmailEst = boolPref(est?.notify_email_estab, true);
-    const canWhatsappEst = boolPref(est?.notify_whatsapp_estab, true);
-    const blockEstabNotifications = estabNotificationsDisabled();
-    const blockClientWhatsapp = clientWhatsappDisabled();
-    const blockWhatsappImmediate = whatsappImmediateDisabled();
-    const blockWhatsappConfirmation = whatsappConfirmationDisabled();
-    const estNome = est?.nome || '';
-    const profNome = profissionalRow?.nome || '';
-    const profLabel = profNome ? ` com ${profNome}` : '';
-    const appointmentLink = `${FRONTEND_BASE}/cliente?agendamento=${novo.id}`;
-    const appointmentLinkHtml = `<p><a href="${appointmentLink}">Ver agendamento</a></p>`;
-
-    fireAndForget(async () => {
-      if (cli?.email) {
-        await notifyEmail(
-          cli.email,
-          'Agendamento confirmado',
-          `<p>Olá, <b>${cli?.nome ?? 'cliente'}</b>! Seu agendamento de <b>${serviceLabel}</b>${profLabel ? ` com <b>${profNome}</b>` : ''} foi confirmado para <b>${inicioBR}</b>.</p>${appointmentLinkHtml}`
-        );
-      }
-      if (!blockEstabNotifications && est?.email && canEmailEst) {
-        await notifyEmail(
-          est.email,
-          'Novo agendamento recebido',
-          `<p>Você recebeu um novo agendamento de <b>${serviceLabel}</b>${profLabel ? ` com <b>${profNome}</b>` : ''} em <b>${inicioBR}</b> para o cliente <b>${cli?.nome ?? ''}</b>.</p>`
-        );
-      }
-    });
-
-    fireAndForget(async () => {
-      if (blockWhatsappImmediate || blockWhatsappConfirmation) return;
-      const paramMode = String(process.env.WA_TEMPLATE_PARAM_MODE || 'single').toLowerCase();
-      const tplName = process.env.WA_TEMPLATE_NAME_CONFIRM || process.env.WA_TEMPLATE_NAME || 'confirmacao_agendamento_v2';
-      const tplLang = process.env.WA_TEMPLATE_LANG || 'pt_BR';
-      const estNomeLabel = estNome || '';
-      const isConfirmV2 = isConfirmacaoAgendamentoV2(tplName);
-      const tplParams = isConfirmV2
-        ? buildConfirmacaoAgendamentoV2Components({
-            serviceLabel,
-            dataHoraLabel: inicioBR,
-            estabelecimentoNome: estNomeLabel,
-          })
-        : [serviceLabel, inicioBR, estNomeLabel];
-      const waMsg = `Novo agendamento registrado: ${serviceLabel}${profNome ? ' / ' + profNome : ''} em ${inicioBR} - ${estNomeLabel}.`;
-      const fallbackBodyParams = isConfirmV2 ? tplParams : [waMsg];
-      if (!blockClientWhatsapp && telCli) {
-        if (/^triple|3$/.test(paramMode)) {
-          await sendAppointmentWhatsApp({
-            estabelecimentoId: req.user.id,
-            agendamentoId: novo.id,
-            to: telCli,
-            kind: 'confirm_cli',
-            template: { name: tplName, lang: tplLang, bodyParams: tplParams },
-          });
-        } else {
-          await sendAppointmentWhatsApp({
-            estabelecimentoId: req.user.id,
-            agendamentoId: novo.id,
-            to: telCli,
-            kind: 'confirm_cli',
-            message: waMsg,
-            template: { name: tplName, lang: tplLang, bodyParams: fallbackBodyParams },
-          });
-        }
-      }
-      if (!blockEstabNotifications && canWhatsappEst && telEst && telEst !== telCli) {
-        if (/^triple|3$/.test(paramMode)) {
-          await sendAppointmentWhatsApp({
-            estabelecimentoId: req.user.id,
-            agendamentoId: novo.id,
-            to: telEst,
-            kind: 'confirm_est',
-            template: { name: tplName, lang: tplLang, bodyParams: tplParams },
-          });
-        } else {
-          await sendAppointmentWhatsApp({
-            estabelecimentoId: req.user.id,
-            agendamentoId: novo.id,
-            to: telEst,
-            kind: 'confirm_est',
-            message: waMsg,
-            template: { name: tplName, lang: tplLang, bodyParams: fallbackBodyParams },
-          });
-        }
-      }
-    });
-
-    return res.status(201).json({
-      id: novo.id,
-      cliente_id: novo.cliente_id,
-      estabelecimento_id: novo.estabelecimento_id,
-      servico_id: novo.servico_id,
-      servico_ids: summary.serviceIds,
-      servico_nome: serviceLabel,
-      servicos: serviceItems.map((item, idx) => {
-        const precoCentavosSnapshot = Math.max(0, Math.round(item.preco_centavos || 0));
-        return {
-          id: item.id,
-          nome: item.nome,
-          duracao_min: item.duracao_min,
-          preco_centavos_snapshot: precoCentavosSnapshot,
-          preco_snapshot: precoCentavosSnapshot,
-          ordem: idx + 1,
-        };
-      }),
-      buffer_min: APPOINTMENT_BUFFER_MIN,
-      duracao_total: summary.duracaoTotal,
-      duracao_total_com_buffer: duracaoTotalComBuffer,
-      preco_total: summary.precoTotal,
-      profissional_id: novo.profissional_id,
-      profissional_nome: profissionalRow?.nome || null,
-      profissional_avatar_url: profissionalRow?.avatar_url || null,
-      inicio: novo.inicio,
-      fim: novo.fim,
-      status: novo.status,
-    });
-  } catch (e) {
-    try { if (txStarted && conn) await conn.rollback(); } catch {}
-    if (conn) { try { conn.release(); } catch {} }
-    console.error('[agendamentos][POST][estabelecimento] erro:', e);
-    return res.status(500).json({ error: 'server_error' });
-  }
-});
-/* =================== Reagendamento (estabelecimento) =================== */
-
-// Reagendar (estabelecimento)
-router.put('/:id/reschedule-estab', authRequired, isEstabelecimento, async (req, res) => {
-  let conn;
-  let txStarted = false;
-  try {
-    const { id } = req.params;
-    const estId = req.user.id;
-    const { inicio } = req.body || {};
-
-    if (!inicio) {
-      return res.status(400).json({ error: 'invalid_payload', message: 'Informe inicio (ISO).' });
-    }
-
-    const inicioDate = new Date(inicio);
-    if (Number.isNaN(inicioDate.getTime())) {
-      return res.status(400).json({ error: 'invalid_date', message: 'Formato de data/hora invalido.' });
-    }
-    if (inicioDate.getTime() <= Date.now()) {
-      return res.status(400).json({ error: 'past_datetime', message: 'Não é possível reagendar no passado.' });
-    }
-
-    const planContext = await getPlanContext(estId);
-    if (planContext && isDelinquentStatus(planContext.status)) {
-      return res.status(403).json({
-        error: 'plan_delinquent',
-        message: 'Sua assinatura esta em atraso. Reagendamentos temporariamente suspensos.',
-      });
-    }
-
-    conn = await pool.getConnection();
-    await conn.beginTransaction();
-    txStarted = true;
-
-    const [[ag]] = await conn.query(
-      `SELECT id, cliente_id, servico_id, profissional_id, status, inicio
-         FROM agendamentos
-        WHERE id=? AND estabelecimento_id=?
-        FOR UPDATE`,
-      [id, estId]
-    );
-    if (!ag) {
-      if (txStarted && conn) {
-        await conn.rollback();
-      }
-      conn.release();
-      conn = null;
-      return res.status(404).json({ error: 'not_found', message: 'Agendamento nao encontrado.' });
-    }
-
-    const statusNorm = String(ag.status || '').toLowerCase();
-    if (statusNorm === 'cancelado') {
-      if (txStarted && conn) {
-        await conn.rollback();
-      }
-      conn.release();
-      conn = null;
-      return res.status(409).json({ error: 'already_cancelled', message: 'Agendamento já está cancelado.' });
-    }
-    if (statusNorm === 'concluido') {
-      if (txStarted && conn) {
-        await conn.rollback();
-      }
-      conn.release();
-      conn = null;
-      return res.status(409).json({ error: 'already_done', message: 'Não é possível reagendar um atendimento concluído.' });
-    }
-
-    const startTime = ag?.inicio ? new Date(ag.inicio).getTime() : NaN;
-    if (Number.isFinite(startTime) && startTime <= Date.now()) {
-      if (txStarted && conn) {
-        await conn.rollback();
-      }
-      conn.release();
-      conn = null;
-      return res.status(409).json({
-        error: 'reschedule_forbidden_time_limit',
-        message: 'Reagendamento indisponível: horário já iniciado.',
-      });
-    }
-
-    const itemsByAppointment = await fetchAppointmentItems(conn, [ag.id]);
-    let serviceItems = itemsByAppointment.get(Number(ag.id)) || [];
-    if (!serviceItems.length && ag.servico_id) {
-      const fallback = await fetchServicesForAppointment(conn, estId, [ag.servico_id]);
-      serviceItems = fallback.items || [];
-    }
-    if (!serviceItems.length) {
-      if (txStarted && conn) {
-        await conn.rollback();
-      }
-      conn.release();
-      conn = null;
-      return res.status(400).json({ error: 'servico_invalido', message: 'Servico invalido ou inativo.' });
-    }
-    const summary = summarizeServices(serviceItems);
-    const serviceIds = summary.serviceIds.length ? summary.serviceIds : (ag.servico_id ? [ag.servico_id] : []);
-    const serviceLabel = summary.serviceLabel || serviceItems[0]?.nome || 'servico';
-
-    const duracaoTotalComBuffer = summary.duracaoTotal + APPOINTMENT_BUFFER_MIN;
-    if (!Number.isFinite(duracaoTotalComBuffer) || duracaoTotalComBuffer <= 0) {
-      if (txStarted && conn) {
-        await conn.rollback();
-      }
-      conn.release();
-      conn = null;
-      return res.status(400).json({ error: 'duracao_invalida', message: 'Duracao do servico invalida.' });
-    }
-
-    const fimDate = new Date(inicioDate.getTime() + duracaoTotalComBuffer * 60_000);
-
-    const expediente = await getExpediente({
-      db: conn || pool,
-      estabelecimentoId: estId,
-      dateUtc: inicioDate,
-    });
-    const { startMin, endMin, spansDays } = getLocalRangeMinutes(inicioDate, fimDate);
-    if (!assertDentroExpediente({
-      startMin,
-      endMin,
-      abre: expediente.abre,
-      fecha: expediente.fecha,
-      spansDays,
-      breaks: expediente.breaks,
-    })) {
-      if (conn) {
-        if (txStarted) {
-          await conn.rollback();
-        }
-        conn.release();
-        conn = null;
-      }
-      return res.status(400).json({ error: 'outside_business_hours', message: formatExpedienteMessage(expediente) });
-    }
-    const professionalMap = await fetchServiceProfessionalMap(conn, serviceIds);
-    const servicesRequiringProfessional = serviceIds.filter((id) => (professionalMap.get(id)?.size || 0) > 0);
-    const requiresProfessional = servicesRequiringProfessional.length > 0;
-
-    let conflictSql = `SELECT id FROM agendamentos
-       WHERE estabelecimento_id=? AND status IN ('confirmado','pendente')
-         AND (status <> 'pendente' OR public_confirm_expires_at IS NULL OR public_confirm_expires_at >= NOW())
-         AND id<>?
-         AND (inicio < ? AND fim > ?)`;
-    const conflictParams = [estId, ag.id, fimDate, inicioDate];
-    if (ag.profissional_id != null && requiresProfessional) {
-      conflictSql += ' AND (profissional_id IS NULL OR profissional_id=?)';
-      conflictParams.push(ag.profissional_id);
-    }
-    conflictSql += ' FOR UPDATE';
-    const [conf] = await conn.query(conflictSql, conflictParams);
-    if (conf.length) {
-      if (txStarted && conn) {
-        await conn.rollback();
-      }
-      conn.release();
-      conn = null;
-      return res.status(409).json({ error: 'slot_ocupado', message: 'Horário indisponível.' });
-    }
-
-    const oldInicioIso = ag?.inicio ? new Date(ag.inicio).toISOString() : null;
-
-    await conn.query(
-      'UPDATE agendamentos SET inicio=?, fim=? WHERE id=? AND estabelecimento_id=?',
-      [inicioDate, fimDate, ag.id, estId]
-    );
-
-    const [[updated]] = await conn.query(
-      'SELECT inicio, fim FROM agendamentos WHERE id=?',
-      [ag.id]
-    );
-
-    const [[cli]] = await conn.query(
-      'SELECT nome, email FROM usuarios WHERE id=?',
-      [ag.cliente_id || 0]
-    );
-    const [[est]] = await conn.query(
-      'SELECT nome FROM usuarios WHERE id=?',
-      [estId]
-    );
-
-    await conn.commit();
-    txStarted = false;
-    conn.release();
-    conn = null;
-
-    const updatedInicioIso = updated?.inicio
-      ? new Date(updated.inicio).toISOString()
-      : inicioDate.toISOString();
-    const appointmentLink = `${FRONTEND_BASE}/cliente?agendamento=${ag.id}`;
-    const appointmentLinkHtml = `<p><a href="${appointmentLink}">Ver agendamento</a></p>`;
-    fireAndForget(async () => {
-      if (!cli?.email) return;
-      if (oldInicioIso) {
-        const oldMs = new Date(oldInicioIso).getTime();
-        const newMs = new Date(updatedInicioIso).getTime();
-        if (Number.isFinite(oldMs) && Number.isFinite(newMs) && oldMs === newMs) return;
-      }
-      const clientName = cli?.nome || 'cliente';
-      const serviceName = serviceLabel || 'servico';
-      const estName = est?.nome || 'estabelecimento';
-      const oldLabel = oldInicioIso ? brDateTime(oldInicioIso) : '';
-      const newLabel = brDateTime(updatedInicioIso);
-      const oldLine = oldLabel ? `Horário anterior: <b>${oldLabel}</b>.<br/>` : '';
-      const html = `<p>Olá, <b>${clientName}</b>!</p>` +
-        `<p>Seu agendamento de <b>${serviceName}</b> no ${estName} foi reagendado.</p>` +
-        `<p>${oldLine}Novo horário: <b>${newLabel}</b>.</p>${appointmentLinkHtml}`;
-      await notifyEmail(cli.email, 'Agendamento reagendado', html);
-    });
-
-    return res.json({ id: ag.id, inicio: updated?.inicio || inicioDate, fim: updated?.fim || fimDate });
-  } catch (e) {
-    try { if (txStarted && conn) await conn.rollback(); } catch {}
-    try { if (conn) conn.release(); } catch {}
-    console.error('[agendamentos/reschedule-estab]', e);
-    return res.status(500).json({ error: 'server_error' });
-  }
-});
-
-/* =================== Cancelamento =================== */
-
-// Cancelar (cliente)
-router.put('/:id/cancel', authRequired, isCliente, async (req, res) => {
-  try {
-    const { id } = req.params;
-
-    const cancelLimitMinutes = Number.isFinite(CANCEL_MINUTES_CLIENT) ? CANCEL_MINUTES_CLIENT : 120;
-    const enforceCancelLimit = cancelLimitMinutes > 0;
-    const limitClause = enforceCancelLimit ? ' AND inicio >= DATE_ADD(NOW(), INTERVAL ? MINUTE)' : '';
-    const params = [id, req.user.id];
-    if (enforceCancelLimit) params.push(cancelLimitMinutes);
-
-    const [rows] = await pool.query(
-      `UPDATE agendamentos
-         SET status="cancelado"
-       WHERE id=? AND cliente_id=? AND cliente_confirmou_whatsapp_at IS NULL${limitClause}`,
-      params
-    );
-    if (!rows.affectedRows) {
-      // Pode ser porque já confirmou via WhatsApp ou não existe/pertence a outro cliente.
-      const [[ag]] = await pool.query(
-        `SELECT cliente_confirmou_whatsapp_at,
-                TIMESTAMPDIFF(MINUTE, NOW(), inicio) AS minutes_to_start
-           FROM agendamentos
-          WHERE id=? AND cliente_id=?`,
-        [id, req.user.id]
-      );
-      if (!ag) {
-        return res.status(404).json({ error: 'not_found', message: 'Agendamento não encontrado.' });
-      }
-      if (ag?.cliente_confirmou_whatsapp_at) {
-        return res.status(409).json({
-          error: 'cancel_forbidden_after_confirm',
-          message: 'Agendamento já foi confirmado via WhatsApp. Se precisar de ajuda, entre em contato com o estabelecimento.',
-        });
-      }
-      if (enforceCancelLimit) {
-        const minutesToStart = Number(ag?.minutes_to_start);
-        if (!Number.isFinite(minutesToStart) || minutesToStart < cancelLimitMinutes) {
-          const limitLabel = formatCancelLimitLabel(cancelLimitMinutes);
-          const message = limitLabel
-            ? `Cancelamento permitido apenas até ${limitLabel} antes do horário. \nEntre em contato com o estabelecimento.`
-            : 'Cancelamento não permitido para este horário.';
-          return res.status(409).json({ error: 'cancel_forbidden_time_limit', message });
-        }
-      }
-      return res.status(404).json({ error: 'not_found', message: 'Agendamento não encontrado.' });
-    }
-
-    // contatos para notificar (opcional)
-    const [[a]]   = await pool.query('SELECT estabelecimento_id, servico_id, profissional_id, inicio FROM agendamentos WHERE id=?', [id]);
-    const itemsByAppointment = await fetchAppointmentItems(pool, [Number(id)]);
-    let serviceItems = itemsByAppointment.get(Number(id)) || [];
-    if (!serviceItems.length && a?.servico_id) {
-      const fallback = await fetchServicesForAppointment(pool, a?.estabelecimento_id || 0, [a.servico_id]);
-      serviceItems = fallback.items || [];
-    }
-    const summary = summarizeServices(serviceItems);
-    const [[cli]] = await pool.query('SELECT nome, telefone FROM usuarios WHERE id=?', [req.user.id]);
-    const [[est]] = await pool.query('SELECT nome, email, telefone, notify_email_estab, notify_whatsapp_estab FROM usuarios WHERE id=?', [a?.estabelecimento_id || 0]);
-    const [[pro]] = await pool.query('SELECT nome FROM profissionais WHERE id=?', [a?.profissional_id || 0]);
-
-    const inicioBR = a?.inicio ? brDateTime(new Date(a.inicio).toISOString()) : '';
-
-    const telCli = toDigits(cli?.telefone);
-    const telEst = toDigits(est?.telefone);
-    const blockEstabNotifications = estabNotificationsDisabled();
-    const blockClientWhatsapp = clientWhatsappDisabled();
-    const blockWhatsappImmediate = whatsappImmediateDisabled();
-    const canEmailEst = boolPref(est?.notify_email_estab, true);
-    const canWhatsappEst = boolPref(est?.notify_whatsapp_estab, true);
-    const estNome = est?.nome || '';
-    const serviceName = summary.serviceLabel || '';
-    const clientName = cli?.nome || 'cliente';
-    const profName = pro?.nome || '';
-    const profLabel = profName ? ` com ${profName}` : '';
-    const whenLabel = inicioBR || '';
-    const cancelText = `[Cancelamento] ${clientName} cancelou ${serviceName || 'o atendimento'}${profLabel} que estava marcado para ${whenLabel}.`;
-
-    // Notificar estabelecimento (email/WhatsApp)
-    fireAndForget(async () => {
-      if (blockEstabNotifications) return;
-
-      if (canEmailEst && est?.email) {
-        try {
-          await notifyEmail(
-            est.email,
-            'Cancelamento de agendamento',
-            `<p>O cliente <b>${clientName}</b> cancelou o agendamento de <b>${serviceName}</b>${profLabel} que estava marcado para <b>${whenLabel}</b>.</p>`
-          );
-        } catch (err) {
-          console.warn('[cancel/estab][email]', err?.message || err);
-        }
-      }
-
-      if (canWhatsappEst && telEst && !blockWhatsappImmediate) {
-        const paramMode = String(
-          process.env.WA_TEMPLATE_PARAM_MODE_ESTAB_CANCEL ||
-          process.env.WA_TEMPLATE_PARAM_MODE_CANCEL ||
-          process.env.WA_TEMPLATE_PARAM_MODE ||
-          'quad'
-        ).toLowerCase();
-        const tplName =
-          process.env.WA_TEMPLATE_NAME_ESTAB_CANCEL ||
-          process.env.WA_TEMPLATE_NAME_CANCEL ||
-          process.env.WA_TEMPLATE_NAME ||
-          'confirmacao_agendamento_v2';
-        const tplLang = process.env.WA_TEMPLATE_LANG || 'pt_BR';
-        const params3 = [serviceName, whenLabel, clientName];
-        const params4 = [serviceName, whenLabel, clientName, profName || '-'];
-        const tplParams = /^quad|4|quatro/.test(paramMode) ? params4 : params3;
-        const waResult = await sendAppointmentWhatsApp({
-          estabelecimentoId: a?.estabelecimento_id,
-          agendamentoId: id,
-          to: telEst,
-          kind: 'cancel_est',
-          template: { name: tplName, lang: tplLang, bodyParams: tplParams },
-        });
-        if (waResult && waResult.ok === false) {
-          console.warn('[cancel/estab][wa]', waResult?.detail || waResult?.error || 'send_failed');
-          await sendAppointmentWhatsApp({
-            estabelecimentoId: a?.estabelecimento_id,
-            agendamentoId: id,
-            to: telEst,
-            kind: 'cancel_est',
-            message: cancelText,
-          });
-        }
-      }
-    });
-
-    // WhatsApp: não notificar cliente quando ele mesmo cancela e não notificar estabelecimento (somente email configurado permanece).
-
-    return res.json({ ok: true });
-  } catch (e) {
-    console.error('[agendamentos/cancel]', e);
-    return res.status(500).json({ error: 'server_error' });
-  }
-});
-
-// Cancelar (forcado pelo estabelecimento) - permitido ate a hora do agendamento
-router.put('/:id/cancel-estab', authRequired, isEstabelecimento, async (req, res) => {
-  try {
-    const { id } = req.params;
-    const estId = req.user.id;
-
-    const [[ag]] = await pool.query(
-      `SELECT id,
-              cliente_id,
-              servico_id,
-              inicio,
-              status,
-              TIMESTAMPDIFF(SECOND, NOW(), inicio) AS seconds_to_start
-         FROM agendamentos
-        WHERE id=? AND estabelecimento_id=?`,
-      [id, estId]
-    );
-    if (!ag) {
-      return res.status(404).json({ error: 'not_found', message: 'Agendamento não encontrado.' });
-    }
-
-    const itemsByAppointment = await fetchAppointmentItems(pool, [Number(id)]);
-    let serviceItems = itemsByAppointment.get(Number(id)) || [];
-    if (!serviceItems.length && ag?.servico_id) {
-      const fallback = await fetchServicesForAppointment(pool, estId, [ag.servico_id]);
-      serviceItems = fallback.items || [];
-    }
-    const summary = summarizeServices(serviceItems);
-    const serviceLabel = summary.serviceLabel || serviceItems[0]?.nome || 'servico';
-
-    const statusNorm = String(ag.status || '').toLowerCase();
-    if (statusNorm === 'cancelado') {
-      return res.status(400).json({ error: 'already_cancelled', message: 'Agendamento já está cancelado.' });
-    }
-    if (statusNorm === 'concluido') {
-      return res.status(409).json({ error: 'cancel_forbidden', message: 'Não é possível cancelar um atendimento já concluído.' });
-    }
-    const secondsToStart = Number(ag?.seconds_to_start);
-    const startTime = ag?.inicio ? new Date(ag.inicio).getTime() : NaN;
-    const started =
-      (Number.isFinite(secondsToStart) && secondsToStart <= 0) ||
-      (Number.isFinite(startTime) && startTime <= Date.now());
-    if (started) {
-      return res.status(409).json({
-        error: 'cancel_forbidden_time_limit', 
-        message: 'Cancelamento indisponível: horário já iniciado.',
-      });
-    }
-
-    const [rows] = await pool.query(
-      'UPDATE agendamentos SET status="cancelado" WHERE id=? AND estabelecimento_id=? AND inicio > NOW()',
-      [id, estId]
-    );
-    if (!rows.affectedRows) {
-      if (started) {
-        return res.status(409).json({
-          error: 'cancel_forbidden_time_limit',
-          message: 'Cancelamento indisponível: horário já iniciado.',
-        });
-      }
-      return res.status(404).json({ error: 'not_found', message: 'Agendamento não encontrado.' });
-    }
-
-    const [[cli]] = await pool.query('SELECT nome, telefone FROM usuarios WHERE id=?', [ag?.cliente_id || 0]);
-    const [[est]] = await pool.query(
-      'SELECT nome, telefone, notify_whatsapp_estab FROM usuarios WHERE id=?',
-      [estId]
-    );
-
-    const inicioISO = ag?.inicio ? new Date(ag.inicio).toISOString() : null;
-    const inicioBR = inicioISO ? brDateTime(inicioISO) : '';
-    const hora = inicioISO ? brTime(inicioISO) : '';
-    const data = inicioISO ? brDate(inicioISO) : '';
-    const telCli = toDigits(cli?.telefone);
-    const telEst = toDigits(est?.telefone);
-    const blockEstabNotifications = estabNotificationsDisabled();
-    const blockClientWhatsapp = clientWhatsappDisabled();
-    const blockWhatsappImmediate = whatsappImmediateDisabled();
-    const canWhatsappEstCancel = boolPref(est?.notify_whatsapp_estab, true);
-
-    // WhatsApp: apenas cliente deve ser notificado quando o estabelecimento cancela; não envia para o estabelecimento.
-    fireAndForget(async () => {
-      const paramModeEnv = String(
-        process.env.WA_TEMPLATE_PARAM_MODE_CANCEL ||
-        process.env.WA_TEMPLATE_PARAM_MODE ||
-        'single'
-      ).toLowerCase();
-      const paramCountHint = Number(process.env.WA_TEMPLATE_CANCEL_PARAMS || NaN);
-      const tplName = process.env.WA_TEMPLATE_NAME_CANCEL || process.env.WA_TEMPLATE_NAME || 'confirmacao_agendamento_v2';
-      const tplLang = process.env.WA_TEMPLATE_LANG || 'pt_BR';
-      // Ajuste de ordem: em {{3}} -> estabelecimento; às {{4}} -> hora+data
-      const params3 = [serviceLabel || '', `${hora} de ${data}`.trim(), est?.nome || ''];
-      const params4 = [cli?.nome || 'cliente', serviceLabel || '', est?.nome || '', `${hora} de ${data}`.trim()];
-
-      let paramMode = paramModeEnv;
-      const tplNameLower = String(tplName || '').toLowerCase();
-      if (paramCountHint === 4) {
-        paramMode = 'quad';
-      } else if (paramCountHint === 3) {
-        paramMode = 'triple';
-      } else if (/v2/.test(tplNameLower)) {
-        paramMode = 'quad';
-      }
-
-      const sendParams = async (p) =>
-        sendAppointmentWhatsApp({
-          estabelecimentoId: estId,
-          agendamentoId: id,
-          to: telCli,
-          kind: 'cancel_cli',
-          template: { name: tplName, lang: tplLang, bodyParams: p },
-        });
-
-      if (/^quad|4|quatro/.test(paramMode)) {
-        if (!blockClientWhatsapp && telCli) {
-          const r1 = await sendParams(params4);
-          if (r1 && r1.ok === false) {
-            const r2 = await sendParams(params3);
-            if (r2 && r2.ok === false) {
-              console.warn('[wa/cancel cli est] (fallback 3)', r2?.detail || r2?.error || 'send_failed');
-            }
-          }
-        }
-      } else if (/^triple|3$/.test(paramMode)) {
-        if (!blockClientWhatsapp && telCli) {
-          const r1 = await sendParams(params3);
-          if (r1 && r1.ok === false) {
-            const r2 = await sendParams(params4);
-            if (r2 && r2.ok === false) {
-              console.warn('[wa/cancel cli est] (fallback 4)', r2?.detail || r2?.error || 'send_failed');
-            }
-          }
-        }
-      } else {
-        if (!blockClientWhatsapp && telCli) {
-          await sendAppointmentWhatsApp({
-            estabelecimentoId: estId,
-            agendamentoId: id,
-            to: telCli,
-            kind: 'cancel_cli',
-            message: `Seu agendamento ${id} (${serviceLabel ?? 'servico'}) em ${inicioBR} foi cancelado pelo estabelecimento.`,
-          });
-        }
-      }
-    });
-
-    return res.json({ ok: true });
-  } catch (e) {
-    console.error('[agendamentos/cancel-estab]', e);
-    return res.status(500).json({ error: 'server_error' });
-  }
-});
-
-export default router;
-
+      const existingPhone = existingUser.telefone  normalizePhoneBR(existingUser.telefone) : '';

+      const emailMismatch = existingEmail && emailNorm && existingEmail !== emailNorm;

+      const phoneMismatch = existingPhone && telNorm && existingPhone !== telNorm;

+      if (emailMismatch || phoneMismatch) {

+        return res.status(409).json({

+          error: 'cliente_conflito',

+          message: 'Ja existe cliente com este email ou telefone. Revise os dados antes de continuar.',

+        });

+      }

+      userId = existingUser.id;

+    }

+    if (!userId) {

+      const hash = await bcrypt.hash(Math.random().toString(36), 10);

+      const [r] = await pool.query(

+        "INSERT INTO usuarios (nome, email, telefone, data_nascimento, cep, endereco, numero, complemento, bairro, cidade, estado, senha_hash, tipo) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,'cliente')",

+        [

+          String(nome).slice(0,120),

+          emailNorm,

+          telNorm || null,

+          dataNascimentoValue,

+          cepDigits || null,

+          enderecoTrim || null,

+          numeroTrim || null,

+          complementoTrim || null,

+          bairroTrim || null,

+          cidadeTrim || null,

+          estadoTrim || null,

+          hash,

+        ]

+      );

+      userId = r.insertId;

+    } else {

+      try {

+        const updates = ['nome=COALESCE(nome,?)'];

+        const params = [String(nome).slice(0,120)];

+        if (telNorm) {

+          updates.push('telefone=?');

+          params.push(telNorm);

+        }

+        if (dataNascimentoValue) {

+          updates.push('data_nascimento=COALESCE(data_nascimento,?)');

+          params.push(dataNascimentoValue);

+        }

+        if (cepDigits) {

+          updates.push('cep=COALESCE(cep,?)');

+          params.push(cepDigits);

+        }

+        if (enderecoTrim) {

+          updates.push('endereco=COALESCE(endereco,?)');

+          params.push(enderecoTrim);

+        }

+        if (numeroTrim) {

+          updates.push('numero=COALESCE(numero,?)');

+          params.push(numeroTrim);

+        }

+        if (complementoTrim) {

+          updates.push('complemento=COALESCE(complemento,?)');

+          params.push(complementoTrim);

+        }

+        if (bairroTrim) {

+          updates.push('bairro=COALESCE(bairro,?)');

+          params.push(bairroTrim);

+        }

+        if (cidadeTrim) {

+          updates.push('cidade=COALESCE(cidade,?)');

+          params.push(cidadeTrim);

+        }

+        if (estadoTrim) {

+          updates.push('estado=COALESCE(estado,?)');

+          params.push(estadoTrim);

+        }

+        if (updates.length) {

+          await pool.query(`UPDATE usuarios SET ${updates.join(', ')} WHERE id=?`, [...params, userId]);

+        }

+      } catch {}

+    }

+

+    conn = await pool.getConnection();

+    await conn.beginTransaction();
+    txStarted = true;
+

+    let conflictSql = `SELECT id FROM agendamentos
+       WHERE estabelecimento_id=?
+         AND status IN ('confirmado','pendente','pendente_pagamento')
+         AND (
+           status = 'confirmado'
+           OR (status = 'pendente' AND (public_confirm_expires_at IS NULL OR public_confirm_expires_at >= NOW()))
+           OR (status = 'pendente_pagamento' AND (deposit_expires_at IS NULL OR deposit_expires_at >= NOW()))
+         )
+         AND (inicio <  AND fim > ?)`;
+    const conflictParams = [estabelecimento_id, fimDate, inicioDate];

+    if (profissional_id != null && requiresProfessional) {

+      conflictSql += ' AND (profissional_id IS NULL OR profissional_id=?)';

+      conflictParams.push(profissional_id);

+    }

+    conflictSql += ' FOR UPDATE';

+    const [conf] = await conn.query(conflictSql, conflictParams);

+    if (conf.length) {
+      if (txStarted && conn) {
+        await conn.rollback();
+      }
+      conn.release();
+      return res.status(409).json({ error: 'slot_ocupado' });
+    }
+

+    const [ins] = await conn.query(
+      'INSERT INTO agendamentos (cliente_id, estabelecimento_id, servico_id, profissional_id, inicio, fim, total_centavos) VALUES (?,?,?,?,?,?,?)',
+      [userId, estabelecimento_id, primaryServiceId, profissional_id || null, inicioDate, fimDate, totalCentavos]
+    );
+    const itemValues = serviceItems.map((item, idx) => ([

+      ins.insertId,

+      item.id,

+      idx + 1,

+      Math.max(0, Math.round(item.duracao_min || 0)),

+      Math.max(0, Math.round(item.preco_centavos || 0)),

+    ]));

+    if (itemValues.length) {

+      const placeholders = itemValues.map(() => '(?,?,?,?,?)').join(',');

+      await conn.query(

+        `INSERT INTO agendamento_itens (agendamento_id, servico_id, ordem, duracao_min, preco_snapshot) VALUES ${placeholders}`,

+        itemValues.flat()

+      );

+    }

+

+    const [[novo]] = await conn.query('SELECT * FROM agendamentos WHERE id=?', [ins.insertId]);

+    const [[cli]] = await conn.query('SELECT email, telefone, nome FROM usuarios WHERE id=?', [userId]);

+    const [[est]] = await conn.query('SELECT email, telefone, nome, notify_email_estab, notify_whatsapp_estab FROM usuarios WHERE id=?', [estabelecimento_id]);

+

+    await conn.commit();
+    txStarted = false;
+    conn.release(); conn = null;
+

+    const inicioISO = new Date(novo.inicio).toISOString();

+    const inicioBR  = brDateTime(inicioISO);

+    const telCli = toDigits(cli?.telefone);

+    const telEst = toDigits(est?.telefone);

+    const canEmailEst = boolPref(est?.notify_email_estab, true);

+    const canWhatsappEst = boolPref(est?.notify_whatsapp_estab, true);

+    const blockEstabNotifications = estabNotificationsDisabled();

+    const blockClientWhatsapp = clientWhatsappDisabled();

+    const blockWhatsappImmediate = whatsappImmediateDisabled();

+    const blockWhatsappConfirmation = whatsappConfirmationDisabled();

+    const estNome = est?.nome || '';

+    const profNome = profissionalRow?.nome || '';

+    const profLabel = profNome  ` com ${profNome}` : '';

+    const appointmentLink = `${FRONTEND_BASE}/cliente?agendamento=${novo.id}`;

+    const appointmentLinkHtml = `<p><a href="${appointmentLink}">Ver agendamento</a></p>`;

+

+    fireAndForget(async () => {

+      if (cli?.email) {

+        await notifyEmail(

+          cli.email,

+          'Agendamento confirmado',

+          `<p>Olá, <b>${cli?.nome  'cliente'}</b>! Seu agendamento de <b>${serviceLabel}</b>${profLabel  ` com <b>${profNome}</b>` : ''} foi confirmado para <b>${inicioBR}</b>.</p>${appointmentLinkHtml}`

+        );

+      }

+      if (!blockEstabNotifications && est?.email && canEmailEst) {

+        await notifyEmail(

+          est.email,

+          'Novo agendamento recebido',

+          `<p>Você recebeu um novo agendamento de <b>${serviceLabel}</b>${profLabel  ` com <b>${profNome}</b>` : ''} em <b>${inicioBR}</b> para o cliente <b>${cli?.nome  ''}</b>.</p>`

+        );

+      }

+    });

+

+    fireAndForget(async () => {

+      if (blockWhatsappImmediate || blockWhatsappConfirmation) return;

+      const paramMode = String(process.env.WA_TEMPLATE_PARAM_MODE || 'single').toLowerCase();

+      const tplName = process.env.WA_TEMPLATE_NAME_CONFIRM || process.env.WA_TEMPLATE_NAME || 'confirmacao_agendamento_v2';

+      const tplLang = process.env.WA_TEMPLATE_LANG || 'pt_BR';

+      const estNomeLabel = estNome || '';

+      const isConfirmV2 = isConfirmacaoAgendamentoV2(tplName);

+      const tplParams = isConfirmV2

+         buildConfirmacaoAgendamentoV2Components({

+            serviceLabel,

+            dataHoraLabel: inicioBR,

+            estabelecimentoNome: estNomeLabel,

+          })

+        : [serviceLabel, inicioBR, estNomeLabel];

+      const waMsg = `Novo agendamento registrado: ${serviceLabel}${profNome  ' / ' + profNome : ''} em ${inicioBR} - ${estNomeLabel}.`;

+      const fallbackBodyParams = isConfirmV2  tplParams : [waMsg];

+      if (!blockClientWhatsapp && telCli) {

+        if (/^triple|3$/.test(paramMode)) {

+          await sendAppointmentWhatsApp({

+            estabelecimentoId: req.user.id,

+            agendamentoId: novo.id,

+            to: telCli,

+            kind: 'confirm_cli',

+            template: { name: tplName, lang: tplLang, bodyParams: tplParams },

+          });

+        } else {

+          await sendAppointmentWhatsApp({

+            estabelecimentoId: req.user.id,

+            agendamentoId: novo.id,

+            to: telCli,

+            kind: 'confirm_cli',

+            message: waMsg,

+            template: { name: tplName, lang: tplLang, bodyParams: fallbackBodyParams },

+          });

+        }

+      }

+      if (!blockEstabNotifications && canWhatsappEst && telEst && telEst !== telCli) {

+        if (/^triple|3$/.test(paramMode)) {

+          await sendAppointmentWhatsApp({

+            estabelecimentoId: req.user.id,

+            agendamentoId: novo.id,

+            to: telEst,

+            kind: 'confirm_est',

+            template: { name: tplName, lang: tplLang, bodyParams: tplParams },

+          });

+        } else {

+          await sendAppointmentWhatsApp({

+            estabelecimentoId: req.user.id,

+            agendamentoId: novo.id,

+            to: telEst,

+            kind: 'confirm_est',

+            message: waMsg,

+            template: { name: tplName, lang: tplLang, bodyParams: fallbackBodyParams },

+          });

+        }

+      }

+    });

+

+    return res.status(201).json({

+      id: novo.id,

+      cliente_id: novo.cliente_id,

+      estabelecimento_id: novo.estabelecimento_id,

+      servico_id: novo.servico_id,

+      servico_ids: summary.serviceIds,

+      servico_nome: serviceLabel,

+      servicos: serviceItems.map((item, idx) => {

+        const precoCentavosSnapshot = Math.max(0, Math.round(item.preco_centavos || 0));

+        return {

+          id: item.id,

+          nome: item.nome,

+          duracao_min: item.duracao_min,

+          preco_centavos_snapshot: precoCentavosSnapshot,

+          preco_snapshot: precoCentavosSnapshot,

+          ordem: idx + 1,

+        };

+      }),

+      buffer_min: APPOINTMENT_BUFFER_MIN,
+      duracao_total: summary.duracaoTotal,
+      duracao_total_com_buffer: duracaoTotalComBuffer,
+      preco_total: summary.precoTotal,
+      total_centavos: totalCentavos,
+      profissional_id: novo.profissional_id,
+      profissional_nome: profissionalRow?.nome || null,

+      profissional_avatar_url: profissionalRow?.avatar_url || null,

+      inicio: novo.inicio,

+      fim: novo.fim,

+      status: novo.status,

+    });

+  } catch (e) {

+    try { if (txStarted && conn) await conn.rollback(); } catch {}
+    if (conn) { try { conn.release(); } catch {} }

+    console.error('[agendamentos][POST][estabelecimento] erro:', e);

+    return res.status(500).json({ error: 'server_error' });

+  }

+});

+/* =================== Reagendamento (estabelecimento) =================== */

+

+// Reagendar (estabelecimento)

+router.put('/:id/reschedule-estab', authRequired, isEstabelecimento, async (req, res) => {
+  let conn;
+  let txStarted = false;
+  try {

+    const { id } = req.params;

+    const estId = req.user.id;

+    const { inicio } = req.body || {};

+

+    if (!inicio) {

+      return res.status(400).json({ error: 'invalid_payload', message: 'Informe inicio (ISO).' });

+    }

+

+    const inicioDate = new Date(inicio);

+    if (Number.isNaN(inicioDate.getTime())) {

+      return res.status(400).json({ error: 'invalid_date', message: 'Formato de data/hora invalido.' });

+    }

+    if (inicioDate.getTime() <= Date.now()) {

+      return res.status(400).json({ error: 'past_datetime', message: 'Não é possível reagendar no passado.' });

+    }

+

+    const planContext = await getPlanContext(estId);

+    if (planContext && isDelinquentStatus(planContext.status)) {

+      return res.status(403).json({

+        error: 'plan_delinquent',

+        message: 'Sua assinatura esta em atraso. Reagendamentos temporariamente suspensos.',

+      });

+    }

+

+    conn = await pool.getConnection();

+    await conn.beginTransaction();
+    txStarted = true;
+

+    const [[ag]] = await conn.query(

+      `SELECT id, cliente_id, servico_id, profissional_id, status, inicio

+         FROM agendamentos

+        WHERE id= AND estabelecimento_id=?

+        FOR UPDATE`,

+      [id, estId]

+    );

+    if (!ag) {
+      if (txStarted && conn) {
+        await conn.rollback();
+      }
+      conn.release();
+      conn = null;
+      return res.status(404).json({ error: 'not_found', message: 'Agendamento nao encontrado.' });
+    }
+

+    const statusNorm = String(ag.status || '').toLowerCase();

+    if (statusNorm === 'cancelado') {
+      if (txStarted && conn) {
+        await conn.rollback();
+      }
+      conn.release();
+      conn = null;
+      return res.status(409).json({ error: 'already_cancelled', message: 'Agendamento já está cancelado.' });

+    }

+    if (statusNorm === 'concluido') {
+      if (txStarted && conn) {
+        await conn.rollback();
+      }
+      conn.release();
+      conn = null;
+      return res.status(409).json({ error: 'already_done', message: 'Não é possível reagendar um atendimento concluído.' });

+    }

+

+    const startTime = ag?.inicio  new Date(ag.inicio).getTime() : NaN;

+    if (Number.isFinite(startTime) && startTime <= Date.now()) {
+      if (txStarted && conn) {
+        await conn.rollback();
+      }
+      conn.release();
+      conn = null;
+      return res.status(409).json({

+        error: 'reschedule_forbidden_time_limit',

+        message: 'Reagendamento indisponível: horário já iniciado.',

+      });

+    }

+

+    const itemsByAppointment = await fetchAppointmentItems(conn, [ag.id]);

+    let serviceItems = itemsByAppointment.get(Number(ag.id)) || [];

+    if (!serviceItems.length && ag.servico_id) {

+      const fallback = await fetchServicesForAppointment(conn, estId, [ag.servico_id]);

+      serviceItems = fallback.items || [];

+    }

+    if (!serviceItems.length) {
+      if (txStarted && conn) {
+        await conn.rollback();
+      }
+      conn.release();
+      conn = null;
+      return res.status(400).json({ error: 'servico_invalido', message: 'Servico invalido ou inativo.' });

+    }

+    const summary = summarizeServices(serviceItems);

+    const serviceIds = summary.serviceIds.length  summary.serviceIds : (ag.servico_id  [ag.servico_id] : []);

+    const serviceLabel = summary.serviceLabel || serviceItems[0]?.nome || 'servico';

+

+    const duracaoTotalComBuffer = summary.duracaoTotal + APPOINTMENT_BUFFER_MIN;

+    if (!Number.isFinite(duracaoTotalComBuffer) || duracaoTotalComBuffer <= 0) {
+      if (txStarted && conn) {
+        await conn.rollback();
+      }
+      conn.release();
+      conn = null;
+      return res.status(400).json({ error: 'duracao_invalida', message: 'Duracao do servico invalida.' });

+    }

+

+    const fimDate = new Date(inicioDate.getTime() + duracaoTotalComBuffer * 60_000);

+

+    const expediente = await getExpediente({

+      db: conn || pool,

+      estabelecimentoId: estId,

+      dateUtc: inicioDate,

+    });

+    const { startMin, endMin, spansDays } = getLocalRangeMinutes(inicioDate, fimDate);

+    if (!assertDentroExpediente({
+      startMin,
+      endMin,
+      abre: expediente.abre,
+      fecha: expediente.fecha,
+      spansDays,
+      breaks: expediente.breaks,
+    })) {
+      if (conn) {
+        if (txStarted) {
+          await conn.rollback();
+        }
+        conn.release();
+        conn = null;
+      }
+      return res.status(400).json({ error: 'outside_business_hours', message: formatExpedienteMessage(expediente) });
+    }
+    const professionalMap = await fetchServiceProfessionalMap(conn, serviceIds);

+    const servicesRequiringProfessional = serviceIds.filter((id) => (professionalMap.get(id)?.size || 0) > 0);

+    const requiresProfessional = servicesRequiringProfessional.length > 0;

+

+    let conflictSql = `SELECT id FROM agendamentos
+       WHERE estabelecimento_id= AND status IN ('confirmado','pendente','pendente_pagamento')
+         AND (
+           status = 'confirmado'
+           OR (status = 'pendente' AND (public_confirm_expires_at IS NULL OR public_confirm_expires_at >= NOW()))
+           OR (status = 'pendente_pagamento' AND (deposit_expires_at IS NULL OR deposit_expires_at >= NOW()))
+         )
+         AND id<>?
+         AND (inicio <  AND fim > ?)`;
+    const conflictParams = [estId, ag.id, fimDate, inicioDate];

+    if (ag.profissional_id != null && requiresProfessional) {

+      conflictSql += ' AND (profissional_id IS NULL OR profissional_id=?)';

+      conflictParams.push(ag.profissional_id);

+    }

+    conflictSql += ' FOR UPDATE';

+    const [conf] = await conn.query(conflictSql, conflictParams);

+    if (conf.length) {
+      if (txStarted && conn) {
+        await conn.rollback();
+      }
+      conn.release();
+      conn = null;
+      return res.status(409).json({ error: 'slot_ocupado', message: 'Horário indisponível.' });

+    }

+

+    const oldInicioIso = ag?.inicio  new Date(ag.inicio).toISOString() : null;

+

+    await conn.query(

+      'UPDATE agendamentos SET inicio=?, fim= WHERE id= AND estabelecimento_id=?',

+      [inicioDate, fimDate, ag.id, estId]

+    );

+

+    const [[updated]] = await conn.query(

+      'SELECT inicio, fim FROM agendamentos WHERE id=?',

+      [ag.id]

+    );

+

+    const [[cli]] = await conn.query(

+      'SELECT nome, email FROM usuarios WHERE id=?',

+      [ag.cliente_id || 0]

+    );

+    const [[est]] = await conn.query(

+      'SELECT nome FROM usuarios WHERE id=?',

+      [estId]

+    );

+

+    await conn.commit();
+    txStarted = false;
+    conn.release();
+    conn = null;
+

+    const updatedInicioIso = updated?.inicio

+       new Date(updated.inicio).toISOString()

+      : inicioDate.toISOString();

+    const appointmentLink = `${FRONTEND_BASE}/cliente?agendamento=${ag.id}`;

+    const appointmentLinkHtml = `<p><a href="${appointmentLink}">Ver agendamento</a></p>`;

+    fireAndForget(async () => {

+      if (!cli?.email) return;

+      if (oldInicioIso) {

+        const oldMs = new Date(oldInicioIso).getTime();

+        const newMs = new Date(updatedInicioIso).getTime();

+        if (Number.isFinite(oldMs) && Number.isFinite(newMs) && oldMs === newMs) return;

+      }

+      const clientName = cli?.nome || 'cliente';

+      const serviceName = serviceLabel || 'servico';

+      const estName = est?.nome || 'estabelecimento';

+      const oldLabel = oldInicioIso  brDateTime(oldInicioIso) : '';

+      const newLabel = brDateTime(updatedInicioIso);

+      const oldLine = oldLabel  `Horário anterior: <b>${oldLabel}</b>.<br/>` : '';

+      const html = `<p>Olá, <b>${clientName}</b>!</p>` +

+        `<p>Seu agendamento de <b>${serviceName}</b> no ${estName} foi reagendado.</p>` +

+        `<p>${oldLine}Novo horário: <b>${newLabel}</b>.</p>${appointmentLinkHtml}`;

+      await notifyEmail(cli.email, 'Agendamento reagendado', html);

+    });

+

+    return res.json({ id: ag.id, inicio: updated?.inicio || inicioDate, fim: updated?.fim || fimDate });

+  } catch (e) {

+    try { if (txStarted && conn) await conn.rollback(); } catch {}
+    try { if (conn) conn.release(); } catch {}

+    console.error('[agendamentos/reschedule-estab]', e);

+    return res.status(500).json({ error: 'server_error' });

+  }

+});

+

+/* =================== Cancelamento =================== */

+

+// Cancelar (cliente)

+router.put('/:id/cancel', authRequired, isCliente, async (req, res) => {

+  try {

+    const { id } = req.params;

+

+    const cancelLimitMinutes = Number.isFinite(CANCEL_MINUTES_CLIENT)  CANCEL_MINUTES_CLIENT : 120;

+    const enforceCancelLimit = cancelLimitMinutes > 0;

+    const limitClause = enforceCancelLimit  ' AND inicio >= DATE_ADD(NOW(), INTERVAL  MINUTE)' : '';

+    const params = [id, req.user.id];

+    if (enforceCancelLimit) params.push(cancelLimitMinutes);

+

+    const [rows] = await pool.query(

+      `UPDATE agendamentos

+         SET status="cancelado"

+       WHERE id= AND cliente_id= AND cliente_confirmou_whatsapp_at IS NULL${limitClause}`,

+      params

+    );

+    if (!rows.affectedRows) {

+      // Pode ser porque já confirmou via WhatsApp ou não existe/pertence a outro cliente.

+      const [[ag]] = await pool.query(

+        `SELECT cliente_confirmou_whatsapp_at,

+                TIMESTAMPDIFF(MINUTE, NOW(), inicio) AS minutes_to_start

+           FROM agendamentos

+          WHERE id= AND cliente_id=?`,

+        [id, req.user.id]

+      );

+      if (!ag) {

+        return res.status(404).json({ error: 'not_found', message: 'Agendamento não encontrado.' });

+      }

+      if (ag?.cliente_confirmou_whatsapp_at) {

+        return res.status(409).json({

+          error: 'cancel_forbidden_after_confirm',

+          message: 'Agendamento já foi confirmado via WhatsApp. Se precisar de ajuda, entre em contato com o estabelecimento.',

+        });

+      }

+      if (enforceCancelLimit) {

+        const minutesToStart = Number(ag?.minutes_to_start);

+        if (!Number.isFinite(minutesToStart) || minutesToStart < cancelLimitMinutes) {

+          const limitLabel = formatCancelLimitLabel(cancelLimitMinutes);

+          const message = limitLabel

+             `Cancelamento permitido apenas até ${limitLabel} antes do horário. \nEntre em contato com o estabelecimento.`

+            : 'Cancelamento não permitido para este horário.';

+          return res.status(409).json({ error: 'cancel_forbidden_time_limit', message });

+        }

+      }

+      return res.status(404).json({ error: 'not_found', message: 'Agendamento não encontrado.' });

+    }

+

+    // contatos para notificar (opcional)

+    const [[a]]   = await pool.query('SELECT estabelecimento_id, servico_id, profissional_id, inicio FROM agendamentos WHERE id=?', [id]);

+    const itemsByAppointment = await fetchAppointmentItems(pool, [Number(id)]);

+    let serviceItems = itemsByAppointment.get(Number(id)) || [];

+    if (!serviceItems.length && a?.servico_id) {

+      const fallback = await fetchServicesForAppointment(pool, a?.estabelecimento_id || 0, [a.servico_id]);

+      serviceItems = fallback.items || [];

+    }

+    const summary = summarizeServices(serviceItems);

+    const [[cli]] = await pool.query('SELECT nome, telefone FROM usuarios WHERE id=?', [req.user.id]);

+    const [[est]] = await pool.query('SELECT nome, email, telefone, notify_email_estab, notify_whatsapp_estab FROM usuarios WHERE id=?', [a?.estabelecimento_id || 0]);

+    const [[pro]] = await pool.query('SELECT nome FROM profissionais WHERE id=?', [a?.profissional_id || 0]);

+

+    const inicioBR = a?.inicio  brDateTime(new Date(a.inicio).toISOString()) : '';

+

+    const telCli = toDigits(cli?.telefone);

+    const telEst = toDigits(est?.telefone);

+    const blockEstabNotifications = estabNotificationsDisabled();

+    const blockClientWhatsapp = clientWhatsappDisabled();

+    const blockWhatsappImmediate = whatsappImmediateDisabled();

+    const canEmailEst = boolPref(est?.notify_email_estab, true);

+    const canWhatsappEst = boolPref(est?.notify_whatsapp_estab, true);

+    const estNome = est?.nome || '';

+    const serviceName = summary.serviceLabel || '';

+    const clientName = cli?.nome || 'cliente';

+    const profName = pro?.nome || '';

+    const profLabel = profName  ` com ${profName}` : '';

+    const whenLabel = inicioBR || '';

+    const cancelText = `[Cancelamento] ${clientName} cancelou ${serviceName || 'o atendimento'}${profLabel} que estava marcado para ${whenLabel}.`;

+

+    // Notificar estabelecimento (email/WhatsApp)

+    fireAndForget(async () => {

+      if (blockEstabNotifications) return;

+

+      if (canEmailEst && est?.email) {

+        try {

+          await notifyEmail(

+            est.email,

+            'Cancelamento de agendamento',

+            `<p>O cliente <b>${clientName}</b> cancelou o agendamento de <b>${serviceName}</b>${profLabel} que estava marcado para <b>${whenLabel}</b>.</p>`

+          );

+        } catch (err) {

+          console.warn('[cancel/estab][email]', err?.message || err);

+        }

+      }

+

+      if (canWhatsappEst && telEst && !blockWhatsappImmediate) {

+        const paramMode = String(

+          process.env.WA_TEMPLATE_PARAM_MODE_ESTAB_CANCEL ||

+          process.env.WA_TEMPLATE_PARAM_MODE_CANCEL ||

+          process.env.WA_TEMPLATE_PARAM_MODE ||

+          'quad'

+        ).toLowerCase();

+        const tplName =

+          process.env.WA_TEMPLATE_NAME_ESTAB_CANCEL ||

+          process.env.WA_TEMPLATE_NAME_CANCEL ||

+          process.env.WA_TEMPLATE_NAME ||

+          'confirmacao_agendamento_v2';

+        const tplLang = process.env.WA_TEMPLATE_LANG || 'pt_BR';

+        const params3 = [serviceName, whenLabel, clientName];

+        const params4 = [serviceName, whenLabel, clientName, profName || '-'];

+        const tplParams = /^quad|4|quatro/.test(paramMode)  params4 : params3;

+        const waResult = await sendAppointmentWhatsApp({

+          estabelecimentoId: a?.estabelecimento_id,

+          agendamentoId: id,

+          to: telEst,

+          kind: 'cancel_est',

+          template: { name: tplName, lang: tplLang, bodyParams: tplParams },

+        });

+        if (waResult && waResult.ok === false) {

+          console.warn('[cancel/estab][wa]', waResult?.detail || waResult?.error || 'send_failed');

+          await sendAppointmentWhatsApp({

+            estabelecimentoId: a?.estabelecimento_id,

+            agendamentoId: id,

+            to: telEst,

+            kind: 'cancel_est',

+            message: cancelText,

+          });

+        }

+      }

+    });

+

+    // WhatsApp: não notificar cliente quando ele mesmo cancela e não notificar estabelecimento (somente email configurado permanece).

+

+    return res.json({ ok: true });

+  } catch (e) {

+    console.error('[agendamentos/cancel]', e);

+    return res.status(500).json({ error: 'server_error' });

+  }

+});

+

+// Cancelar (forcado pelo estabelecimento) - permitido ate a hora do agendamento

+router.put('/:id/cancel-estab', authRequired, isEstabelecimento, async (req, res) => {

+  try {

+    const { id } = req.params;

+    const estId = req.user.id;

+

+    const [[ag]] = await pool.query(

+      `SELECT id,

+              cliente_id,

+              servico_id,

+              inicio,

+              status,

+              TIMESTAMPDIFF(SECOND, NOW(), inicio) AS seconds_to_start

+         FROM agendamentos

+        WHERE id= AND estabelecimento_id=?`,

+      [id, estId]

+    );

+    if (!ag) {

+      return res.status(404).json({ error: 'not_found', message: 'Agendamento não encontrado.' });

+    }

+

+    const itemsByAppointment = await fetchAppointmentItems(pool, [Number(id)]);

+    let serviceItems = itemsByAppointment.get(Number(id)) || [];

+    if (!serviceItems.length && ag?.servico_id) {

+      const fallback = await fetchServicesForAppointment(pool, estId, [ag.servico_id]);

+      serviceItems = fallback.items || [];

+    }

+    const summary = summarizeServices(serviceItems);

+    const serviceLabel = summary.serviceLabel || serviceItems[0]?.nome || 'servico';

+

+    const statusNorm = String(ag.status || '').toLowerCase();

+    if (statusNorm === 'cancelado') {

+      return res.status(400).json({ error: 'already_cancelled', message: 'Agendamento já está cancelado.' });

+    }

+    if (statusNorm === 'concluido') {

+      return res.status(409).json({ error: 'cancel_forbidden', message: 'Não é possível cancelar um atendimento já concluído.' });

+    }

+    const secondsToStart = Number(ag?.seconds_to_start);

+    const startTime = ag?.inicio  new Date(ag.inicio).getTime() : NaN;

+    const started =

+      (Number.isFinite(secondsToStart) && secondsToStart <= 0) ||

+      (Number.isFinite(startTime) && startTime <= Date.now());

+    if (started) {

+      return res.status(409).json({

+        error: 'cancel_forbidden_time_limit', 

+        message: 'Cancelamento indisponível: horário já iniciado.',

+      });

+    }

+

+    const [rows] = await pool.query(

+      'UPDATE agendamentos SET status="cancelado" WHERE id= AND estabelecimento_id= AND inicio > NOW()',

+      [id, estId]

+    );

+    if (!rows.affectedRows) {

+      if (started) {

+        return res.status(409).json({

+          error: 'cancel_forbidden_time_limit',

+          message: 'Cancelamento indisponível: horário já iniciado.',

+        });

+      }

+      return res.status(404).json({ error: 'not_found', message: 'Agendamento não encontrado.' });

+    }

+

+    const [[cli]] = await pool.query('SELECT nome, telefone FROM usuarios WHERE id=?', [ag?.cliente_id || 0]);

+    const [[est]] = await pool.query(

+      'SELECT nome, telefone, notify_whatsapp_estab FROM usuarios WHERE id=?',

+      [estId]

+    );

+

+    const inicioISO = ag?.inicio  new Date(ag.inicio).toISOString() : null;

+    const inicioBR = inicioISO  brDateTime(inicioISO) : '';

+    const hora = inicioISO  brTime(inicioISO) : '';

+    const data = inicioISO  brDate(inicioISO) : '';

+    const telCli = toDigits(cli?.telefone);

+    const telEst = toDigits(est?.telefone);

+    const blockEstabNotifications = estabNotificationsDisabled();

+    const blockClientWhatsapp = clientWhatsappDisabled();

+    const blockWhatsappImmediate = whatsappImmediateDisabled();

+    const canWhatsappEstCancel = boolPref(est?.notify_whatsapp_estab, true);

+

+    // WhatsApp: apenas cliente deve ser notificado quando o estabelecimento cancela; não envia para o estabelecimento.

+    fireAndForget(async () => {

+      const paramModeEnv = String(

+        process.env.WA_TEMPLATE_PARAM_MODE_CANCEL ||

+        process.env.WA_TEMPLATE_PARAM_MODE ||

+        'single'

+      ).toLowerCase();

+      const paramCountHint = Number(process.env.WA_TEMPLATE_CANCEL_PARAMS || NaN);

+      const tplName = process.env.WA_TEMPLATE_NAME_CANCEL || process.env.WA_TEMPLATE_NAME || 'confirmacao_agendamento_v2';

+      const tplLang = process.env.WA_TEMPLATE_LANG || 'pt_BR';

+      // Ajuste de ordem: em {{3}} -> estabelecimento; às {{4}} -> hora+data

+      const params3 = [serviceLabel || '', `${hora} de ${data}`.trim(), est?.nome || ''];

+      const params4 = [cli?.nome || 'cliente', serviceLabel || '', est?.nome || '', `${hora} de ${data}`.trim()];

+

+      let paramMode = paramModeEnv;

+      const tplNameLower = String(tplName || '').toLowerCase();

+      if (paramCountHint === 4) {

+        paramMode = 'quad';

+      } else if (paramCountHint === 3) {

+        paramMode = 'triple';

+      } else if (/v2/.test(tplNameLower)) {

+        paramMode = 'quad';

+      }

+

+      const sendParams = async (p) =>

+        sendAppointmentWhatsApp({

+          estabelecimentoId: estId,

+          agendamentoId: id,

+          to: telCli,

+          kind: 'cancel_cli',

+          template: { name: tplName, lang: tplLang, bodyParams: p },

+        });

+

+      if (/^quad|4|quatro/.test(paramMode)) {

+        if (!blockClientWhatsapp && telCli) {

+          const r1 = await sendParams(params4);

+          if (r1 && r1.ok === false) {

+            const r2 = await sendParams(params3);

+            if (r2 && r2.ok === false) {

+              console.warn('[wa/cancel cli est] (fallback 3)', r2?.detail || r2?.error || 'send_failed');

+            }

+          }

+        }

+      } else if (/^triple|3$/.test(paramMode)) {

+        if (!blockClientWhatsapp && telCli) {

+          const r1 = await sendParams(params3);

+          if (r1 && r1.ok === false) {

+            const r2 = await sendParams(params4);

+            if (r2 && r2.ok === false) {

+              console.warn('[wa/cancel cli est] (fallback 4)', r2?.detail || r2?.error || 'send_failed');

+            }

+          }

+        }

+      } else {

+        if (!blockClientWhatsapp && telCli) {

+          await sendAppointmentWhatsApp({

+            estabelecimentoId: estId,

+            agendamentoId: id,

+            to: telCli,

+            kind: 'cancel_cli',

+            message: `Seu agendamento ${id} (${serviceLabel  'servico'}) em ${inicioBR} foi cancelado pelo estabelecimento.`,

+          });

+        }

+      }

+    });

+

+    return res.json({ ok: true });

+  } catch (e) {

+    console.error('[agendamentos/cancel-estab]', e);

+    return res.status(500).json({ error: 'server_error' });

+  }

+});

+

+export default router;

+

diff --git a/backend/src/routes/agendamentos_public.js b/backend/src/routes/agendamentos_public.js
index 42c33e8..62abd26 100644
--- a/backend/src/routes/agendamentos_public.js
+++ b/backend/src/routes/agendamentos_public.js
@@ -1,841 +1,1018 @@
-// backend/src/routes/agendamentos_public.js
-import { Router } from 'express';
-import crypto from 'crypto';
-import { pool } from '../lib/db.js';
-import { assertDentroExpediente, formatExpedienteMessage, getExpediente, getLocalRangeMinutes } from '../lib/expediente.js';
-import { getPlanContext, isDelinquentStatus, formatPlanLimitExceeded } from '../lib/plans.js';
-import bcrypt from 'bcryptjs';
-import { notifyEmail } from '../lib/notifications.js';
-import { sendAppointmentWhatsApp } from '../lib/whatsapp_outbox.js';
-import { buildConfirmacaoAgendamentoV2Components, isConfirmacaoAgendamentoV2 } from '../lib/whatsapp_templates.js';
-import { estabNotificationsDisabled } from '../lib/estab_notifications.js';
-import { clientWhatsappDisabled, whatsappImmediateDisabled, whatsappConfirmationDisabled } from '../lib/client_notifications.js';
-import jwt from 'jsonwebtoken';
-import { checkMonthlyAppointmentLimit, notifyAppointmentLimitReached } from '../lib/appointment_limits.js';
-
-const router = Router();
-const TZ = 'America/Sao_Paulo';
-const FRONTEND_BASE = String(process.env.FRONTEND_BASE_URL || process.env.APP_URL || 'http://localhost:3001').replace(/\/$/, '');
-const APPOINTMENT_BUFFER_MIN = (() => {
-  const raw = process.env.AGENDAMENTO_BUFFER_MIN ?? process.env.APPOINTMENT_BUFFER_MIN;
-  if (raw === undefined || raw === null || String(raw).trim() === '') return 0;
-  const parsed = Number(raw);
-  return Number.isFinite(parsed) && parsed > 0 ? Math.round(parsed) : 0;
-})();
-
-const normalizeServiceIds = (value) => {
-  const ids = [];
-  const pushId = (entry) => {
-    const num = Number(entry);
-    if (Number.isFinite(num) && num > 0) ids.push(num);
-  };
-  if (Array.isArray(value)) {
-    value.forEach((entry) => {
-      if (!entry) return;
-      if (typeof entry === 'object') {
-        pushId(entry.id ?? entry.servico_id ?? entry.service_id ?? entry.servicoId ?? entry.serviceId);
-      } else {
-        pushId(entry);
-      }
-    });
-  } else if (value !== undefined && value !== null && String(value).trim() !== '') {
-    String(value)
-      .split(',')
-      .map((part) => part.trim())
-      .filter(Boolean)
-      .forEach(pushId);
-  }
-  const seen = new Set();
-  return ids.filter((id) => {
-    if (seen.has(id)) return false;
-    seen.add(id);
-    return true;
-  });
-};
-
-const extractServiceIds = (body) => {
-  if (!body || typeof body !== 'object') return [];
-  const rawList =
-    body.servico_ids ??
-    body.servicos ??
-    body.service_ids ??
-    body.services ??
-    body.serviceIds ??
-    body.servicoIds ??
-    null;
-  const parsed = normalizeServiceIds(rawList);
-  if (parsed.length) return parsed;
-  if (body.servico_id != null) {
-    return normalizeServiceIds([body.servico_id]);
-  }
-  return [];
-};
-
-const summarizeServices = (items) => {
-  const serviceNames = items.map((item) => item?.nome).filter(Boolean);
-  const duracaoTotal = items.reduce((sum, item) => sum + Number(item?.duracao_min || 0), 0);
-  const precoTotal = items.reduce(
-    (sum, item) => sum + Number(item?.preco_centavos ?? item?.preco_snapshot ?? 0),
-    0
-  );
-  return {
-    serviceIds: items.map((item) => item.id),
-    serviceNames,
-    serviceLabel: serviceNames.join(' + '),
-    duracaoTotal,
-    precoTotal,
-  };
-};
-
-const normalizeOrigem = (value) => {
-  const raw = String(value || '').trim().toLowerCase();
-  if (!raw) return null;
-  return raw.slice(0, 32);
-};
-
-const fetchServicesForAppointment = async (db, estabelecimentoId, serviceIds) => {
-  if (!serviceIds.length) return { items: [], missing: serviceIds };
-  const placeholders = serviceIds.map(() => '?').join(', ');
-  const [rows] = await db.query(
-    `SELECT id, nome, duracao_min, preco_centavos
-       FROM servicos
-      WHERE id IN (${placeholders})
-        AND estabelecimento_id=?
-        AND ativo=1`,
-    [...serviceIds, estabelecimentoId]
-  );
-  const map = new Map(rows.map((row) => [Number(row.id), row]));
-  const missing = serviceIds.filter((id) => !map.has(Number(id)));
-  if (missing.length) return { items: [], missing };
-  const items = serviceIds.map((id) => {
-    const svc = map.get(Number(id));
-    return {
-      id: Number(svc.id),
-      nome: svc.nome,
-      duracao_min: Number(svc.duracao_min || 0),
-      preco_centavos: Number(svc.preco_centavos || 0),
-    };
-  });
-  return { items, missing: [] };
-};
-
-const fetchServiceProfessionalMap = async (db, serviceIds) => {
-  if (!serviceIds.length) return new Map();
-  const placeholders = serviceIds.map(() => '?').join(', ');
-  const [rows] = await db.query(
-    `SELECT servico_id, profissional_id
-       FROM servico_profissionais
-      WHERE servico_id IN (${placeholders})`,
-    serviceIds
-  );
-  const map = new Map();
-  rows.forEach((row) => {
-    const key = Number(row.servico_id);
-    if (!map.has(key)) map.set(key, new Set());
-    map.get(key).add(Number(row.profissional_id));
-  });
-  return map;
-};
-
-const fetchAppointmentItems = async (db, appointmentIds) => {
-  if (!appointmentIds.length) return new Map();
-  const placeholders = appointmentIds.map(() => '?').join(', ');
-  const [rows] = await db.query(
-    `SELECT ai.agendamento_id,
-            ai.servico_id,
-            ai.ordem,
-            ai.duracao_min,
-            ai.preco_snapshot,
-            s.nome AS servico_nome
-       FROM agendamento_itens ai
-       JOIN servicos s ON s.id = ai.servico_id
-      WHERE ai.agendamento_id IN (${placeholders})
-      ORDER BY ai.agendamento_id, ai.ordem`,
-    appointmentIds
-  );
-  const byAppointment = new Map();
-  rows.forEach((row) => {
-    const key = Number(row.agendamento_id);
-    if (!byAppointment.has(key)) byAppointment.set(key, []);
-    byAppointment.get(key).push({
-      id: Number(row.servico_id),
-      nome: row.servico_nome,
-      ordem: Number(row.ordem) || 0,
-      duracao_min: Number(row.duracao_min || 0),
-      preco_snapshot: Number(row.preco_snapshot || 0),
-    });
-  });
-  return byAppointment;
-};
-
-function brDateTime(iso) {
-  return new Date(iso).toLocaleString('pt-BR', {
-    hour: '2-digit', minute: '2-digit', day: '2-digit', month: '2-digit', year: 'numeric', timeZone: TZ,
-  });
-}
-
-function toDigits(s){ return String(s || '').replace(/\D/g, ''); }
-
-function normalizePhoneBR(value){
-  let digits = toDigits(value);
-  if (!digits) return '';
-  digits = digits.replace(/^0+/, '');
-  if (digits.startsWith('55')) return digits;
-  if (digits.length >= 10 && digits.length <= 11) return `55${digits}`;
-  return digits;
-}
-
-const normalizeBirthdate = (value) => {
-  if (value === undefined || value === null) return null;
-  const raw = String(value).trim();
-  if (!raw) return null;
-  const match = raw.match(/^(\d{4})-(\d{2})-(\d{2})$/);
-  if (!match) return null;
-  const year = Number(match[1]);
-  const month = Number(match[2]);
-  const day = Number(match[3]);
-  const dt = new Date(year, month - 1, day);
-  if (
-    Number.isNaN(dt.getTime()) ||
-    dt.getFullYear() !== year ||
-    dt.getMonth() + 1 !== month ||
-    dt.getDate() !== day
-  ) {
-    return null;
-  }
-  return `${match[1]}-${match[2]}-${match[3]}`;
-};
-
-const boolPref = (value, fallback = true) => {
-  if (value === undefined || value === null) return fallback;
-  if (value === true || value === false) return Boolean(value);
-  const num = Number(value);
-  if (!Number.isNaN(num)) return num !== 0;
-  const norm = String(value).trim().toLowerCase();
-  if (['0', 'false', 'off', 'no', 'nao'].includes(norm)) return false;
-  if (['1', 'true', 'on', 'yes', 'sim'].includes(norm)) return true;
-  return fallback;
-};
-
-const hashToken = (token) =>
-  crypto.createHash('sha256').update(String(token || '')).digest('hex');
-const firstName = (full) => {
-  const parts = String(full || '').trim().split(/\s+/);
-  return parts[0] || '';
-};
-
-const renderConfirmPage = ({ title, message }) => `<!doctype html>
-<html lang="pt-BR">
-  <head>
-    <meta charset="utf-8" />
-    <meta name="viewport" content="width=device-width, initial-scale=1" />
-    <title>${title}</title>
-    <style>
-      body { font-family: Arial, sans-serif; margin: 40px; color: #0f172a; }
-      .card { max-width: 520px; padding: 24px; border: 1px solid #e2e8f0; border-radius: 12px; }
-      .muted { color: #64748b; font-size: 14px; }
-      a { color: #2563eb; text-decoration: none; }
-    </style>
-  </head>
-  <body>
-    <div class="card">
-      <h2>${title}</h2>
-      <p>${message}</p>
-      <p class="muted"><a href="${FRONTEND_BASE}">Ir para o site</a></p>
-    </div>
-  </body>
-</html>`;
-
-async function notifyPublicConfirmedAppointment(appointmentId) {
-  try {
-    const [[ag]] = await pool.query(
-      `SELECT a.id, a.inicio, a.estabelecimento_id, a.servico_id, a.profissional_id,
-              c.nome AS cliente_nome, c.email AS cliente_email, c.telefone AS cliente_telefone
-         FROM agendamentos a
-         JOIN usuarios c ON c.id=a.cliente_id
-        WHERE a.id=? LIMIT 1`,
-      [appointmentId]
-    );
-    if (!ag) return;
-
-    const itemsByAppointment = await fetchAppointmentItems(pool, [Number(ag.id)]);
-    let serviceItems = itemsByAppointment.get(Number(ag.id)) || [];
-    if (!serviceItems.length && ag.servico_id) {
-      const fallback = await fetchServicesForAppointment(pool, ag.estabelecimento_id, [ag.servico_id]);
-      serviceItems = fallback.items || [];
-    }
-    const summary = summarizeServices(serviceItems);
-    const serviceLabel = summary.serviceLabel || serviceItems[0]?.nome || 'servico';
-    const [[est]] = await pool.query(
-      'SELECT email, telefone, nome, notify_email_estab, notify_whatsapp_estab FROM usuarios WHERE id=?',
-      [ag.estabelecimento_id]
-    );
-    const [tmplRows] = await pool.query(
-      'SELECT email_subject, email_html, wa_template FROM estab_messages WHERE estabelecimento_id=?',
-      [ag.estabelecimento_id]
-    );
-    let profissionalRow = null;
-    if (ag.profissional_id != null) {
-      const [[profRow]] = await pool.query(
-        'SELECT nome FROM profissionais WHERE id=? AND estabelecimento_id=?',
-        [ag.profissional_id, ag.estabelecimento_id]
-      );
-      profissionalRow = profRow || null;
-    }
-    const tmpl = (tmplRows && tmplRows[0]) ? tmplRows[0] : {};
-    const inicioISO = new Date(ag.inicio).toISOString();
-    const inicioBR = brDateTime(inicioISO);
-    const telCli = normalizePhoneBR(ag.cliente_telefone);
-    const telEst = normalizePhoneBR(est?.telefone);
-    const canWhatsappEst = boolPref(est?.notify_whatsapp_estab, true);
-    const blockEstabNotifications = estabNotificationsDisabled();
-    const blockClientWhatsapp = clientWhatsappDisabled();
-    const blockWhatsappImmediate = whatsappImmediateDisabled();
-    const blockWhatsappConfirmation = whatsappConfirmationDisabled();
-    const profNome = profissionalRow?.nome || '';
-    const profLabel = profNome ? ` com ${profNome}` : '';
-    const appointmentLink = `${FRONTEND_BASE}/cliente?agendamento=${ag.id}`;
-    const appointmentLinkHtml = `<p><a href="${appointmentLink}">Ver agendamento</a></p>`;
-
-    try {
+// backend/src/routes/agendamentos_public.js

+import { Router } from 'express';

+import crypto from 'crypto';

+import { pool } from '../lib/db.js';

+import { assertDentroExpediente, formatExpedienteMessage, getExpediente, getLocalRangeMinutes } from '../lib/expediente.js';

+import { getPlanContext, isDelinquentStatus, formatPlanLimitExceeded } from '../lib/plans.js';

+import bcrypt from 'bcryptjs';

+import { notifyEmail } from '../lib/notifications.js';
+import { sendAppointmentWhatsApp } from '../lib/whatsapp_outbox.js';
+import { buildConfirmacaoAgendamentoV2Components, isConfirmacaoAgendamentoV2 } from '../lib/whatsapp_templates.js';
+import { createMercadoPagoPixPayment } from '../lib/billing.js';
+import { resolveMpAccessToken } from '../services/mpAccounts.js';
+import { estabNotificationsDisabled } from '../lib/estab_notifications.js';
+import { clientWhatsappDisabled, whatsappImmediateDisabled, whatsappConfirmationDisabled } from '../lib/client_notifications.js';
+import jwt from 'jsonwebtoken';
+import { checkMonthlyAppointmentLimit, notifyAppointmentLimitReached } from '../lib/appointment_limits.js';
+

+const router = Router();

+const TZ = 'America/Sao_Paulo';

+const FRONTEND_BASE = String(process.env.FRONTEND_BASE_URL || process.env.APP_URL || 'http://localhost:3001').replace(/\/$/, '');

+const APPOINTMENT_BUFFER_MIN = (() => {
+  const raw = process.env.AGENDAMENTO_BUFFER_MIN  process.env.APPOINTMENT_BUFFER_MIN;
+  if (raw === undefined || raw === null || String(raw).trim() === '') return 0;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) && parsed > 0  Math.round(parsed) : 0;
+})();
+const DEFAULT_DEPOSIT_HOLD_MINUTES = 15;
+const DEPOSIT_ALLOWED_PLANS = new Set(['pro', 'premium']);
+
+const safeJson = (payload) => {
+  try {
+    return JSON.stringify(payload);
+  } catch {
+    return null;
+  }
+};
+
+function resolveApiBaseUrl() {
+  const frontBase = String(process.env.FRONTEND_BASE_URL || process.env.APP_URL || 'http://localhost:3001').replace(/\/$/, '');
+  const isDevFront = /^(https?:\/\/)?(localhost|127\.0\.0\.1):3001$/i.test(frontBase);
+  const defaultApi = isDevFront  'http://localhost:3002' : `${frontBase}/api`;
+  return String(process.env.API_BASE_URL || process.env.BACKEND_BASE_URL || defaultApi).replace(/\/$/, '');
+}
+
+async function resolveDepositConfig(estabelecimentoId, planContext) {
+  const allowed = DEPOSIT_ALLOWED_PLANS.has(String(planContext?.plan || '').toLowerCase());
+  if (!allowed) {
+    return { allowed: false, enabled: false, percent: null, holdMinutes: DEFAULT_DEPOSIT_HOLD_MINUTES };
+  }
+  const [rows] = await pool.query(
+    'SELECT deposit_enabled, deposit_percent, deposit_hold_minutes FROM establishment_settings WHERE estabelecimento_id= LIMIT 1',
+    [estabelecimentoId]
+  );
+  const row = rows?.[0];
+  const enabledFlag = row  Number(row.deposit_enabled || 0) : 0;
+  const percent = row?.deposit_percent != null  Number(row.deposit_percent) : null;
+  const holdMinutes = Number(row?.deposit_hold_minutes || DEFAULT_DEPOSIT_HOLD_MINUTES) || DEFAULT_DEPOSIT_HOLD_MINUTES;
+  const enabled =
+    Boolean(enabledFlag) &&
+    Number.isFinite(percent) &&
+    percent >= 5 &&
+    percent <= 90;
+  return { allowed: true, enabled, percent, holdMinutes };
+}
+

+const normalizeServiceIds = (value) => {

+  const ids = [];

+  const pushId = (entry) => {

+    const num = Number(entry);

+    if (Number.isFinite(num) && num > 0) ids.push(num);

+  };

+  if (Array.isArray(value)) {

+    value.forEach((entry) => {

+      if (!entry) return;

+      if (typeof entry === 'object') {

+        pushId(entry.id  entry.servico_id  entry.service_id  entry.servicoId  entry.serviceId);

+      } else {

+        pushId(entry);

+      }

+    });

+  } else if (value !== undefined && value !== null && String(value).trim() !== '') {

+    String(value)

+      .split(',')

+      .map((part) => part.trim())

+      .filter(Boolean)

+      .forEach(pushId);

+  }

+  const seen = new Set();

+  return ids.filter((id) => {

+    if (seen.has(id)) return false;

+    seen.add(id);

+    return true;

+  });

+};

+

+const extractServiceIds = (body) => {

+  if (!body || typeof body !== 'object') return [];

+  const rawList =

+    body.servico_ids ?

+    body.servicos ?

+    body.service_ids ?

+    body.services ?

+    body.serviceIds ?

+    body.servicoIds ?

+    null;

+  const parsed = normalizeServiceIds(rawList);

+  if (parsed.length) return parsed;

+  if (body.servico_id != null) {

+    return normalizeServiceIds([body.servico_id]);

+  }

+  return [];

+};

+

+const summarizeServices = (items) => {
+  const serviceNames = items.map((item) => item?.nome).filter(Boolean);

+  const duracaoTotal = items.reduce((sum, item) => sum + Number(item?.duracao_min || 0), 0);

+  const precoTotal = items.reduce(

+    (sum, item) => sum + Number(item?.preco_centavos  item?.preco_snapshot  0),

+    0

+  );

+  return {
+    serviceIds: items.map((item) => item.id),
+    serviceNames,
+    serviceLabel: serviceNames.join(' + '),
+    duracaoTotal,
+    precoTotal,
+  };
+};
+
+const normalizeOrigem = (value) => {
+  const raw = String(value || '').trim().toLowerCase();
+  if (!raw) return null;
+  return raw.slice(0, 32);
+};
+

+const fetchServicesForAppointment = async (db, estabelecimentoId, serviceIds) => {

+  if (!serviceIds.length) return { items: [], missing: serviceIds };

+  const placeholders = serviceIds.map(() => '?').join(', ');

+  const [rows] = await db.query(

+    `SELECT id, nome, duracao_min, preco_centavos

+       FROM servicos

+      WHERE id IN (${placeholders})

+        AND estabelecimento_id=?

+        AND ativo=1`,

+    [...serviceIds, estabelecimentoId]

+  );

+  const map = new Map(rows.map((row) => [Number(row.id), row]));

+  const missing = serviceIds.filter((id) => !map.has(Number(id)));

+  if (missing.length) return { items: [], missing };

+  const items = serviceIds.map((id) => {

+    const svc = map.get(Number(id));

+    return {

+      id: Number(svc.id),

+      nome: svc.nome,

+      duracao_min: Number(svc.duracao_min || 0),

+      preco_centavos: Number(svc.preco_centavos || 0),

+    };

+  });

+  return { items, missing: [] };

+};

+

+const fetchServiceProfessionalMap = async (db, serviceIds) => {

+  if (!serviceIds.length) return new Map();

+  const placeholders = serviceIds.map(() => '?').join(', ');

+  const [rows] = await db.query(

+    `SELECT servico_id, profissional_id

+       FROM servico_profissionais

+      WHERE servico_id IN (${placeholders})`,

+    serviceIds

+  );

+  const map = new Map();

+  rows.forEach((row) => {

+    const key = Number(row.servico_id);

+    if (!map.has(key)) map.set(key, new Set());

+    map.get(key).add(Number(row.profissional_id));

+  });

+  return map;

+};

+

+const fetchAppointmentItems = async (db, appointmentIds) => {

+  if (!appointmentIds.length) return new Map();

+  const placeholders = appointmentIds.map(() => '?').join(', ');

+  const [rows] = await db.query(

+    `SELECT ai.agendamento_id,

+            ai.servico_id,

+            ai.ordem,

+            ai.duracao_min,

+            ai.preco_snapshot,

+            s.nome AS servico_nome

+       FROM agendamento_itens ai

+       JOIN servicos s ON s.id = ai.servico_id

+      WHERE ai.agendamento_id IN (${placeholders})

+      ORDER BY ai.agendamento_id, ai.ordem`,

+    appointmentIds

+  );

+  const byAppointment = new Map();

+  rows.forEach((row) => {

+    const key = Number(row.agendamento_id);

+    if (!byAppointment.has(key)) byAppointment.set(key, []);

+    byAppointment.get(key).push({

+      id: Number(row.servico_id),

+      nome: row.servico_nome,

+      ordem: Number(row.ordem) || 0,

+      duracao_min: Number(row.duracao_min || 0),

+      preco_snapshot: Number(row.preco_snapshot || 0),

+    });

+  });

+  return byAppointment;

+};

+

+function brDateTime(iso) {

+  return new Date(iso).toLocaleString('pt-BR', {

+    hour: '2-digit', minute: '2-digit', day: '2-digit', month: '2-digit', year: 'numeric', timeZone: TZ,

+  });

+}

+

+function toDigits(s){ return String(s || '').replace(/\D/g, ''); }

+

+function normalizePhoneBR(value){

+  let digits = toDigits(value);

+  if (!digits) return '';

+  digits = digits.replace(/^0+/, '');

+  if (digits.startsWith('55')) return digits;

+  if (digits.length >= 10 && digits.length <= 11) return `55${digits}`;

+  return digits;

+}

+

+const normalizeBirthdate = (value) => {

+  if (value === undefined || value === null) return null;

+  const raw = String(value).trim();

+  if (!raw) return null;

+  const match = raw.match(/^(\d{4})-(\d{2})-(\d{2})$/);

+  if (!match) return null;

+  const year = Number(match[1]);

+  const month = Number(match[2]);

+  const day = Number(match[3]);

+  const dt = new Date(year, month - 1, day);

+  if (

+    Number.isNaN(dt.getTime()) ||

+    dt.getFullYear() !== year ||

+    dt.getMonth() + 1 !== month ||

+    dt.getDate() !== day

+  ) {

+    return null;

+  }

+  return `${match[1]}-${match[2]}-${match[3]}`;

+};

+

+const boolPref = (value, fallback = true) => {

+  if (value === undefined || value === null) return fallback;

+  if (value === true || value === false) return Boolean(value);

+  const num = Number(value);

+  if (!Number.isNaN(num)) return num !== 0;

+  const norm = String(value).trim().toLowerCase();

+  if (['0', 'false', 'off', 'no', 'nao'].includes(norm)) return false;

+  if (['1', 'true', 'on', 'yes', 'sim'].includes(norm)) return true;

+  return fallback;

+};

+

+const hashToken = (token) =>

+  crypto.createHash('sha256').update(String(token || '')).digest('hex');

+const firstName = (full) => {

+  const parts = String(full || '').trim().split(/\s+/);

+  return parts[0] || '';

+};

+

+const renderConfirmPage = ({ title, message }) => `<!doctype html>

+<html lang="pt-BR">

+  <head>

+    <meta charset="utf-8" />

+    <meta name="viewport" content="width=device-width, initial-scale=1" />

+    <title>${title}</title>

+    <style>

+      body { font-family: Arial, sans-serif; margin: 40px; color: #0f172a; }

+      .card { max-width: 520px; padding: 24px; border: 1px solid #e2e8f0; border-radius: 12px; }

+      .muted { color: #64748b; font-size: 14px; }

+      a { color: #2563eb; text-decoration: none; }

+    </style>

+  </head>

+  <body>

+    <div class="card">

+      <h2>${title}</h2>

+      <p>${message}</p>

+      <p class="muted"><a href="${FRONTEND_BASE}">Ir para o site</a></p>

+    </div>

+  </body>

+</html>`;

+

+async function notifyPublicConfirmedAppointment(appointmentId) {

+  try {

+    const [[ag]] = await pool.query(

+      `SELECT a.id, a.inicio, a.estabelecimento_id, a.servico_id, a.profissional_id,

+              c.nome AS cliente_nome, c.email AS cliente_email, c.telefone AS cliente_telefone

+         FROM agendamentos a

+         JOIN usuarios c ON c.id=a.cliente_id

+        WHERE a.id= LIMIT 1`,

+      [appointmentId]

+    );

+    if (!ag) return;

+

+    const itemsByAppointment = await fetchAppointmentItems(pool, [Number(ag.id)]);

+    let serviceItems = itemsByAppointment.get(Number(ag.id)) || [];

+    if (!serviceItems.length && ag.servico_id) {

+      const fallback = await fetchServicesForAppointment(pool, ag.estabelecimento_id, [ag.servico_id]);

+      serviceItems = fallback.items || [];

+    }

+    const summary = summarizeServices(serviceItems);

+    const serviceLabel = summary.serviceLabel || serviceItems[0]?.nome || 'servico';
+    const [[est]] = await pool.query(

+      'SELECT email, telefone, nome, notify_email_estab, notify_whatsapp_estab FROM usuarios WHERE id=?',

+      [ag.estabelecimento_id]

+    );

+    const [tmplRows] = await pool.query(

+      'SELECT email_subject, email_html, wa_template FROM estab_messages WHERE estabelecimento_id=?',

+      [ag.estabelecimento_id]

+    );

+    let profissionalRow = null;

+    if (ag.profissional_id != null) {

+      const [[profRow]] = await pool.query(

+        'SELECT nome FROM profissionais WHERE id= AND estabelecimento_id=?',

+        [ag.profissional_id, ag.estabelecimento_id]

+      );

+      profissionalRow = profRow || null;

+    }

+    const tmpl = (tmplRows && tmplRows[0])  tmplRows[0] : {};

+    const inicioISO = new Date(ag.inicio).toISOString();

+    const inicioBR = brDateTime(inicioISO);

+    const telCli = normalizePhoneBR(ag.cliente_telefone);

+    const telEst = normalizePhoneBR(est?.telefone);

+    const canWhatsappEst = boolPref(est?.notify_whatsapp_estab, true);

+    const blockEstabNotifications = estabNotificationsDisabled();

+    const blockClientWhatsapp = clientWhatsappDisabled();

+    const blockWhatsappImmediate = whatsappImmediateDisabled();

+    const blockWhatsappConfirmation = whatsappConfirmationDisabled();

+    const profNome = profissionalRow?.nome || '';

+    const profLabel = profNome  ` com ${profNome}` : '';

+    const appointmentLink = `${FRONTEND_BASE}/cliente?agendamento=${ag.id}`;

+    const appointmentLinkHtml = `<p><a href="${appointmentLink}">Ver agendamento</a></p>`;

+

+    try {

       const emailNorm = ag.cliente_email ? String(ag.cliente_email).trim().toLowerCase() : '';
-      if (emailNorm) {
-        const subject = tmpl.email_subject || 'Agendamento confirmado';
-        const rawTemplate =
-          tmpl.email_html ||
-          `<p>Olá, <b>{{cliente_nome}}</b>! Seu agendamento de <b>{{servico_nome}}</b>{{profissional_nome}} foi confirmado para <b>{{data_hora}}</b>.</p>`;
-        const hasLinkPlaceholder = /{{\s*link_agendamento\s*}}/i.test(rawTemplate);
-        let html = rawTemplate
-          .replace(/{{\s*cliente_nome\s*}}/g, firstName(ag.cliente_nome) || 'cliente')
-          .replace(/{{\s*servico_nome\s*}}/g, serviceLabel)
-          .replace(/{{\s*data_hora\s*}}/g, inicioBR)
-          .replace(/{{\s*estabelecimento_nome\s*}}/g, est?.nome || '')
-          .replace(/{{\s*profissional_nome\s*}}/g, profNome ? ` com <b>${profNome}</b>` : '')
-          .replace(/{{\s*link_agendamento\s*}}/gi, appointmentLinkHtml);
-        if (!hasLinkPlaceholder) {
-          html += appointmentLinkHtml;
-        }
-        await notifyEmail(emailNorm, subject, html);
-      }
-    } catch {}
-
-    try {
-        if (!blockWhatsappImmediate && !blockWhatsappConfirmation && !blockClientWhatsapp && telCli) {
-          const paramMode = String(process.env.WA_TEMPLATE_PARAM_MODE || 'single').toLowerCase();
-          const tplName = process.env.WA_TEMPLATE_NAME_CONFIRM || process.env.WA_TEMPLATE_NAME || 'confirmacao_agendamento_v2';
-          const tplLang = process.env.WA_TEMPLATE_LANG || 'pt_BR';
-          const estNomeLabel = est?.nome || '';
-          const isConfirmV2 = isConfirmacaoAgendamentoV2(tplName);
-          const tplParams = isConfirmV2
-            ? buildConfirmacaoAgendamentoV2Components({
-                serviceLabel,
-                dataHoraLabel: inicioBR,
-                estabelecimentoNome: estNomeLabel,
-              })
-            : [serviceLabel, inicioBR, estNomeLabel];
-          const waMsg = (tmpl.wa_template || `Novo agendamento registrado: {{servico_nome}} em {{data_hora}} - {{estabelecimento_nome}}.`)
-            .replace(/{{\s*cliente_nome\s*}}/g, firstName(ag.cliente_nome) || 'cliente')
-            .replace(/{{\s*servico_nome\s*}}/g, serviceLabel)
-            .replace(/{{\s*data_hora\s*}}/g, inicioBR)
-            .replace(/{{\s*estabelecimento_nome\s*}}/g, estNomeLabel)
-            .replace(/{{\s*profissional_nome\s*}}/g, profNome ? ` com ${profNome}` : '');
-          const fallbackBodyParams = isConfirmV2 ? tplParams : [waMsg];
-          if (/^triple|3$/.test(paramMode)) {
-            await sendAppointmentWhatsApp({
-              estabelecimentoId: ag.estabelecimento_id,
-              agendamentoId: ag.id,
-              to: telCli,
-              kind: 'confirm_cli',
-              template: { name: tplName, lang: tplLang, bodyParams: tplParams },
-            });
-          } else {
-            await sendAppointmentWhatsApp({
-              estabelecimentoId: ag.estabelecimento_id,
-              agendamentoId: ag.id,
-              to: telCli,
-              kind: 'confirm_cli',
-              message: waMsg,
-              template: { name: tplName, lang: tplLang, bodyParams: fallbackBodyParams },
-            });
-          }
-        }
-    } catch {}
-
-    try {
-      if (!blockWhatsappImmediate && !blockWhatsappConfirmation && !blockEstabNotifications && canWhatsappEst && telEst && telEst !== telCli) {
-        const tplName = process.env.WA_TEMPLATE_NAME_CONFIRM || process.env.WA_TEMPLATE_NAME || 'confirmacao_agendamento_v2';
-        const tplLang = process.env.WA_TEMPLATE_LANG || 'pt_BR';
-        const estNomeLabel = est?.nome || '';
-        const isConfirmV2 = isConfirmacaoAgendamentoV2(tplName);
-        const tplParams = isConfirmV2
-          ? buildConfirmacaoAgendamentoV2Components({
-              serviceLabel,
-              dataHoraLabel: inicioBR,
-              estabelecimentoNome: estNomeLabel,
-            })
-          : [serviceLabel, inicioBR, estNomeLabel];
-        const waMsgEst = `Novo agendamento: ${serviceLabel}${profLabel} em ${inicioBR} - Cliente: ${String(ag.cliente_nome) || ''}`;
-        const fallbackBodyParams = isConfirmV2 ? tplParams : [waMsgEst];
-        await sendAppointmentWhatsApp({
-          estabelecimentoId: ag.estabelecimento_id,
-          agendamentoId: ag.id,
-          to: telEst,
-          kind: 'confirm_est',
-          message: waMsgEst,
-          template: { name: tplName, lang: tplLang, bodyParams: fallbackBodyParams },
-        });
-      }
-    } catch {}
-  } catch (e) {
-    console.warn('[public/confirm][notify]', e?.message || e);
-  }
-}
-
-// POST /public/agendamentos  cria agendamento sem login (guest)
-router.post('/', async (req, res) => {
-  let conn;
-  let txStarted = false;
-  try {
-    const {
-      estabelecimento_id,
-      inicio,
-      nome,
-      email,
-      telefone,
-      otp_token,
-      profissional_id: profissionalIdRaw,
-      profissionalId,
-      cep,
-      endereco,
-      numero,
-      complemento,
-      bairro,
-      cidade,
-      estado,
-      data_nascimento,
-      dataNascimento,
-    } = req.body || {};
-
-    const professionalCandidate = profissionalIdRaw != null ? profissionalIdRaw : profissionalId;
+      if (emailNorm) {

+        const subject = tmpl.email_subject || 'Agendamento confirmado';

+        const rawTemplate =

+          tmpl.email_html ||

+          `<p>Olá, <b>{{cliente_nome}}</b>! Seu agendamento de <b>{{servico_nome}}</b>{{profissional_nome}} foi confirmado para <b>{{data_hora}}</b>.</p>`;

+        const hasLinkPlaceholder = /{{\s*link_agendamento\s*}}/i.test(rawTemplate);

+        let html = rawTemplate

+          .replace(/{{\s*cliente_nome\s*}}/g, firstName(ag.cliente_nome) || 'cliente')

+          .replace(/{{\s*servico_nome\s*}}/g, serviceLabel)

+          .replace(/{{\s*data_hora\s*}}/g, inicioBR)

+          .replace(/{{\s*estabelecimento_nome\s*}}/g, est?.nome || '')

+          .replace(/{{\s*profissional_nome\s*}}/g, profNome  ` com <b>${profNome}</b>` : '')

+          .replace(/{{\s*link_agendamento\s*}}/gi, appointmentLinkHtml);

+        if (!hasLinkPlaceholder) {

+          html += appointmentLinkHtml;

+        }

+        await notifyEmail(emailNorm, subject, html);

+      }

+    } catch {}

+

+    try {

+        if (!blockWhatsappImmediate && !blockWhatsappConfirmation && !blockClientWhatsapp && telCli) {

+          const paramMode = String(process.env.WA_TEMPLATE_PARAM_MODE || 'single').toLowerCase();

+          const tplName = process.env.WA_TEMPLATE_NAME_CONFIRM || process.env.WA_TEMPLATE_NAME || 'confirmacao_agendamento_v2';

+          const tplLang = process.env.WA_TEMPLATE_LANG || 'pt_BR';

+          const estNomeLabel = est?.nome || '';

+          const isConfirmV2 = isConfirmacaoAgendamentoV2(tplName);

+          const tplParams = isConfirmV2

+             buildConfirmacaoAgendamentoV2Components({

+                serviceLabel,

+                dataHoraLabel: inicioBR,

+                estabelecimentoNome: estNomeLabel,

+              })

+            : [serviceLabel, inicioBR, estNomeLabel];

+          const waMsg = (tmpl.wa_template || `Novo agendamento registrado: {{servico_nome}} em {{data_hora}} - {{estabelecimento_nome}}.`)

+            .replace(/{{\s*cliente_nome\s*}}/g, firstName(ag.cliente_nome) || 'cliente')

+            .replace(/{{\s*servico_nome\s*}}/g, serviceLabel)

+            .replace(/{{\s*data_hora\s*}}/g, inicioBR)

+            .replace(/{{\s*estabelecimento_nome\s*}}/g, estNomeLabel)

+            .replace(/{{\s*profissional_nome\s*}}/g, profNome  ` com ${profNome}` : '');

+          const fallbackBodyParams = isConfirmV2  tplParams : [waMsg];

+          if (/^triple|3$/.test(paramMode)) {

+            await sendAppointmentWhatsApp({

+              estabelecimentoId: ag.estabelecimento_id,

+              agendamentoId: ag.id,

+              to: telCli,

+              kind: 'confirm_cli',

+              template: { name: tplName, lang: tplLang, bodyParams: tplParams },

+            });

+          } else {

+            await sendAppointmentWhatsApp({

+              estabelecimentoId: ag.estabelecimento_id,

+              agendamentoId: ag.id,

+              to: telCli,

+              kind: 'confirm_cli',

+              message: waMsg,

+              template: { name: tplName, lang: tplLang, bodyParams: fallbackBodyParams },

+            });

+          }

+        }

+    } catch {}

+

+    try {

+      if (!blockWhatsappImmediate && !blockWhatsappConfirmation && !blockEstabNotifications && canWhatsappEst && telEst && telEst !== telCli) {

+        const tplName = process.env.WA_TEMPLATE_NAME_CONFIRM || process.env.WA_TEMPLATE_NAME || 'confirmacao_agendamento_v2';

+        const tplLang = process.env.WA_TEMPLATE_LANG || 'pt_BR';

+        const estNomeLabel = est?.nome || '';

+        const isConfirmV2 = isConfirmacaoAgendamentoV2(tplName);

+        const tplParams = isConfirmV2

+           buildConfirmacaoAgendamentoV2Components({

+              serviceLabel,

+              dataHoraLabel: inicioBR,

+              estabelecimentoNome: estNomeLabel,

+            })

+          : [serviceLabel, inicioBR, estNomeLabel];

+        const waMsgEst = `Novo agendamento: ${serviceLabel}${profLabel} em ${inicioBR} - Cliente: ${String(ag.cliente_nome) || ''}`;

+        const fallbackBodyParams = isConfirmV2  tplParams : [waMsgEst];

+        await sendAppointmentWhatsApp({

+          estabelecimentoId: ag.estabelecimento_id,

+          agendamentoId: ag.id,

+          to: telEst,

+          kind: 'confirm_est',

+          message: waMsgEst,

+          template: { name: tplName, lang: tplLang, bodyParams: fallbackBodyParams },

+        });

+      }

+    } catch {}

+  } catch (e) {

+    console.warn('[public/confirm][notify]', e?.message || e);

+  }

+}

+

+// POST /public/agendamentos  cria agendamento sem login (guest)

+router.post('/', async (req, res) => {
+  let conn;
+  let txStarted = false;
+  try {

+    const {

+      estabelecimento_id,

+      inicio,

+      nome,

+      email,

+      telefone,

+      otp_token,

+      profissional_id: profissionalIdRaw,

+      profissionalId,

+      cep,

+      endereco,

+      numero,

+      complemento,

+      bairro,

+      cidade,

+      estado,

+      data_nascimento,

+      dataNascimento,

+    } = req.body || {};

+

+    const professionalCandidate = profissionalIdRaw != null  profissionalIdRaw : profissionalId;

     const profissional_id = professionalCandidate == null ? null : Number(professionalCandidate);
-    if (profissional_id !== null && !Number.isFinite(profissional_id)) {
-      return res.status(400).json({ error: 'profissional_invalido', message: 'Profissional invalido.' });
-    }
-
-    const serviceIds = extractServiceIds(req.body || {});
-    if (!estabelecimento_id || !serviceIds.length || !inicio || !nome || !email || !telefone) {
-      return res.status(400).json({
-        error: 'invalid_payload',
-        message: 'Campos obrigatorios: estabelecimento_id, servico_ids, inicio, nome, email, telefone.'
-      });
-    }
-
-    const cepDigits = (cep ? String(cep) : '').replace(/[^0-9]/g, '').slice(0, 8);
-    const enderecoTrim = endereco ? String(endereco).trim() : '';
-    const numeroTrim = numero ? String(numero).trim() : '';
-    const complementoTrim = complemento ? String(complemento).trim() : '';
-    const bairroTrim = bairro ? String(bairro).trim() : '';
-    const cidadeTrim = cidade ? String(cidade).trim() : '';
-    const estadoTrim = estado ? String(estado).trim().toUpperCase() : '';
-    const dataNascimentoRaw = data_nascimento ?? dataNascimento;
-    const dataNascimentoValue = normalizeBirthdate(dataNascimentoRaw);
-    if (dataNascimentoRaw && String(dataNascimentoRaw).trim() && !dataNascimentoValue) {
-      return res.status(400).json({ error: 'data_nascimento_invalida', message: 'Informe uma data de nascimento valida.' });
-    }
-    if (cepDigits && cepDigits.length !== 8) {
-      return res.status(400).json({ error: 'cep_invalido', message: 'Informe um CEP valido com 8 digitos.' });
-    }
-    if (estadoTrim && !/^[A-Z]{2}$/.test(estadoTrim)) {
-      return res.status(400).json({ error: 'estado_invalido', message: 'Informe a UF com 2 letras.' });
-    }
-
-    const planContext = await getPlanContext(estabelecimento_id);
-    if (!planContext) {
-      return res.status(404).json({ error: 'estabelecimento_inexistente' });
-    }
-    if (isDelinquentStatus(planContext.status)) {
-      return res.status(403).json({ error: 'plan_delinquent', message: 'Este estabelecimento esta com o plano em atraso. Agendamentos temporariamente suspensos.' });
-    }
-
-    const inicioDate = new Date(inicio);
-    if (Number.isNaN(inicioDate.getTime())) return res.status(400).json({ error: 'invalid_date' });
-    if (inicioDate.getTime() <= Date.now()) return res.status(400).json({ error: 'past_datetime' });
-
-    const { items: serviceItems, missing } = await fetchServicesForAppointment(pool, estabelecimento_id, serviceIds);
-    if (missing.length) {
-      return res.status(400).json({ error: 'servico_invalido', message: 'Servico invalido ou inativo para este estabelecimento.' });
-    }
-    if (serviceItems.some((item) => !Number.isFinite(item.duracao_min) || item.duracao_min <= 0)) {
-      return res.status(400).json({ error: 'duracao_invalida' });
-    }
-    const summary = summarizeServices(serviceItems);
-    const primaryServiceId = summary.serviceIds[0] || serviceIds[0];
-    const serviceLabel = summary.serviceLabel || serviceItems[0]?.nome || 'servico';
-
-    const professionalMap = await fetchServiceProfessionalMap(pool, summary.serviceIds);
-    const servicesRequiringProfessional = summary.serviceIds.filter((id) => (professionalMap.get(id)?.size || 0) > 0);
-    const requiresProfessional = servicesRequiringProfessional.length > 0;
-
-    if (requiresProfessional && profissional_id == null) {
-      return res.status(400).json({ error: 'profissional_obrigatorio', message: 'Escolha um profissional para estes servicos.' });
-    }
-
-    if (profissional_id != null) {
-      const [[profRow]] = await pool.query(
-        'SELECT id, nome, avatar_url, ativo FROM profissionais WHERE id=? AND estabelecimento_id=?',
-        [profissional_id, estabelecimento_id]
-      );
-      if (!profRow) {
-        return res.status(400).json({ error: 'profissional_invalido', message: 'Profissional nao encontrado para este estabelecimento.' });
-      }
-      if (!profRow.ativo) {
-        return res.status(400).json({ error: 'profissional_inativo', message: 'Profissional inativo.' });
-      }
-      if (requiresProfessional) {
-        const valid = servicesRequiringProfessional.every((id) => professionalMap.get(id)?.has(profissional_id));
-        if (!valid) {
-          return res.status(400).json({ error: 'profissional_servico', message: 'Profissional nao esta associado a todos os servicos selecionados.' });
-        }
-      }
-    }
-
-    const duracaoTotal = summary.duracaoTotal + APPOINTMENT_BUFFER_MIN;
-    if (!Number.isFinite(duracaoTotal) || duracaoTotal <= 0) return res.status(400).json({ error: 'duracao_invalida' });
-    const fimDate = new Date(inicioDate.getTime() + duracaoTotal * 60_000);
-    const expediente = await getExpediente({
-      db: pool,
-      estabelecimentoId: estabelecimento_id,
-      dateUtc: inicioDate,
-    });
-    const { startMin, endMin, spansDays } = getLocalRangeMinutes(inicioDate, fimDate);
-    if (!assertDentroExpediente({
-      startMin,
-      endMin,
-      abre: expediente.abre,
-      fecha: expediente.fecha,
-      spansDays,
-      breaks: expediente.breaks,
-    })) {
-      return res.status(400).json({ error: 'outside_business_hours', message: formatExpedienteMessage(expediente) });
-    }
-    const planConfig = planContext?.config;
-    const limitCheck = await checkMonthlyAppointmentLimit({
-      estabelecimentoId: estabelecimento_id,
-      planConfig,
-      appointmentDate: inicioDate,
-    });
-    if (!limitCheck.ok) {
-      (async () => {
-        try {
-          await notifyAppointmentLimitReached({
-            estabelecimentoId: estabelecimento_id,
-            limit: limitCheck.limit,
-            total: limitCheck.total,
-            range: limitCheck.range,
-            planConfig,
-          });
-        } catch (e) {
-          console.warn('[agendamentos_public][limit_notify]', e?.message || e);
-        }
-      })();
-      return res.status(403).json({
-        error: 'plan_limit_agendamentos',
-        message: formatPlanLimitExceeded(planConfig, 'appointments') || 'Limite de agendamentos atingido para este mes.',
-        details: { limit: limitCheck.limit, total: limitCheck.total, month: limitCheck.range?.label || null },
-      });
-    }
-
-    const emailNorm = String(email).trim().toLowerCase();
-    const telDigits = toDigits(telefone);
-    const telNorm = normalizePhoneBR(telefone);
-
-    // OTP opcional (exigido via flag)
-    const requireOtp = /^(1|true)$/i.test(String(process.env.PUBLIC_BOOKING_REQUIRE_OTP || ''));
-    if (requireOtp) {
-      const token = String(req.headers['x-otp-token'] || otp_token || '');
-      const secret = process.env.JWT_SECRET;
-      if (!token || !secret) return res.status(400).json({ error: 'otp_required' });
-      try {
-        const payload = jwt.verify(token, secret);
-        if (payload?.scope !== 'otp') throw new Error('bad_scope');
-        const ok = (payload.ch === 'email' && String(payload.v || '').toLowerCase() === emailNorm) ||
-                  (payload.ch === 'phone' && String(payload.v || '') === telDigits);
-        if (!ok) return res.status(400).json({ error: 'otp_mismatch' });
-      } catch (e) {
-        return res.status(400).json({ error: 'otp_invalid' });
-      }
-    }
-
-    // resolve/ cria cliente guest via email (preferencia) ou telefone
-
-    let userId = null;
-    let userByEmail = null;
-    let userByPhone = null;
-    {
-      const [urows] = await pool.query(
-        'SELECT id, nome, email, telefone FROM usuarios WHERE LOWER(email)=? LIMIT 1',
-        [emailNorm]
-      );
-      if (urows.length) userByEmail = urows[0];
-    }
-    if (telNorm || telDigits) {
-      const candidates = [];
-      if (telNorm) candidates.push(telNorm);
-      if (telDigits && telDigits !== telNorm) candidates.push(telDigits);
-      for (const candidate of candidates) {
-        const [urows] = await pool.query(
-          'SELECT id, nome, email, telefone FROM usuarios WHERE telefone=? LIMIT 1',
-          [candidate]
-        );
-        if (urows.length) {
-          userByPhone = urows[0];
-          break;
-        }
-      }
-    }
-    if (userByEmail && userByPhone && userByEmail.id !== userByPhone.id) {
-      return res.status(409).json({
-        error: 'cliente_conflito',
-        message: 'Já existe cliente com este email ou telefone. Revise os dados antes de continuar.',
-      });
-    }
-    const existingUser = userByEmail || userByPhone;
-    if (existingUser) {
+    if (profissional_id !== null && !Number.isFinite(profissional_id)) {

+      return res.status(400).json({ error: 'profissional_invalido', message: 'Profissional invalido.' });

+    }

+

+    const serviceIds = extractServiceIds(req.body || {});

+    if (!estabelecimento_id || !serviceIds.length || !inicio || !nome || !email || !telefone) {

+      return res.status(400).json({

+        error: 'invalid_payload',

+        message: 'Campos obrigatorios: estabelecimento_id, servico_ids, inicio, nome, email, telefone.'

+      });

+    }

+

+    const cepDigits = (cep == null ? '' : String(cep))
+      .replace(/[^0-9]/g, '')
+      .slice(0, 8);
+    const enderecoTrim = endereco == null ? '' : String(endereco).trim();
+    const numeroTrim = numero == null ? '' : String(numero).trim();
+    const complementoTrim = complemento == null ? '' : String(complemento).trim();
+    const bairroTrim = bairro == null ? '' : String(bairro).trim();
+    const cidadeTrim = cidade == null ? '' : String(cidade).trim();
+    const estadoTrim = estado == null ? '' : String(estado).trim().toUpperCase();
+    const dataNascimentoRaw = data_nascimento  dataNascimento;

+    const dataNascimentoValue = normalizeBirthdate(dataNascimentoRaw);

+    if (dataNascimentoRaw && String(dataNascimentoRaw).trim() && !dataNascimentoValue) {

+      return res.status(400).json({ error: 'data_nascimento_invalida', message: 'Informe uma data de nascimento valida.' });

+    }

+    if (cepDigits && cepDigits.length !== 8) {

+      return res.status(400).json({ error: 'cep_invalido', message: 'Informe um CEP valido com 8 digitos.' });

+    }

+    if (estadoTrim && !/^[A-Z]{2}$/.test(estadoTrim)) {

+      return res.status(400).json({ error: 'estado_invalido', message: 'Informe a UF com 2 letras.' });

+    }

+

+    const planContext = await getPlanContext(estabelecimento_id);

+    if (!planContext) {

+      return res.status(404).json({ error: 'estabelecimento_inexistente' });

+    }

+    if (isDelinquentStatus(planContext.status)) {

+      return res.status(403).json({ error: 'plan_delinquent', message: 'Este estabelecimento esta com o plano em atraso. Agendamentos temporariamente suspensos.' });

+    }

+

+    const inicioDate = new Date(inicio);

+    if (Number.isNaN(inicioDate.getTime())) return res.status(400).json({ error: 'invalid_date' });

+    if (inicioDate.getTime() <= Date.now()) return res.status(400).json({ error: 'past_datetime' });

+

+    const { items: serviceItems, missing } = await fetchServicesForAppointment(pool, estabelecimento_id, serviceIds);

+    if (missing.length) {

+      return res.status(400).json({ error: 'servico_invalido', message: 'Servico invalido ou inativo para este estabelecimento.' });

+    }

+    if (serviceItems.some((item) => !Number.isFinite(item.duracao_min) || item.duracao_min <= 0)) {

+      return res.status(400).json({ error: 'duracao_invalida' });

+    }

+    const summary = summarizeServices(serviceItems);
+    const primaryServiceId = summary.serviceIds[0] || serviceIds[0];
+    const serviceLabel = summary.serviceLabel || serviceItems[0]?.nome || 'servico';
+    const totalCentavos = Math.max(0, Math.round(summary.precoTotal || 0));
+    const depositConfig = await resolveDepositConfig(estabelecimento_id, planContext);
+    const depositCandidate = depositConfig.allowed && depositConfig.enabled;
+    const depositPercent = depositCandidate  Number(depositConfig.percent || 0) : null;
+    let depositCentavos = depositCandidate  Math.round(totalCentavos * (depositPercent || 0) / 100) : null;
+    const depositRequired = depositCandidate && totalCentavos > 0 && Number.isFinite(depositCentavos) && depositCentavos > 0;
+    if (!depositRequired) depositCentavos = null;
+    const depositHoldMinutes = depositRequired  depositConfig.holdMinutes : DEFAULT_DEPOSIT_HOLD_MINUTES;
+    const depositExpiresAt = depositRequired
+       new Date(Date.now() + Number(depositHoldMinutes || DEFAULT_DEPOSIT_HOLD_MINUTES) * 60_000)
+      : null;
+    let mpAccessToken = null;
+    if (depositRequired) {
+      const mpAccess = await resolveMpAccessToken(estabelecimento_id);
+      mpAccessToken = mpAccess.accessToken || null;
+      if (!mpAccessToken) {
+        if (!mpAccess.allowFallback) {
+          return res.status(409).json({
+            error: 'mp_not_connected',
+            message: 'Conecte seu Mercado Pago para receber o sinal.',
+          });
+        }
+        console.warn('[public/agendamentos][deposit] mp fallback', {
+          estabelecimento_id,
+          reason: mpAccess.reason || 'missing_token',
+        });
+      }
+    }
+

+    const professionalMap = await fetchServiceProfessionalMap(pool, summary.serviceIds);

+    const servicesRequiringProfessional = summary.serviceIds.filter((id) => (professionalMap.get(id)?.size || 0) > 0);

+    const requiresProfessional = servicesRequiringProfessional.length > 0;

+

+    if (requiresProfessional && profissional_id == null) {

+      return res.status(400).json({ error: 'profissional_obrigatorio', message: 'Escolha um profissional para estes servicos.' });

+    }

+

+    if (profissional_id != null) {

+      const [[profRow]] = await pool.query(

+        'SELECT id, nome, avatar_url, ativo FROM profissionais WHERE id= AND estabelecimento_id=?',

+        [profissional_id, estabelecimento_id]

+      );

+      if (!profRow) {

+        return res.status(400).json({ error: 'profissional_invalido', message: 'Profissional nao encontrado para este estabelecimento.' });

+      }

+      if (!profRow.ativo) {

+        return res.status(400).json({ error: 'profissional_inativo', message: 'Profissional inativo.' });

+      }

+      if (requiresProfessional) {

+        const valid = servicesRequiringProfessional.every((id) => professionalMap.get(id)?.has(profissional_id));

+        if (!valid) {

+          return res.status(400).json({ error: 'profissional_servico', message: 'Profissional nao esta associado a todos os servicos selecionados.' });

+        }

+      }

+    }

+

+    const duracaoTotal = summary.duracaoTotal + APPOINTMENT_BUFFER_MIN;

+    if (!Number.isFinite(duracaoTotal) || duracaoTotal <= 0) return res.status(400).json({ error: 'duracao_invalida' });

+    const fimDate = new Date(inicioDate.getTime() + duracaoTotal * 60_000);

+    const expediente = await getExpediente({

+      db: pool,

+      estabelecimentoId: estabelecimento_id,

+      dateUtc: inicioDate,

+    });

+    const { startMin, endMin, spansDays } = getLocalRangeMinutes(inicioDate, fimDate);

+    if (!assertDentroExpediente({

+      startMin,

+      endMin,

+      abre: expediente.abre,

+      fecha: expediente.fecha,

+      spansDays,

+      breaks: expediente.breaks,

+    })) {

+      return res.status(400).json({ error: 'outside_business_hours', message: formatExpedienteMessage(expediente) });

+    }

+    const planConfig = planContext?.config;

+    const limitCheck = await checkMonthlyAppointmentLimit({

+      estabelecimentoId: estabelecimento_id,

+      planConfig,

+      appointmentDate: inicioDate,

+    });

+    if (!limitCheck.ok) {

+      (async () => {

+        try {

+          await notifyAppointmentLimitReached({

+            estabelecimentoId: estabelecimento_id,

+            limit: limitCheck.limit,

+            total: limitCheck.total,

+            range: limitCheck.range,

+            planConfig,

+          });

+        } catch (e) {

+          console.warn('[agendamentos_public][limit_notify]', e?.message || e);

+        }

+      })();

+      return res.status(403).json({

+        error: 'plan_limit_agendamentos',

+        message: formatPlanLimitExceeded(planConfig, 'appointments') || 'Limite de agendamentos atingido para este mes.',

+        details: { limit: limitCheck.limit, total: limitCheck.total, month: limitCheck.range?.label || null },

+      });

+    }

+

+    const emailNorm = String(email).trim().toLowerCase();

+    const telDigits = toDigits(telefone);

+    const telNorm = normalizePhoneBR(telefone);

+

+    // OTP opcional (exigido via flag)

+    const requireOtp = /^(1|true)$/i.test(String(process.env.PUBLIC_BOOKING_REQUIRE_OTP || ''));

+    if (requireOtp) {

+      const token = String(req.headers['x-otp-token'] || otp_token || '');

+      const secret = process.env.JWT_SECRET;

+      if (!token || !secret) return res.status(400).json({ error: 'otp_required' });

+      try {

+        const payload = jwt.verify(token, secret);

+        if (payload?.scope !== 'otp') throw new Error('bad_scope');

+        const ok = (payload.ch === 'email' && String(payload.v || '').toLowerCase() === emailNorm) ||

+                  (payload.ch === 'phone' && String(payload.v || '') === telDigits);

+        if (!ok) return res.status(400).json({ error: 'otp_mismatch' });

+      } catch (e) {

+        return res.status(400).json({ error: 'otp_invalid' });

+      }

+    }

+

+    // resolve/ cria cliente guest via email (preferencia) ou telefone

+

+    let userId = null;

+    let userByEmail = null;

+    let userByPhone = null;

+    {

+      const [urows] = await pool.query(

+        'SELECT id, nome, email, telefone FROM usuarios WHERE LOWER(email)= LIMIT 1',

+        [emailNorm]

+      );

+      if (urows.length) userByEmail = urows[0];

+    }

+    if (telNorm || telDigits) {

+      const candidates = [];

+      if (telNorm) candidates.push(telNorm);

+      if (telDigits && telDigits !== telNorm) candidates.push(telDigits);

+      for (const candidate of candidates) {

+        const [urows] = await pool.query(

+          'SELECT id, nome, email, telefone FROM usuarios WHERE telefone= LIMIT 1',

+          [candidate]

+        );

+        if (urows.length) {

+          userByPhone = urows[0];

+          break;

+        }

+      }

+    }

+    if (userByEmail && userByPhone && userByEmail.id !== userByPhone.id) {

+      return res.status(409).json({

+        error: 'cliente_conflito',

+        message: 'Já existe cliente com este email ou telefone. Revise os dados antes de continuar.',

+      });

+    }

+    const existingUser = userByEmail || userByPhone;

+    if (existingUser) {

       const existingEmail = existingUser.email ? String(existingUser.email).trim().toLowerCase() : '';
-      const existingPhone = existingUser.telefone ? normalizePhoneBR(existingUser.telefone) : '';
-      const emailMismatch = existingEmail && emailNorm && existingEmail !== emailNorm;
-      const phoneMismatch = existingPhone && telNorm && existingPhone !== telNorm;
-      if (emailMismatch || phoneMismatch) {
-        return res.status(409).json({
-          error: 'cliente_conflito',
-          message: 'Já existe cliente com este email ou telefone. Revise os dados antes de continuar.',
-        });
-      }
-      userId = existingUser.id;
-    }
-    if (!userId) {
-      const hash = await bcrypt.hash(Math.random().toString(36), 10);
-      const [r] = await pool.query(
-        "INSERT INTO usuarios (nome, email, telefone, data_nascimento, cep, endereco, numero, complemento, bairro, cidade, estado, senha_hash, tipo) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,'cliente')",
-        [
-          String(nome).slice(0,120),
-          emailNorm,
-          telNorm || null,
-          dataNascimentoValue,
-          cepDigits || null,
-          enderecoTrim || null,
-          numeroTrim || null,
-          complementoTrim || null,
-          bairroTrim || null,
-          cidadeTrim || null,
-          estadoTrim || null,
-          hash,
-        ]
-      );
-      userId = r.insertId;
-    } else {
-      try {
-        const updates = ['nome=COALESCE(nome,?)'];
-        const params = [String(nome).slice(0,120)];
-        if (telNorm) {
-          updates.push('telefone=?');
-          params.push(telNorm);
-        }
-        if (dataNascimentoValue) {
-          updates.push('data_nascimento=COALESCE(data_nascimento,?)');
-          params.push(dataNascimentoValue);
-        }
-        if (cepDigits) {
-          updates.push('cep=COALESCE(cep,?)');
-          params.push(cepDigits);
-        }
-        if (enderecoTrim) {
-          updates.push('endereco=COALESCE(endereco,?)');
-          params.push(enderecoTrim);
-        }
-        if (numeroTrim) {
-          updates.push('numero=COALESCE(numero,?)');
-          params.push(numeroTrim);
-        }
-        if (complementoTrim) {
-          updates.push('complemento=COALESCE(complemento,?)');
-          params.push(complementoTrim);
-        }
-        if (bairroTrim) {
-          updates.push('bairro=COALESCE(bairro,?)');
-          params.push(bairroTrim);
-        }
-        if (cidadeTrim) {
-          updates.push('cidade=COALESCE(cidade,?)');
-          params.push(cidadeTrim);
-        }
-        if (estadoTrim) {
-          updates.push('estado=COALESCE(estado,?)');
-          params.push(estadoTrim);
-        }
-        if (updates.length) {
-          await pool.query(`UPDATE usuarios SET ${updates.join(', ')} WHERE id=?`, [...params, userId]);
-        }
-      } catch {}
-    }
-
-    conn = await pool.getConnection();
-    await conn.beginTransaction();
-    txStarted = true;
-
-    let conflictSql = `SELECT id FROM agendamentos
-       WHERE estabelecimento_id=? AND status IN ('confirmado','pendente')
-         AND (status <> 'pendente' OR public_confirm_expires_at IS NULL OR public_confirm_expires_at >= NOW())
-         AND (inicio < ? AND fim > ?)`;
-    const conflictParams = [estabelecimento_id, fimDate, inicioDate];
-    if (profissional_id != null && requiresProfessional) {
-      conflictSql += ' AND (profissional_id IS NULL OR profissional_id=?)';
-      conflictParams.push(profissional_id);
-    }
-    conflictSql += ' FOR UPDATE';
-    const [conf] = await conn.query(conflictSql, conflictParams);
-    if (conf.length) {
-      if (txStarted && conn) {
-        await conn.rollback();
-      }
-      conn.release();
-      return res.status(409).json({ error: 'slot_ocupado' });
-    }
-
-    const origem =
-      normalizeOrigem(
-        req.body?.origem ??
-        req.body?.canal ??
-        req.body?.channel ??
-        req.body?.utm_source ??
-        req.body?.utmSource ??
-        req.body?.source ??
-        req.query?.origem ??
-        req.query?.canal ??
-        req.query?.utm_source ??
-        req.query?.utmSource ??
-        req.query?.source
-      ) || 'site';
-
-    const [ins] = await conn.query(
-      `INSERT INTO agendamentos
-        (cliente_id, estabelecimento_id, servico_id, profissional_id, inicio, fim, status, origem, public_confirm_token_hash, public_confirm_expires_at, public_confirmed_at)
-       VALUES (?,?,?,?,?,?, 'confirmado', ?, NULL, NULL, NOW())`,
-      [userId, estabelecimento_id, primaryServiceId, profissional_id || null, inicioDate, fimDate, origem]
-    );
-    const itemValues = serviceItems.map((item, idx) => ([
-      ins.insertId,
-      item.id,
-      idx + 1,
-      Math.max(0, Math.round(item.duracao_min || 0)),
-      Math.max(0, Math.round(item.preco_centavos || 0)),
-    ]));
-    if (itemValues.length) {
-      const placeholders = itemValues.map(() => '(?,?,?,?,?)').join(',');
-      await conn.query(
-        `INSERT INTO agendamento_itens (agendamento_id, servico_id, ordem, duracao_min, preco_snapshot) VALUES ${placeholders}`,
-        itemValues.flat()
-      );
-    }
-
-    await conn.commit();
-    txStarted = false;
-    conn.release(); conn = null;
-
-    // Notificacoes de confirmacao (best-effort)
-    (async () => {
-      try {
-        await notifyPublicConfirmedAppointment(ins.insertId);
-      } catch {}
-    })();
-
-    return res.status(201).json({
-      id: ins.insertId,
-      cliente_id: userId,
-      estabelecimento_id,
-      servico_id: primaryServiceId,
-      servico_ids: summary.serviceIds,
-      servico_nome: summary.serviceLabel || serviceLabel,
-      servicos: serviceItems,
-      duracao_total: summary.duracaoTotal,
-      preco_total: summary.precoTotal,
-      profissional_id: profissional_id || null,
-      inicio: inicioDate,
-      fim: fimDate,
-      status: 'confirmado',
-      confirm_expires_at: null,
-    });
-  } catch (e) {
-    try { if (txStarted && conn) await conn.rollback(); } catch {}
-    try { if (conn) conn.release(); } catch {}
-    console.error('[public/agendamentos][POST]', e);
-    return res.status(500).json({ error: 'server_error' });
-  }
-});
-
-// GET /public/agendamentos/confirm?token=...
-router.get('/confirm', async (req, res) => {
-  try {
-    const token = String(req.query?.token || '').trim();
-    if (!token) {
-      return res.status(400).send(renderConfirmPage({
-        title: 'Token invalido',
-        message: 'Link de confirmacao invalido ou ausente.',
-      }));
-    }
-    const tokenHash = hashToken(token);
-    const [[ag]] = await pool.query(
-      'SELECT id, status, public_confirm_expires_at FROM agendamentos WHERE public_confirm_token_hash=? LIMIT 1',
-      [tokenHash]
-    );
-    if (!ag) {
-      return res.status(404).send(renderConfirmPage({
-        title: 'Agendamento nao encontrado',
-        message: 'Este link nao e valido ou ja expirou.',
-      }));
-    }
-    if (ag.status === 'confirmado') {
-      return res.status(200).send(renderConfirmPage({
-        title: 'Agendamento confirmado',
-        message: 'Seu agendamento ja estava confirmado.',
-      }));
-    }
-    if (ag.status === 'cancelado') {
-      return res.status(410).send(renderConfirmPage({
-        title: 'Confirmacao expirada',
-        message: 'Este agendamento foi cancelado por falta de confirmacao.',
-      }));
-    }
-    if (ag.public_confirm_expires_at && new Date(ag.public_confirm_expires_at).getTime() < Date.now()) {
-      await pool.query(
-        "UPDATE agendamentos SET status='cancelado' WHERE id=? AND status='pendente'",
-        [ag.id]
-      );
-      return res.status(410).send(renderConfirmPage({
-        title: 'Confirmacao expirada',
-        message: 'Este agendamento foi cancelado por falta de confirmacao.',
-      }));
-    }
-
-    const [r] = await pool.query(
-      "UPDATE agendamentos SET status='confirmado', public_confirmed_at=NOW(), public_confirm_expires_at=NULL WHERE id=? AND status='pendente'",
-      [ag.id]
-    );
-    if (r?.affectedRows) {
-      notifyPublicConfirmedAppointment(ag.id);
-    }
-    return res.status(200).send(renderConfirmPage({
-      title: 'Agendamento confirmado',
-      message: 'Confirmacao registrada com sucesso.',
-    }));
-  } catch (e) {
-    console.error('[public/agendamentos][confirm]', e?.message || e);
-    return res.status(500).send(renderConfirmPage({
-      title: 'Erro na confirmacao',
-      message: 'Nao foi possivel confirmar agora. Tente novamente.',
-    }));
-  }
-});
-
-export default router;
-
+      const existingPhone = existingUser.telefone  normalizePhoneBR(existingUser.telefone) : '';

+      const emailMismatch = existingEmail && emailNorm && existingEmail !== emailNorm;

+      const phoneMismatch = existingPhone && telNorm && existingPhone !== telNorm;

+      if (emailMismatch || phoneMismatch) {

+        return res.status(409).json({

+          error: 'cliente_conflito',

+          message: 'Já existe cliente com este email ou telefone. Revise os dados antes de continuar.',

+        });

+      }

+      userId = existingUser.id;

+    }

+    if (!userId) {

+      const hash = await bcrypt.hash(Math.random().toString(36), 10);

+      const [r] = await pool.query(

+        "INSERT INTO usuarios (nome, email, telefone, data_nascimento, cep, endereco, numero, complemento, bairro, cidade, estado, senha_hash, tipo) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,'cliente')",

+        [

+          String(nome).slice(0,120),

+          emailNorm,

+          telNorm || null,

+          dataNascimentoValue,

+          cepDigits || null,

+          enderecoTrim || null,

+          numeroTrim || null,

+          complementoTrim || null,

+          bairroTrim || null,

+          cidadeTrim || null,

+          estadoTrim || null,

+          hash,

+        ]

+      );

+      userId = r.insertId;

+    } else {

+      try {

+        const updates = ['nome=COALESCE(nome,?)'];

+        const params = [String(nome).slice(0,120)];

+        if (telNorm) {

+          updates.push('telefone=?');

+          params.push(telNorm);

+        }

+        if (dataNascimentoValue) {

+          updates.push('data_nascimento=COALESCE(data_nascimento,?)');

+          params.push(dataNascimentoValue);

+        }

+        if (cepDigits) {

+          updates.push('cep=COALESCE(cep,?)');

+          params.push(cepDigits);

+        }

+        if (enderecoTrim) {

+          updates.push('endereco=COALESCE(endereco,?)');

+          params.push(enderecoTrim);

+        }

+        if (numeroTrim) {

+          updates.push('numero=COALESCE(numero,?)');

+          params.push(numeroTrim);

+        }

+        if (complementoTrim) {

+          updates.push('complemento=COALESCE(complemento,?)');

+          params.push(complementoTrim);

+        }

+        if (bairroTrim) {

+          updates.push('bairro=COALESCE(bairro,?)');

+          params.push(bairroTrim);

+        }

+        if (cidadeTrim) {

+          updates.push('cidade=COALESCE(cidade,?)');

+          params.push(cidadeTrim);

+        }

+        if (estadoTrim) {

+          updates.push('estado=COALESCE(estado,?)');

+          params.push(estadoTrim);

+        }

+        if (updates.length) {

+          await pool.query(`UPDATE usuarios SET ${updates.join(', ')} WHERE id=?`, [...params, userId]);

+        }

+      } catch {}

+    }

+

+    conn = await pool.getConnection();

+    await conn.beginTransaction();
+    txStarted = true;
+

+    let conflictSql = `SELECT id FROM agendamentos
+       WHERE estabelecimento_id= AND status IN ('confirmado','pendente','pendente_pagamento')
+         AND (
+           status = 'confirmado'
+           OR (status = 'pendente' AND (public_confirm_expires_at IS NULL OR public_confirm_expires_at >= NOW()))
+           OR (status = 'pendente_pagamento' AND (deposit_expires_at IS NULL OR deposit_expires_at >= NOW()))
+         )
+         AND (inicio <  AND fim > ?)`;
+    const conflictParams = [estabelecimento_id, fimDate, inicioDate];

+    if (profissional_id != null && requiresProfessional) {

+      conflictSql += ' AND (profissional_id IS NULL OR profissional_id=?)';

+      conflictParams.push(profissional_id);

+    }

+    conflictSql += ' FOR UPDATE';

+    const [conf] = await conn.query(conflictSql, conflictParams);

+    if (conf.length) {
+      if (txStarted && conn) {
+        await conn.rollback();
+      }
+      conn.release();
+      return res.status(409).json({ error: 'slot_ocupado' });
+    }
+

+    const origem =
+      normalizeOrigem(
+        req.body?.origem ?
+        req.body?.canal ?
+        req.body?.channel ?
+        req.body?.utm_source ?
+        req.body?.utmSource ?
+        req.body?.source ?
+        req.query?.origem ?
+        req.query?.canal ?
+        req.query?.utm_source ?
+        req.query?.utmSource ?
+        req.query?.source
+      ) || 'site';
+
+    let appointmentId = null;
+    let depositPaymentId = null;
+    if (depositRequired) {
+      const [ins] = await conn.query(
+        `INSERT INTO agendamentos
+          (cliente_id, estabelecimento_id, servico_id, profissional_id, inicio, fim, status, origem, total_centavos,
+           deposit_required, deposit_percent, deposit_centavos, deposit_expires_at)
+         VALUES (?,?,?,?,?,?,'pendente_pagamento', ?, ?, 1, ?, ?, ?)`,
+        [
+          userId,
+          estabelecimento_id,
+          primaryServiceId,
+          profissional_id || null,
+          inicioDate,
+          fimDate,
+          origem,
+          totalCentavos,
+          depositPercent,
+          depositCentavos,
+          depositExpiresAt,
+        ]
+      );
+      appointmentId = ins.insertId;
+      const [payIns] = await conn.query(
+        `INSERT INTO appointment_payments
+          (agendamento_id, estabelecimento_id, type, status, amount_centavos, percent, expires_at)
+         VALUES (?,?,?,?,?,?,?)`,
+        [
+          appointmentId,
+          estabelecimento_id,
+          'deposit',
+          'pending',
+          depositCentavos,
+          depositPercent,
+          depositExpiresAt,
+        ]
+      );
+      depositPaymentId = payIns.insertId;
+    } else {
+      const [ins] = await conn.query(
+        `INSERT INTO agendamentos
+          (cliente_id, estabelecimento_id, servico_id, profissional_id, inicio, fim, status, origem, public_confirm_token_hash,
+           public_confirm_expires_at, public_confirmed_at, total_centavos)
+         VALUES (?,?,?,?,?,?,'confirmado', ?, NULL, NULL, NOW(), ?)`,
+        [userId, estabelecimento_id, primaryServiceId, profissional_id || null, inicioDate, fimDate, origem, totalCentavos]
+      );
+      appointmentId = ins.insertId;
+    }
+    const itemValues = serviceItems.map((item, idx) => ([
+      appointmentId,
+      item.id,
+      idx + 1,
+      Math.max(0, Math.round(item.duracao_min || 0)),
+      Math.max(0, Math.round(item.preco_centavos || 0)),
+    ]));
+    if (itemValues.length) {

+      const placeholders = itemValues.map(() => '(?,?,?,?,?)').join(',');

+      await conn.query(

+        `INSERT INTO agendamento_itens (agendamento_id, servico_id, ordem, duracao_min, preco_snapshot) VALUES ${placeholders}`,

+        itemValues.flat()

+      );

+    }

+

+    await conn.commit();
+    txStarted = false;
+    conn.release(); conn = null;
+
+    if (depositRequired) {
+      const expiresIso = depositExpiresAt  depositExpiresAt.toISOString() : null;
+      const apiBase = resolveApiBaseUrl();
+      const externalReference = `dep:ag:${appointmentId}:pay:${depositPaymentId}:est:${estabelecimento_id}`;
+      const metadata = {
+        agendamento_id: String(appointmentId),
+        estabelecimento_id: String(estabelecimento_id),
+        type: 'deposit',
+      };
+        try {
+          const { payment, pix } = await createMercadoPagoPixPayment({
+            amountCents: depositCentavos,
+            description: `Sinal - ${serviceLabel}`,
+            externalReference,
+            metadata,
+            notificationUrl: `${apiBase}/payments/webhook`,
+            payerEmail: emailNorm || null,
+            expiresAt: depositExpiresAt,
+            accessToken: mpAccessToken,
+          });
+        await pool.query(
+          'UPDATE appointment_payments SET provider_payment_id=?, provider_reference=?, raw_payload= WHERE id=?',
+          [String(payment.id), externalReference, safeJson(payment), depositPaymentId]
+        );
+        return res.status(201).json({
+          id: appointmentId,
+          agendamentoId: appointmentId,
+          status: 'pendente_pagamento',
+          total_centavos: totalCentavos,
+          deposit_required: 1,
+          deposit_percent: depositPercent,
+          deposit_centavos: depositCentavos,
+          deposit_expires_at: expiresIso,
+          paymentId: depositPaymentId,
+          expiresAt: expiresIso,
+          pix_qr: pix?.qr_code_base64 || null,
+          pix_qr_raw: pix?.qr_code || null,
+          pix_copia_cola: pix?.copia_e_cola || pix?.qr_code || null,
+          pix_ticket_url: pix?.ticket_url || null,
+          amount_centavos: depositCentavos,
+          pix,
+        });
+      } catch (err) {
+        console.error('[public/agendamentos][deposit] erro ao criar PIX:', err?.message || err);
+        const payload = safeJson({ error: err?.message || String(err) });
+        await pool.query(
+          'UPDATE appointment_payments SET status=?, raw_payload= WHERE id=?',
+          ['failed', payload, depositPaymentId]
+        );
+        await pool.query(
+          "UPDATE agendamentos SET status='cancelado', deposit_expires_at=NOW() WHERE id= AND status='pendente_pagamento'",
+          [appointmentId]
+        );
+        return res.status(502).json({
+          error: 'payment_create_failed',
+          message: 'Nao foi possivel gerar o PIX do sinal. Tente novamente.',
+        });
+      }
+    }
+
+    // Notificacoes de confirmacao (best-effort)
+    (async () => {
+      try {
+        await notifyPublicConfirmedAppointment(appointmentId);
+      } catch {}
+    })();
+
+    return res.status(201).json({
+      id: appointmentId,
+      cliente_id: userId,
+      estabelecimento_id,
+      servico_id: primaryServiceId,
+      servico_ids: summary.serviceIds,

+      servico_nome: summary.serviceLabel || serviceLabel,

+      servicos: serviceItems,
+      duracao_total: summary.duracaoTotal,
+      preco_total: summary.precoTotal,
+      total_centavos: totalCentavos,
+      profissional_id: profissional_id || null,
+      inicio: inicioDate,
+      fim: fimDate,
+      status: 'confirmado',
+      confirm_expires_at: null,

+    });

+  } catch (e) {

+    try { if (txStarted && conn) await conn.rollback(); } catch {}
+    try { if (conn) conn.release(); } catch {}

+    console.error('[public/agendamentos][POST]', e);

+    return res.status(500).json({ error: 'server_error' });

+  }

+});

+

+// GET /public/agendamentos/confirm?token=...

+router.get('/confirm', async (req, res) => {

+  try {

+    const token = String(req.query?.token || '').trim();

+    if (!token) {

+      return res.status(400).send(renderConfirmPage({

+        title: 'Token invalido',

+        message: 'Link de confirmacao invalido ou ausente.',

+      }));

+    }

+    const tokenHash = hashToken(token);

+    const [[ag]] = await pool.query(

+      'SELECT id, status, public_confirm_expires_at FROM agendamentos WHERE public_confirm_token_hash= LIMIT 1',

+      [tokenHash]

+    );

+    if (!ag) {

+      return res.status(404).send(renderConfirmPage({

+        title: 'Agendamento nao encontrado',

+        message: 'Este link nao e valido ou ja expirou.',

+      }));

+    }

+    if (ag.status === 'confirmado') {

+      return res.status(200).send(renderConfirmPage({

+        title: 'Agendamento confirmado',

+        message: 'Seu agendamento ja estava confirmado.',

+      }));

+    }

+    if (ag.status === 'cancelado') {

+      return res.status(410).send(renderConfirmPage({

+        title: 'Confirmacao expirada',

+        message: 'Este agendamento foi cancelado por falta de confirmacao.',

+      }));

+    }

+    if (ag.public_confirm_expires_at && new Date(ag.public_confirm_expires_at).getTime() < Date.now()) {

+      await pool.query(

+        "UPDATE agendamentos SET status='cancelado' WHERE id= AND status='pendente'",

+        [ag.id]

+      );

+      return res.status(410).send(renderConfirmPage({

+        title: 'Confirmacao expirada',

+        message: 'Este agendamento foi cancelado por falta de confirmacao.',

+      }));

+    }

+

+    const [r] = await pool.query(

+      "UPDATE agendamentos SET status='confirmado', public_confirmed_at=NOW(), public_confirm_expires_at=NULL WHERE id= AND status='pendente'",

+      [ag.id]

+    );

+    if (r?.affectedRows) {

+      notifyPublicConfirmedAppointment(ag.id);

+    }

+    return res.status(200).send(renderConfirmPage({

+      title: 'Agendamento confirmado',

+      message: 'Confirmacao registrada com sucesso.',

+    }));

+  } catch (e) {

+    console.error('[public/agendamentos][confirm]', e?.message || e);

+    return res.status(500).send(renderConfirmPage({

+      title: 'Erro na confirmacao',

+      message: 'Nao foi possivel confirmar agora. Tente novamente.',

+    }));

+  }

+});

+

+export default router;

+

diff --git a/backend/src/routes/auth.js b/backend/src/routes/auth.js
index ce5b268..4458d5c 100644
--- a/backend/src/routes/auth.js
+++ b/backend/src/routes/auth.js
@@ -1,843 +1,847 @@
-// backend/src/routes/auth.js
-import { Router } from 'express';
-import { pool } from '../lib/db.js';
-import bcrypt from 'bcryptjs';
-import jwt from 'jsonwebtoken';
-import { auth } from '../middleware/auth.js';
-import dotenv from 'dotenv'; dotenv.config();
-import { notifyEmail } from '../lib/notifications.js';
-import crypto from 'crypto';
-import { consumeLinkToken } from '../lib/wa_store.js';
-import { saveAvatarFromDataUrl, removeAvatarFile } from '../lib/avatar.js';
-import { MAX_TRIAL_DAYS } from '../lib/plans.js';
-
-const router = Router();
-const DAY_MS = 86400000;
-const TRIAL_PLANS = new Set(['starter', 'pro']);
-
-const toBool = (value) => {
-  if (value === true || value === false) return Boolean(value);
-  const num = Number(value);
-  if (!Number.isNaN(num)) return num !== 0;
-  if (typeof value === 'string') {
-    const norm = value.trim().toLowerCase();
-    if (['true', 'on', 'yes', 'sim', '1'].includes(norm)) return true;
-    if (['false', 'off', 'no', 'nao', '0'].includes(norm)) return false;
-  }
-  return false;
-};
-
-const normalizeBirthdate = (value) => {
-  if (value === undefined || value === null) return null;
-  const raw = String(value).trim();
-  if (!raw) return null;
-  const match = raw.match(/^(\d{4})-(\d{2})-(\d{2})$/);
-  if (!match) return null;
-  const year = Number(match[1]);
-  const month = Number(match[2]);
-  const day = Number(match[3]);
-  const dt = new Date(year, month - 1, day);
-  if (
-    Number.isNaN(dt.getTime()) ||
-    dt.getFullYear() !== year ||
-    dt.getMonth() + 1 !== month ||
-    dt.getDate() !== day
-  ) {
-    return null;
-  }
-  return `${match[1]}-${match[2]}-${match[3]}`;
-};
-
-const normalizeCpfCnpj = (value) => {
-  if (value === undefined || value === null) return { digits: null, provided: false };
-  const raw = String(value).trim();
-  if (!raw) return { digits: '', provided: true };
-  const digits = raw.replace(/\D/g, '');
-  return { digits, provided: true };
-};
-
-router.post('/register', async (req, res) => {
-  try {
-    const {
-      nome,
-      email,
-      senha,
-      tipo,
-      telefone,
-      cep,
-      endereco,
-      numero,
-      complemento,
-      bairro,
-      cidade,
-      estado,
-      data_nascimento,
-      dataNascimento,
-      notifyEmailEstab,
-      notifyWhatsappEstab,
-    } = req.body || {};
-
-    if (!nome || !email || !senha || !['cliente','estabelecimento'].includes(tipo)) {
-      return res.status(400).json({ error: 'invalid_payload' });
-    }
-
-    const telefoneTrim = telefone === undefined || telefone === null ? null : String(telefone).trim();
-    if (!telefoneTrim) {
-      return res.status(400).json({ error: 'telefone_obrigatorio', message: 'Informe um telefone com DDD.' });
-    }
-    if (telefoneTrim.length > 20) {
-      return res.status(400).json({ error: 'telefone_invalido' });
-    }
-
-    const nomeTrim = String(nome).trim();
-    const emailTrim = String(email).trim();
-    const emailNorm = emailTrim.toLowerCase();
-    const cepDigits = (cep ? String(cep) : '').replace(/[^0-9]/g, '').slice(0, 8);
-    const enderecoTrim = endereco ? String(endereco).trim() : '';
-    const numeroTrim = numero ? String(numero).trim() : '';
-    const complementoTrim = complemento ? String(complemento).trim() : '';
-    const bairroTrim = bairro ? String(bairro).trim() : '';
-    const cidadeTrim = cidade ? String(cidade).trim() : '';
-    const estadoTrim = estado ? String(estado).trim().toUpperCase() : '';
-    const dataNascimentoRaw = data_nascimento ?? dataNascimento;
-    const dataNascimentoValue = normalizeBirthdate(dataNascimentoRaw);
-    if (dataNascimentoRaw && String(dataNascimentoRaw).trim() && !dataNascimentoValue) {
-      return res.status(400).json({ error: 'data_nascimento_invalida', message: 'Informe uma data de nascimento valida.' });
-    }
-
-    const cpfCnpjRaw = req.body?.cpf_cnpj ?? req.body?.cpfCnpj;
-    const { digits: cpfCnpjDigits } = normalizeCpfCnpj(cpfCnpjRaw);
-    if (cpfCnpjDigits && ![11, 14].includes(cpfCnpjDigits.length)) {
-      return res.status(400).json({ error: 'cpf_cnpj_invalido', message: 'Informe um CPF ou CNPJ valido.' });
-    }
+// backend/src/routes/auth.js

+import { Router } from 'express';

+import { pool } from '../lib/db.js';

+import bcrypt from 'bcryptjs';

+import jwt from 'jsonwebtoken';

+import { auth } from '../middleware/auth.js';

+import dotenv from 'dotenv'; dotenv.config();

+import { notifyEmail } from '../lib/notifications.js';

+import crypto from 'crypto';

+import { consumeLinkToken } from '../lib/wa_store.js';

+import { saveAvatarFromDataUrl, removeAvatarFile } from '../lib/avatar.js';

+import { MAX_TRIAL_DAYS } from '../lib/plans.js';

+

+const router = Router();

+const DAY_MS = 86400000;

+const TRIAL_PLANS = new Set(['starter', 'pro']);

+

+const toBool = (value) => {

+  if (value === true || value === false) return Boolean(value);

+  const num = Number(value);

+  if (!Number.isNaN(num)) return num !== 0;

+  if (typeof value === 'string') {

+    const norm = value.trim().toLowerCase();

+    if (['true', 'on', 'yes', 'sim', '1'].includes(norm)) return true;

+    if (['false', 'off', 'no', 'nao', '0'].includes(norm)) return false;

+  }

+  return false;

+};

+

+const normalizeBirthdate = (value) => {

+  if (value === undefined || value === null) return null;

+  const raw = String(value).trim();

+  if (!raw) return null;

+  const match = raw.match(/^(\d{4})-(\d{2})-(\d{2})$/);

+  if (!match) return null;

+  const year = Number(match[1]);

+  const month = Number(match[2]);

+  const day = Number(match[3]);

+  const dt = new Date(year, month - 1, day);

+  if (

+    Number.isNaN(dt.getTime()) ||

+    dt.getFullYear() !== year ||

+    dt.getMonth() + 1 !== month ||

+    dt.getDate() !== day

+  ) {

+    return null;

+  }

+  return `${match[1]}-${match[2]}-${match[3]}`;

+};

+

+const normalizeCpfCnpj = (value) => {

+  if (value === undefined || value === null) return { digits: null, provided: false };

+  const raw = String(value).trim();

+  if (!raw) return { digits: '', provided: true };

+  const digits = raw.replace(/\D/g, '');

+  return { digits, provided: true };

+};

+

+router.post('/register', async (req, res) => {

+  try {

+    const {

+      nome,

+      email,

+      senha,

+      tipo,

+      telefone,

+      cep,

+      endereco,

+      numero,

+      complemento,

+      bairro,

+      cidade,

+      estado,

+      data_nascimento,

+      dataNascimento,

+      notifyEmailEstab,

+      notifyWhatsappEstab,

+    } = req.body || {};

+

+    if (!nome || !email || !senha || !['cliente','estabelecimento'].includes(tipo)) {

+      return res.status(400).json({ error: 'invalid_payload' });

+    }

+

+    const telefoneTrim = telefone == null ? null : String(telefone).trim();
+    if (!telefoneTrim) {

+      return res.status(400).json({ error: 'telefone_obrigatorio', message: 'Informe um telefone com DDD.' });

+    }

+    if (telefoneTrim.length > 20) {

+      return res.status(400).json({ error: 'telefone_invalido' });

+    }

+

+    const nomeTrim = String(nome).trim();

+    const emailTrim = String(email).trim();

+    const emailNorm = emailTrim.toLowerCase();

+    const cepDigits = (cep == null ? '' : String(cep))
+      .replace(/[^0-9]/g, '')
+      .slice(0, 8);
+    const enderecoTrim = endereco == null ? '' : String(endereco).trim();
+    const numeroTrim = numero == null ? '' : String(numero).trim();
+    const complementoTrim = complemento == null ? '' : String(complemento).trim();
+    const bairroTrim = bairro == null ? '' : String(bairro).trim();
+    const cidadeTrim = cidade == null ? '' : String(cidade).trim();
+    const estadoTrim = estado == null ? '' : String(estado).trim().toUpperCase();
+    const dataNascimentoRaw = data_nascimento || dataNascimento;
+    const dataNascimentoValue = normalizeBirthdate(dataNascimentoRaw);

+    if (dataNascimentoRaw && String(dataNascimentoRaw).trim() && !dataNascimentoValue) {

+      return res.status(400).json({ error: 'data_nascimento_invalida', message: 'Informe uma data de nascimento valida.' });

+    }

+

+    const cpfCnpjRaw = req.body?.cpf_cnpj || req.body?.cpfCnpj;
+    const { digits: cpfCnpjDigits } = normalizeCpfCnpj(cpfCnpjRaw);

+    if (cpfCnpjDigits && ![11, 14].includes(cpfCnpjDigits.length)) {

+      return res.status(400).json({ error: 'cpf_cnpj_invalido', message: 'Informe um CPF ou CNPJ valido.' });

+    }

     const cpfCnpjValue = cpfCnpjDigits ? cpfCnpjDigits : null;
-
-    if (tipo === 'estabelecimento') {
-      if (cepDigits.length !== 8) {
-        return res.status(400).json({ error: 'cep_invalido', message: 'Informe um CEP válido com 8 dígitos.' });
-      }
-      if (!enderecoTrim) {
-        return res.status(400).json({ error: 'endereco_obrigatorio', message: 'Informe o endereço do estabelecimento.' });
-      }
-      if (!numeroTrim) {
-        return res.status(400).json({ error: 'numero_obrigatorio', message: 'Informe o número do endereço.' });
-      }
-      if (!bairroTrim) {
-        return res.status(400).json({ error: 'bairro_obrigatorio', message: 'Informe o bairro do endereço.' });
-      }
-      if (!cidadeTrim) {
-        return res.status(400).json({ error: 'cidade_obrigatoria', message: 'Informe a cidade.' });
-      }
-      if (!/^[A-Z]{2}$/.test(estadoTrim)) {
-        return res.status(400).json({ error: 'estado_invalido', message: 'Informe a UF com 2 letras.' });
-      }
-    } else {
-      if (cepDigits.length && cepDigits.length !== 8) {
-        return res.status(400).json({ error: 'cep_invalido', message: 'Informe um CEP válido com 8 dígitos.' });
-      }
-      if (estadoTrim && !/^[A-Z]{2}$/.test(estadoTrim)) {
-        return res.status(400).json({ error: 'estado_invalido', message: 'Informe a UF com 2 letras.' });
-      }
-    }
-
-    const [rows] = await pool.query('SELECT id FROM usuarios WHERE LOWER(email)=? LIMIT 1', [emailNorm]);
-    if (rows.length) return res.status(400).json({ error: 'email_exists' });
-
-    const now = new Date();
-    const normalizedRequestedPlan = String(req.body?.trial_plan || req.body?.plan || '').trim().toLowerCase();
+

+    if (tipo === 'estabelecimento') {

+      if (cepDigits.length !== 8) {

+        return res.status(400).json({ error: 'cep_invalido', message: 'Informe um CEP válido com 8 dígitos.' });

+      }

+      if (!enderecoTrim) {

+        return res.status(400).json({ error: 'endereco_obrigatorio', message: 'Informe o endereço do estabelecimento.' });

+      }

+      if (!numeroTrim) {

+        return res.status(400).json({ error: 'numero_obrigatorio', message: 'Informe o número do endereço.' });

+      }

+      if (!bairroTrim) {

+        return res.status(400).json({ error: 'bairro_obrigatorio', message: 'Informe o bairro do endereço.' });

+      }

+      if (!cidadeTrim) {

+        return res.status(400).json({ error: 'cidade_obrigatoria', message: 'Informe a cidade.' });

+      }

+      if (!/^[A-Z]{2}$/.test(estadoTrim)) {

+        return res.status(400).json({ error: 'estado_invalido', message: 'Informe a UF com 2 letras.' });

+      }

+    } else {

+      if (cepDigits.length && cepDigits.length !== 8) {

+        return res.status(400).json({ error: 'cep_invalido', message: 'Informe um CEP válido com 8 dígitos.' });

+      }

+      if (estadoTrim && !/^[A-Z]{2}$/.test(estadoTrim)) {

+        return res.status(400).json({ error: 'estado_invalido', message: 'Informe a UF com 2 letras.' });

+      }

+    }

+

+    const [rows] = await pool.query('SELECT id FROM usuarios WHERE LOWER(email)= LIMIT 1', [emailNorm]);

+    if (rows.length) return res.status(400).json({ error: 'email_exists' });

+

+    const now = new Date();

+    const normalizedRequestedPlan = String(req.body?.trial_plan || req.body?.plan || '').trim().toLowerCase();

     const planForTrial = TRIAL_PLANS.has(normalizedRequestedPlan) ? normalizedRequestedPlan : 'starter';
-    const trialEndsAt =
-      tipo === 'estabelecimento' && MAX_TRIAL_DAYS > 0
-        ? new Date(now.getTime() + MAX_TRIAL_DAYS * DAY_MS)
-        : null;
-
-    const hash = await bcrypt.hash(String(senha), 10);
-    const [r] = await pool.query(
-      'INSERT INTO usuarios (nome, email, telefone, data_nascimento, cpf_cnpj, cep, endereco, numero, complemento, bairro, cidade, estado, avatar_url, senha_hash, tipo) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
-      [
-        nomeTrim,
-        emailTrim,
-        telefoneTrim || null,
-        dataNascimentoValue,
-        cpfCnpjValue,
-        cepDigits || null,
-        enderecoTrim || null,
-        numeroTrim || null,
-        complementoTrim || null,
-        bairroTrim || null,
-        cidadeTrim || null,
-        estadoTrim || null,
-        null,
-        hash,
-        tipo,
-      ]
-    );
-
-    if (trialEndsAt) {
-      try {
-        await pool.query(
-          'UPDATE usuarios SET plan=?, plan_status=?, plan_trial_ends_at=? WHERE id=?',
-          [planForTrial, 'trialing', trialEndsAt, r.insertId]
-        );
-      } catch (err) {
-        console.error('[auth/register] failed to set trial end', err);
-      }
-    }
-
-    const secret = process.env.JWT_SECRET;
-    if (!secret) return res.status(500).json({ error: 'server_config', message: 'JWT_SECRET ausente.' });
-
-    const user = {
-      id: r.insertId,
-      nome: nomeTrim,
-      email: emailTrim,
-      telefone: telefoneTrim || null,
-      data_nascimento: dataNascimentoValue,
-      cpf_cnpj: cpfCnpjValue,
-      cep: cepDigits || null,
-      endereco: enderecoTrim || null,
-      numero: numeroTrim || null,
-      complemento: complementoTrim || null,
-      bairro: bairroTrim || null,
-      cidade: cidadeTrim || null,
-      estado: estadoTrim || null,
-      tipo,
-      plan: planForTrial,
-      notify_email_estab: tipo === 'estabelecimento',
-      notify_whatsapp_estab: tipo === 'estabelecimento',
-      plan_status: 'trialing',
+    const trialEndsAt =

+      tipo === 'estabelecimento' && MAX_TRIAL_DAYS > 0

+         new Date(now.getTime() + MAX_TRIAL_DAYS * DAY_MS)

+        : null;

+

+    const hash = await bcrypt.hash(String(senha), 10);

+    const [r] = await pool.query(

+      'INSERT INTO usuarios (nome, email, telefone, data_nascimento, cpf_cnpj, cep, endereco, numero, complemento, bairro, cidade, estado, avatar_url, senha_hash, tipo) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',

+      [

+        nomeTrim,

+        emailTrim,

+        telefoneTrim || null,

+        dataNascimentoValue,

+        cpfCnpjValue,

+        cepDigits || null,

+        enderecoTrim || null,

+        numeroTrim || null,

+        complementoTrim || null,

+        bairroTrim || null,

+        cidadeTrim || null,

+        estadoTrim || null,

+        null,

+        hash,

+        tipo,

+      ]

+    );

+

+    if (trialEndsAt) {

+      try {

+        await pool.query(

+          'UPDATE usuarios SET plan=?, plan_status=?, plan_trial_ends_at= WHERE id=?',

+          [planForTrial, 'trialing', trialEndsAt, r.insertId]

+        );

+      } catch (err) {

+        console.error('[auth/register] failed to set trial end', err);

+      }

+    }

+

+    const secret = process.env.JWT_SECRET;

+    if (!secret) return res.status(500).json({ error: 'server_config', message: 'JWT_SECRET ausente.' });

+

+    const user = {

+      id: r.insertId,

+      nome: nomeTrim,

+      email: emailTrim,

+      telefone: telefoneTrim || null,

+      data_nascimento: dataNascimentoValue,

+      cpf_cnpj: cpfCnpjValue,

+      cep: cepDigits || null,

+      endereco: enderecoTrim || null,

+      numero: numeroTrim || null,

+      complemento: complementoTrim || null,

+      bairro: bairroTrim || null,

+      cidade: cidadeTrim || null,

+      estado: estadoTrim || null,

+      tipo,

+      plan: planForTrial,

+      notify_email_estab: tipo === 'estabelecimento',

+      notify_whatsapp_estab: tipo === 'estabelecimento',

+      plan_status: 'trialing',

       plan_trial_ends_at: trialEndsAt ? trialEndsAt.toISOString() : null,
-      plan_active_until: null,
-      plan_subscription_id: null,
-    };
-
-    const maskPhoneForDisplay = (value) => {
-      if (!value) return '-';
-      const digits = String(value).replace(/\D/g, '');
-      if (!digits) return '-';
-      if (digits.length <= 4) return '*'.repeat(digits.length);
-      const prefix = digits.slice(0, 2);
-      const suffix = digits.slice(-2);
-      const middleLength = digits.length - prefix.length - suffix.length;
-      const middleMasked = '*'.repeat(Math.max(0, middleLength));
-      return `${prefix}${middleMasked}${suffix}`;
-    };
-    const telefoneDisplay = maskPhoneForDisplay(telefoneTrim);
-
-    // Emails de boas-vindas/alerta
-    try {
-      const adminEmail = process.env.NEW_USER_ALERT_EMAIL || 'servicos.negocios.digital@gmail.com';
-      const planKey = (planForTrial || 'starter').toString().toLowerCase();
-      const planLabel = (planForTrial || 'starter').toString().toLowerCase() === 'pro' ? 'Pro' : 'Starter';
-
-      const subjectUser = 'Bem-vindo(a) ao Agendamentos Online';
-      const isEstabelecimento = tipo === 'estabelecimento';
-      const htmlUser = `
-        <p>Oi, ${nomeTrim}!</p>
-        <p>Seu cadastro foi criado com sucesso.</p>
-        <ul>
+      plan_active_until: null,

+      plan_subscription_id: null,

+    };

+

+    const maskPhoneForDisplay = (value) => {

+      if (!value) return '-';

+      const digits = String(value).replace(/\D/g, '');

+      if (!digits) return '-';

+      if (digits.length <= 4) return '*'.repeat(digits.length);

+      const prefix = digits.slice(0, 2);

+      const suffix = digits.slice(-2);

+      const middleLength = digits.length - prefix.length - suffix.length;

+      const middleMasked = '*'.repeat(Math.max(0, middleLength));

+      return `${prefix}${middleMasked}${suffix}`;

+    };

+    const telefoneDisplay = maskPhoneForDisplay(telefoneTrim);

+

+    // Emails de boas-vindas/alerta

+    try {

+      const adminEmail = process.env.NEW_USER_ALERT_EMAIL || 'servicos.negocios.digital@gmail.com';

+      const planKey = (planForTrial || 'starter').toString().toLowerCase();

+    const planLabel = (planForTrial || 'starter').toString().toLowerCase() === 'pro' ? 'Pro' : 'Starter';
+

+      const subjectUser = 'Bem-vindo(a) ao Agendamentos Online';

+      const isEstabelecimento = tipo === 'estabelecimento';

+      const htmlUser = `

+        <p>Oi, ${nomeTrim}!</p>

+        <p>Seu cadastro foi criado com sucesso.</p>

+        <ul>

           ${isEstabelecimento ? `<li>Plano: ${planLabel} (teste grátis habilitado para estabelecimentos)</li>` : ''}
-          <li>Email: ${emailTrim}</li>
-          <li>Telefone: ${telefoneDisplay}</li>
-        </ul>
-        ${
-          isEstabelecimento
-            ? `
-        <p><strong>Acesse o painel e siga estes passos:</strong></p>
-        <ol>
-          <li>Cadastre seus profissionais</li>
-          <li>Cadastre seus serviços</li>
-          <li>Compartilhe seu link de agendamento com seus clientes</li>
-        </ol>
-        `
-            : ''
-        }
-        <p>Conte com a gente para agilizar seus agendamentos.</p>
-      `;
-      const subjectAdmin = 'Novo cadastro no Agendamentos Online';
-      const htmlAdmin = `
-        <p>Um novo usuário se cadastrou.</p>
-        <ul>
-          <li>Nome: ${nomeTrim}</li>
-          <li>Email: ${emailTrim}</li>
-          <li>Telefone: ${telefoneTrim || '-'}</li>
-          <li>Tipo: ${tipo}</li>
-          <li>CEP: ${cepDigits || '-'}</li>
-          <li>Cidade/UF: ${cidadeTrim || '-'} / ${estadoTrim || '-'}</li>
-        </ul>
-      `;
-
-      const emailJobs = [
-        { name: 'user', promise: notifyEmail(emailTrim, subjectUser, htmlUser) },
-      ];
-      if (adminEmail) {
-        emailJobs.push({ name: 'admin', promise: notifyEmail(adminEmail, subjectAdmin, htmlAdmin) });
-      }
-
-      const results = await Promise.allSettled(emailJobs.map((job) => job.promise));
-      results.forEach((result, index) => {
-        const job = emailJobs[index];
-        if (result.status === 'rejected') {
-          console.warn(`[welcome_email][${job.name}] falhou`, result.reason?.message || result.reason);
-        } else {
-          console.log(`[welcome_email][${job.name}] ok`);
-        }
-      });
-    } catch (err) {
-      console.warn('[auth/register][welcome_email] falhou', err?.message || err);
-    }
-
-    const token = jwt.sign({ id: user.id, nome: nomeTrim, email: emailTrim, tipo }, secret, { expiresIn: '10h' });
-    res.json({ token, user });
-  } catch (e) {
-    console.error('[auth/register] erro:', e);
-    res.status(500).json({ error: 'server_error' });
-  }
-});
-
-
-
-router.post('/login', async (req, res) => {
-  try {
-    const emailRaw = req.body?.email;
-    const senha = req.body?.senha;
-    if (!emailRaw || !senha) {
-      return res.status(400).json({ error: 'missing_fields', message: 'Informe email e senha.' });
-    }
-    const email = String(emailRaw).trim().toLowerCase();
-
-    const [rows] = await pool.query(
-      'SELECT id, nome, email, telefone, data_nascimento, cpf_cnpj, cep, endereco, numero, complemento, bairro, cidade, estado, avatar_url, senha_hash, tipo, notify_email_estab, notify_whatsapp_estab, plan, plan_status, plan_trial_ends_at, plan_active_until, plan_subscription_id FROM usuarios WHERE LOWER(email)=? LIMIT 1',
-      [email]
-    );
-    if (!rows.length) return res.status(401).json({ error: 'invalid_credentials' });
-
-    const u = rows[0];
-    if (!u.senha_hash) {
-      return res.status(500).json({ error: 'user_password_not_configured' });
-    }
-
-    const ok = await bcrypt.compare(String(senha), String(u.senha_hash));
-    if (!ok) return res.status(401).json({ error: 'invalid_credentials' });
-
-    const secret = process.env.JWT_SECRET;
-    if (!secret) return res.status(500).json({ error: 'server_config', message: 'JWT_SECRET ausente.' });
-
-    const payload = { id: u.id, nome: u.nome, email: u.email, tipo: u.tipo || 'cliente' };
-    const token = jwt.sign(payload, secret, { expiresIn: '10h' });
-
-    const user = {
-      id: u.id,
-      nome: u.nome,
-      email: u.email,
-      telefone: u.telefone,
-      data_nascimento: u.data_nascimento || null,
-      cpf_cnpj: u.cpf_cnpj || null,
-      cep: u.cep || null,
-      endereco: u.endereco || null,
-      numero: u.numero || null,
-      complemento: u.complemento || null,
-      bairro: u.bairro || null,
-      cidade: u.cidade || null,
-      estado: u.estado || null,
-      avatar_url: u.avatar_url || null,
-      tipo: u.tipo || 'cliente',
-      notify_email_estab: toBool(u.notify_email_estab),
-      notify_whatsapp_estab: toBool(u.notify_whatsapp_estab),
-      plan: u.plan || 'starter',
-      plan_status: u.plan_status || 'trialing',
+          <li>Email: ${emailTrim}</li>

+          <li>Telefone: ${telefoneDisplay}</li>

+        </ul>

+        ${

+          isEstabelecimento

+             `

+        <p><strong>Acesse o painel e siga estes passos:</strong></p>

+        <ol>

+          <li>Cadastre seus profissionais</li>

+          <li>Cadastre seus serviços</li>

+          <li>Compartilhe seu link de agendamento com seus clientes</li>

+        </ol>

+        `

+            : ''

+        }

+        <p>Conte com a gente para agilizar seus agendamentos.</p>

+      `;

+      const subjectAdmin = 'Novo cadastro no Agendamentos Online';

+      const htmlAdmin = `

+        <p>Um novo usuário se cadastrou.</p>

+        <ul>

+          <li>Nome: ${nomeTrim}</li>

+          <li>Email: ${emailTrim}</li>

+          <li>Telefone: ${telefoneTrim || '-'}</li>

+          <li>Tipo: ${tipo}</li>

+          <li>CEP: ${cepDigits || '-'}</li>

+          <li>Cidade/UF: ${cidadeTrim || '-'} / ${estadoTrim || '-'}</li>

+        </ul>

+      `;

+

+      const emailJobs = [

+        { name: 'user', promise: notifyEmail(emailTrim, subjectUser, htmlUser) },

+      ];

+      if (adminEmail) {

+        emailJobs.push({ name: 'admin', promise: notifyEmail(adminEmail, subjectAdmin, htmlAdmin) });

+      }

+

+      const results = await Promise.allSettled(emailJobs.map((job) => job.promise));

+      results.forEach((result, index) => {

+        const job = emailJobs[index];

+        if (result.status === 'rejected') {

+          console.warn(`[welcome_email][${job.name}] falhou`, result.reason?.message || result.reason);

+        } else {

+          console.log(`[welcome_email][${job.name}] ok`);

+        }

+      });

+    } catch (err) {

+      console.warn('[auth/register][welcome_email] falhou', err?.message || err);

+    }

+

+    const token = jwt.sign({ id: user.id, nome: nomeTrim, email: emailTrim, tipo }, secret, { expiresIn: '10h' });

+    res.json({ token, user });

+  } catch (e) {

+    console.error('[auth/register] erro:', e);

+    res.status(500).json({ error: 'server_error' });

+  }

+});

+

+

+

+router.post('/login', async (req, res) => {

+  try {

+    const emailRaw = req.body?.email;

+    const senha = req.body?.senha;

+    if (!emailRaw || !senha) {

+      return res.status(400).json({ error: 'missing_fields', message: 'Informe email e senha.' });

+    }

+    const email = String(emailRaw).trim().toLowerCase();

+

+    const [rows] = await pool.query(

+      'SELECT id, nome, email, telefone, data_nascimento, cpf_cnpj, cep, endereco, numero, complemento, bairro, cidade, estado, avatar_url, senha_hash, tipo, notify_email_estab, notify_whatsapp_estab, plan, plan_status, plan_trial_ends_at, plan_active_until, plan_subscription_id FROM usuarios WHERE LOWER(email)= LIMIT 1',

+      [email]

+    );

+    if (!rows.length) return res.status(401).json({ error: 'invalid_credentials' });

+

+    const u = rows[0];

+    if (!u.senha_hash) {

+      return res.status(500).json({ error: 'user_password_not_configured' });

+    }

+

+    const ok = await bcrypt.compare(String(senha), String(u.senha_hash));

+    if (!ok) return res.status(401).json({ error: 'invalid_credentials' });

+

+    const secret = process.env.JWT_SECRET;

+    if (!secret) return res.status(500).json({ error: 'server_config', message: 'JWT_SECRET ausente.' });

+

+    const payload = { id: u.id, nome: u.nome, email: u.email, tipo: u.tipo || 'cliente' };

+    const token = jwt.sign(payload, secret, { expiresIn: '10h' });

+

+    const user = {

+      id: u.id,

+      nome: u.nome,

+      email: u.email,

+      telefone: u.telefone,

+      data_nascimento: u.data_nascimento || null,

+      cpf_cnpj: u.cpf_cnpj || null,

+      cep: u.cep || null,

+      endereco: u.endereco || null,

+      numero: u.numero || null,

+      complemento: u.complemento || null,

+      bairro: u.bairro || null,

+      cidade: u.cidade || null,

+      estado: u.estado || null,

+      avatar_url: u.avatar_url || null,

+      tipo: u.tipo || 'cliente',

+      notify_email_estab: toBool(u.notify_email_estab),

+      notify_whatsapp_estab: toBool(u.notify_whatsapp_estab),

+      plan: u.plan || 'starter',

+      plan_status: u.plan_status || 'trialing',

       plan_trial_ends_at: u.plan_trial_ends_at ? new Date(u.plan_trial_ends_at).toISOString() : null,
       plan_active_until: u.plan_active_until ? new Date(u.plan_active_until).toISOString() : null,
-      plan_subscription_id: u.plan_subscription_id || null,
-    };
-    return res.json({ ok: true, token, user });
-  } catch (e) {
-    console.error('[auth/login] erro:', e);
-    return res.status(500).json({ error: 'server_error' });
-  }
-});
-
-
-
-
-router.get('/me', auth, async (req, res) => {
-  try {
-    const [[pending]] = await pool.query('SELECT new_email, expires_at FROM email_change_tokens WHERE user_id=? LIMIT 1', [req.user.id]);
-    const emailConfirmation = pending
+      plan_subscription_id: u.plan_subscription_id || null,

+    };

+    return res.json({ ok: true, token, user });

+  } catch (e) {

+    console.error('[auth/login] erro:', e);

+    return res.status(500).json({ error: 'server_error' });

+  }

+});

+

+

+

+

+router.get('/me', auth, async (req, res) => {

+  try {

+    const [[pending]] = await pool.query('SELECT new_email, expires_at FROM email_change_tokens WHERE user_id= LIMIT 1', [req.user.id]);

+    const emailConfirmation = pending

       ? { pending: true, newEmail: pending.new_email, expiresAt: pending.expires_at }
-      : null;
-    res.json({ user: req.user, emailConfirmation });
-  } catch (e) {
-    console.error('[auth/me][GET]', e);
-    res.json({ user: req.user, emailConfirmation: null });
-  }
-});
-
-
-
-router.put('/me', auth, async (req, res) => {
-  try {
-    const userId = req.user.id;
-    let {
-      nome,
-      email,
-      telefone,
-      senhaAtual,
-      senhaNova,
-      cep,
-      endereco,
-      numero,
-      complemento,
-      bairro,
-      cidade,
-      estado,
-      data_nascimento,
-      dataNascimento,
-      notifyEmailEstab,
-      notifyWhatsappEstab,
-    } = req.body || {};
-
-    nome = String(nome || '').trim();
-    email = String(email || '').trim();
-    telefone = telefone === undefined || telefone === null ? null : String(telefone).trim();
-    const cepDigitsRaw = (cep ? String(cep) : '').replace(/[^0-9]/g, '').slice(0, 8);
+      : null;

+    res.json({ user: req.user, emailConfirmation });

+  } catch (e) {

+    console.error('[auth/me][GET]', e);

+    res.json({ user: req.user, emailConfirmation: null });

+  }

+});

+

+

+

+router.put('/me', auth, async (req, res) => {

+  try {

+    const userId = req.user.id;

+    let {

+      nome,

+      email,

+      telefone,

+      senhaAtual,

+      senhaNova,

+      cep,

+      endereco,

+      numero,

+      complemento,

+      bairro,

+      cidade,

+      estado,

+      data_nascimento,

+      dataNascimento,

+      notifyEmailEstab,

+      notifyWhatsappEstab,

+    } = req.body || {};

+

+    nome = String(nome || '').trim();

+    email = String(email || '').trim();

+    telefone = telefone == null ? null : String(telefone).trim();
+    const cepDigitsRaw = (cep == null ? '' : String(cep))
+      .replace(/[^0-9]/g, '')
+      .slice(0, 8);
     const cepNormalized = cepDigitsRaw.length === 8 ? cepDigitsRaw : '';
-    const enderecoTrim = endereco ? String(endereco).trim() : '';
-    const numeroTrim = numero ? String(numero).trim() : '';
-    const complementoTrim = complemento ? String(complemento).trim() : '';
-    const bairroTrim = bairro ? String(bairro).trim() : '';
-    const cidadeTrim = cidade ? String(cidade).trim() : '';
-    const estadoTrim = estado ? String(estado).trim().toUpperCase() : '';
-    const dataNascimentoRaw = data_nascimento ?? dataNascimento;
-    const dataNascimentoValue = normalizeBirthdate(dataNascimentoRaw);
-    const hasDataNascimento = String(dataNascimentoRaw || '').trim().length > 0;
-    if (hasDataNascimento && !dataNascimentoValue) {
-      return res.status(400).json({ error: 'data_nascimento_invalida', message: 'Informe uma data de nascimento valida.' });
-    }
-    const cpfCnpjRaw = req.body?.cpf_cnpj ?? req.body?.cpfCnpj;
-    const cpfCnpjInfo = normalizeCpfCnpj(cpfCnpjRaw);
-    if (cpfCnpjInfo.provided && cpfCnpjInfo.digits && ![11, 14].includes(cpfCnpjInfo.digits.length)) {
-      return res.status(400).json({ error: 'cpf_cnpj_invalido', message: 'Informe um CPF ou CNPJ valido.' });
-    }
-    const cpfCnpjNext = cpfCnpjInfo.provided
+    const enderecoTrim = endereco == null ? '' : String(endereco).trim();
+    const numeroTrim = numero == null ? '' : String(numero).trim();
+    const complementoTrim = complemento == null ? '' : String(complemento).trim();
+    const bairroTrim = bairro == null ? '' : String(bairro).trim();
+    const cidadeTrim = cidade == null ? '' : String(cidade).trim();
+    const estadoTrim = estado == null ? '' : String(estado).trim().toUpperCase();
+    const dataNascimentoRaw = data_nascimento || dataNascimento;
+    const dataNascimentoValue = normalizeBirthdate(dataNascimentoRaw);

+    const hasDataNascimento = String(dataNascimentoRaw || '').trim().length > 0;

+    if (hasDataNascimento && !dataNascimentoValue) {

+      return res.status(400).json({ error: 'data_nascimento_invalida', message: 'Informe uma data de nascimento valida.' });

+    }

+    const cpfCnpjRaw = req.body?.cpf_cnpj || req.body?.cpfCnpj;
+    const cpfCnpjInfo = normalizeCpfCnpj(cpfCnpjRaw);

+    if (cpfCnpjInfo.provided && cpfCnpjInfo.digits && ![11, 14].includes(cpfCnpjInfo.digits.length)) {

+      return res.status(400).json({ error: 'cpf_cnpj_invalido', message: 'Informe um CPF ou CNPJ valido.' });

+    }

+    const cpfCnpjNext = cpfCnpjInfo.provided

       ? (cpfCnpjInfo.digits || null)
-      : (req.user?.cpf_cnpj || null);
-    const addressRequired = req.user?.tipo === 'estabelecimento';
-
-    if (!nome) {
-      return res.status(400).json({ error: 'nome_invalido', message: 'Informe seu nome.' });
-    }
-    if (!email) {
-      return res.status(400).json({ error: 'email_invalido', message: 'Informe um email.' });
-    }
-
-    const emailNorm = email.toLowerCase();
-    const emailRe = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
-    if (!emailRe.test(emailNorm)) {
-      return res.status(400).json({ error: 'email_invalido', message: 'Email invalido.' });
-    }
-
-    if (addressRequired) {
-      if (cepDigitsRaw.length !== 8) {
-        return res.status(400).json({ error: 'cep_invalido', message: 'Informe um CEP valido com 8 digitos.' });
-      }
-      if (!enderecoTrim) {
-        return res.status(400).json({ error: 'endereco_obrigatorio', message: 'Informe o endereco do estabelecimento.' });
-      }
-      if (!numeroTrim) {
-        return res.status(400).json({ error: 'numero_obrigatorio', message: 'Informe o numero do endereco.' });
-      }
-      if (!bairroTrim) {
-        return res.status(400).json({ error: 'bairro_obrigatorio', message: 'Informe o bairro do endereco.' });
-      }
-      if (!cidadeTrim) {
-        return res.status(400).json({ error: 'cidade_obrigatoria', message: 'Informe a cidade.' });
-      }
-      if (!/^[A-Z]{2}$/.test(estadoTrim)) {
-        return res.status(400).json({ error: 'estado_invalido', message: 'Informe a UF com 2 letras.' });
-      }
-    } else {
-      if (cepDigitsRaw.length && cepDigitsRaw.length !== 8) {
-        return res.status(400).json({ error: 'cep_invalido', message: 'Informe um CEP valido com 8 digitos.' });
-      }
-      if (estadoTrim && !/^[A-Z]{2}$/.test(estadoTrim)) {
-        return res.status(400).json({ error: 'estado_invalido', message: 'Informe a UF com 2 letras.' });
-      }
-    }
-
+      : (req.user?.cpf_cnpj || null);

+    const addressRequired = req.user?.tipo === 'estabelecimento';

+

+    if (!nome) {

+      return res.status(400).json({ error: 'nome_invalido', message: 'Informe seu nome.' });

+    }

+    if (!email) {

+      return res.status(400).json({ error: 'email_invalido', message: 'Informe um email.' });

+    }

+

+    const emailNorm = email.toLowerCase();

+    const emailRe = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

+    if (!emailRe.test(emailNorm)) {

+      return res.status(400).json({ error: 'email_invalido', message: 'Email invalido.' });

+    }

+

+    if (addressRequired) {

+      if (cepDigitsRaw.length !== 8) {

+        return res.status(400).json({ error: 'cep_invalido', message: 'Informe um CEP valido com 8 digitos.' });

+      }

+      if (!enderecoTrim) {

+        return res.status(400).json({ error: 'endereco_obrigatorio', message: 'Informe o endereco do estabelecimento.' });

+      }

+      if (!numeroTrim) {

+        return res.status(400).json({ error: 'numero_obrigatorio', message: 'Informe o numero do endereco.' });

+      }

+      if (!bairroTrim) {

+        return res.status(400).json({ error: 'bairro_obrigatorio', message: 'Informe o bairro do endereco.' });

+      }

+      if (!cidadeTrim) {

+        return res.status(400).json({ error: 'cidade_obrigatoria', message: 'Informe a cidade.' });

+      }

+      if (!/^[A-Z]{2}$/.test(estadoTrim)) {

+        return res.status(400).json({ error: 'estado_invalido', message: 'Informe a UF com 2 letras.' });

+      }

+    } else {

+      if (cepDigitsRaw.length && cepDigitsRaw.length !== 8) {

+        return res.status(400).json({ error: 'cep_invalido', message: 'Informe um CEP valido com 8 digitos.' });

+      }

+      if (estadoTrim && !/^[A-Z]{2}$/.test(estadoTrim)) {

+        return res.status(400).json({ error: 'estado_invalido', message: 'Informe a UF com 2 letras.' });

+      }

+    }

+

     const phoneClean = telefone ? telefone.replace(/[^\d+]/g, '') : null;
-    if (phoneClean && phoneClean.length > 25) {
-      return res.status(400).json({ error: 'telefone_invalido', message: 'Telefone invalido.' });
-    }
-
-    const isEstabUser = req.user?.tipo === 'estabelecimento';
-    const parseToggle = (value) => {
-      if (value === undefined || value === null) return null;
-      if (typeof value === 'boolean') return value;
-      if (typeof value === 'number') return value === 1;
-      if (typeof value === 'string') {
-        const norm = value.trim().toLowerCase();
-        if (['1', 'true', 'on', 'yes', 'sim'].includes(norm)) return true;
-        if (['0', 'false', 'off', 'no', 'nao'].includes(norm)) return false;
-      }
-      return null;
-    };
-    const notifyEmailRaw = notifyEmailEstab ?? req.body?.notify_email_estab;
-    const notifyWhatsappRaw = notifyWhatsappEstab ?? req.body?.notify_whatsapp_estab;
-    const currentNotifyEmail = Boolean(req.user?.notify_email_estab);
-    const currentNotifyWhatsapp = Boolean(req.user?.notify_whatsapp_estab);
-    const nextNotifyEmail = isEstabUser
+    if (phoneClean && phoneClean.length > 25) {

+      return res.status(400).json({ error: 'telefone_invalido', message: 'Telefone invalido.' });

+    }

+

+    const isEstabUser = req.user?.tipo === 'estabelecimento';

+    const parseToggle = (value) => {

+      if (value === undefined || value === null) return null;

+      if (typeof value === 'boolean') return value;

+      if (typeof value === 'number') return value === 1;

+      if (typeof value === 'string') {

+        const norm = value.trim().toLowerCase();

+        if (['1', 'true', 'on', 'yes', 'sim'].includes(norm)) return true;

+        if (['0', 'false', 'off', 'no', 'nao'].includes(norm)) return false;

+      }

+      return null;

+    };

+    const notifyEmailRaw = notifyEmailEstab || req.body?.notify_email_estab;
+    const notifyWhatsappRaw = notifyWhatsappEstab || req.body?.notify_whatsapp_estab;
+    const currentNotifyEmail = Boolean(req.user?.notify_email_estab);

+    const currentNotifyWhatsapp = Boolean(req.user?.notify_whatsapp_estab);

+    const nextNotifyEmail = isEstabUser

       ? (parseToggle(notifyEmailRaw) ?? currentNotifyEmail)
-      : currentNotifyEmail;
-    const nextNotifyWhatsapp = isEstabUser
+      : currentNotifyEmail;

+    const nextNotifyWhatsapp = isEstabUser

       ? (parseToggle(notifyWhatsappRaw) ?? currentNotifyWhatsapp)
-      : currentNotifyWhatsapp;
-
-    const [emailRows] = await pool.query('SELECT id FROM usuarios WHERE LOWER(email)=? AND id<>? LIMIT 1', [emailNorm, userId]);
-    if (emailRows.length) {
-      return res.status(400).json({ error: 'email_exists', message: 'Este email já esta em uso.' });
-    }
-
-    const atual = String(senhaAtual || '').trim();
-    if (!atual) {
-      return res.status(400).json({ error: 'senha_atual_obrigatoria', message: 'Informe a senha atual.' });
-    }
-
-    const [[row]] = await pool.query('SELECT senha_hash FROM usuarios WHERE id=? LIMIT 1', [userId]);
-    if (!row || !row.senha_hash) {
-      return res.status(400).json({ error: 'senha_indefinida', message: 'Não foi possível validar a senha atual.' });
-    }
-
-    const okAtual = await bcrypt.compare(atual, row.senha_hash);
-    if (!okAtual) {
-      return res.status(400).json({ error: 'senha_incorreta', message: 'Senha atual incorreta.' });
-    }
-
-    const previousAvatar = req.user?.avatar_url || null;
+      : currentNotifyWhatsapp;

+

+    const [emailRows] = await pool.query('SELECT id FROM usuarios WHERE LOWER(email)= AND id<> LIMIT 1', [emailNorm, userId]);

+    if (emailRows.length) {

+      return res.status(400).json({ error: 'email_exists', message: 'Este email já esta em uso.' });

+    }

+

+    const atual = String(senhaAtual || '').trim();

+    if (!atual) {

+      return res.status(400).json({ error: 'senha_atual_obrigatoria', message: 'Informe a senha atual.' });

+    }

+

+    const [[row]] = await pool.query('SELECT senha_hash FROM usuarios WHERE id= LIMIT 1', [userId]);

+    if (!row || !row.senha_hash) {

+      return res.status(400).json({ error: 'senha_indefinida', message: 'Não foi possível validar a senha atual.' });

+    }

+

+    const okAtual = await bcrypt.compare(atual, row.senha_hash);

+    if (!okAtual) {

+      return res.status(400).json({ error: 'senha_incorreta', message: 'Senha atual incorreta.' });

+    }

+

+    const previousAvatar = req.user?.avatar_url || null;

     const avatarRaw = typeof req.body?.avatar === 'string' ? req.body.avatar.trim() : '';
-    const wantsRemoveAvatar = req.body?.avatarRemove === true || req.body?.avatarRemove === 'true';
-    let nextAvatar = previousAvatar;
-
-    if (wantsRemoveAvatar && previousAvatar) {
-      try {
-        await removeAvatarFile(previousAvatar);
-      } catch (err) {
-        if (err?.code !== 'ENOENT') console.warn('[auth/me][avatar] remove failed', err?.message || err);
-      }
-      nextAvatar = null;
-    }
-
-    if (avatarRaw) {
-      if (!avatarRaw.startsWith('data:image/')) {
-        return res.status(400).json({ error: 'avatar_invalido', message: 'Envie uma imagem PNG, JPG ou WEBP.' });
-      }
-      try {
+    const wantsRemoveAvatar = req.body?.avatarRemove === true || req.body?.avatarRemove === 'true';

+    let nextAvatar = previousAvatar;

+

+    if (wantsRemoveAvatar && previousAvatar) {

+      try {

+        await removeAvatarFile(previousAvatar);

+      } catch (err) {

+        if (err?.code !== 'ENOENT') console.warn('[auth/me][avatar] remove failed', err?.message || err);

+      }

+      nextAvatar = null;

+    }

+

+    if (avatarRaw) {

+      if (!avatarRaw.startsWith('data:image/')) {

+        return res.status(400).json({ error: 'avatar_invalido', message: 'Envie uma imagem PNG, JPG ou WEBP.' });

+      }

+      try {

         const previousForSave = wantsRemoveAvatar ? null : previousAvatar;
-        nextAvatar = await saveAvatarFromDataUrl(avatarRaw, userId, previousForSave);
-      } catch (err) {
-        if (err?.code === 'AVATAR_TOO_LARGE') {
-          return res.status(400).json({ error: 'avatar_grande', message: 'A imagem deve ter no maximo 2MB.' });
-        }
-        if (err?.code === 'AVATAR_INVALID') {
-          return res.status(400).json({ error: 'avatar_invalido', message: 'Envie uma imagem PNG, JPG ou WEBP.' });
-        }
-        console.error('[auth/me][avatar] erro:', err);
-        return res.status(500).json({ error: 'avatar_falhou', message: 'Não foi possível salvar a foto de perfil.' });
-      }
-    }
-
-    if (senhaNova) {
-      const nova = String(senhaNova || '');
-      if (nova.length < 6) {
-        return res.status(400).json({ error: 'senha_fraca', message: 'A nova senha deve ter pelo menos 6 caracteres.' });
-      }
-      const newHash = await bcrypt.hash(nova, 10);
-      await pool.query('UPDATE usuarios SET senha_hash=? WHERE id=?', [newHash, userId]);
-    }
-
-    const cepValue = cepNormalized || null;
-    const enderecoValue = enderecoTrim || null;
-    const numeroValue = numeroTrim || null;
-    const complementoValue = complementoTrim || null;
-    const bairroValue = bairroTrim || null;
-    const cidadeValue = cidadeTrim || null;
-    const estadoValue = estadoTrim || null;
+        nextAvatar = await saveAvatarFromDataUrl(avatarRaw, userId, previousForSave);

+      } catch (err) {

+        if (err?.code === 'AVATAR_TOO_LARGE') {

+          return res.status(400).json({ error: 'avatar_grande', message: 'A imagem deve ter no maximo 2MB.' });

+        }

+        if (err?.code === 'AVATAR_INVALID') {

+          return res.status(400).json({ error: 'avatar_invalido', message: 'Envie uma imagem PNG, JPG ou WEBP.' });

+        }

+        console.error('[auth/me][avatar] erro:', err);

+        return res.status(500).json({ error: 'avatar_falhou', message: 'Não foi possível salvar a foto de perfil.' });

+      }

+    }

+

+    if (senhaNova) {

+      const nova = String(senhaNova || '');

+      if (nova.length < 6) {

+        return res.status(400).json({ error: 'senha_fraca', message: 'A nova senha deve ter pelo menos 6 caracteres.' });

+      }

+      const newHash = await bcrypt.hash(nova, 10);

+      await pool.query('UPDATE usuarios SET senha_hash= WHERE id=?', [newHash, userId]);

+    }

+

+    const cepValue = cepNormalized || null;

+    const enderecoValue = enderecoTrim || null;

+    const numeroValue = numeroTrim || null;

+    const complementoValue = complementoTrim || null;

+    const bairroValue = bairroTrim || null;

+    const cidadeValue = cidadeTrim || null;

+    const estadoValue = estadoTrim || null;

     const dataNascimentoNext = hasDataNascimento ? dataNascimentoValue : (req.user?.data_nascimento || null);
-
-    const currentEmail = String(req.user?.email || '').trim().toLowerCase();
-    const emailChanged = emailNorm !== currentEmail;
-
-    if (emailChanged) {
-      await pool.query(
-        'UPDATE usuarios SET nome=?, telefone=?, data_nascimento=?, cpf_cnpj=?, cep=?, endereco=?, numero=?, complemento=?, bairro=?, cidade=?, estado=?, notify_email_estab=?, notify_whatsapp_estab=?, avatar_url=? WHERE id=?',
+

+    const currentEmail = String(req.user?.email || '').trim().toLowerCase();

+    const emailChanged = emailNorm !== currentEmail;

+

+    if (emailChanged) {

+      await pool.query(

+        'UPDATE usuarios SET nome=?, telefone=?, data_nascimento=?, cpf_cnpj=?, cep=?, endereco=?, numero=?, complemento=?, bairro=?, cidade=?, estado=?, notify_email_estab=?, notify_whatsapp_estab=?, avatar_url= WHERE id=?',

         [nome, phoneClean || null, dataNascimentoNext, cpfCnpjNext, cepValue, enderecoValue, numeroValue, complementoValue, bairroValue, cidadeValue, estadoValue, nextNotifyEmail ? 1 : 0, nextNotifyWhatsapp ? 1 : 0, nextAvatar, userId]
-      );
-      await pool.query('DELETE FROM email_change_tokens WHERE user_id=?', [userId]);
-      const code = String(Math.floor(100000 + Math.random() * 900000));
-      const codeHash = await bcrypt.hash(code, 10);
-      const expiresAt = new Date(Date.now() + 30 * 60 * 1000);
-      await pool.query('INSERT INTO email_change_tokens (user_id, new_email, code_hash, expires_at) VALUES (?,?,?,?)', [userId, emailNorm, codeHash, expiresAt]);
-      const subject = 'Confirme seu novo email';
-      const html = `<p>Ola!</p><p>Use o código <strong>${code}</strong> para confirmar seu novo email.</p><p>O código expira em 30 minutos.</p>`;
-      try { await notifyEmail(emailNorm, subject, html); } catch (err) { console.error('[auth/me][email]', err); }
-
-      const [[userRow]] = await pool.query("SELECT id, nome, email, telefone, data_nascimento, cpf_cnpj, cep, endereco, numero, complemento, bairro, cidade, estado, avatar_url, tipo, notify_email_estab, notify_whatsapp_estab, plan, plan_status, plan_trial_ends_at, plan_active_until, plan_subscription_id FROM usuarios WHERE id=? LIMIT 1", [userId]);
-      if (!userRow) {
-        return res.status(404).json({ error: 'not_found', message: 'Usuario nao encontrado.' });
-      }
-
-      const mergedUser = {
-        ...userRow,
-        nome: userRow.nome || nome,
-        telefone: userRow.telefone || phoneClean,
-        data_nascimento: userRow.data_nascimento || dataNascimentoNext,
-        cpf_cnpj: userRow.cpf_cnpj ?? cpfCnpjNext,
-        cep: userRow.cep || cepValue,
-        endereco: userRow.endereco || enderecoValue,
-        numero: userRow.numero || numeroValue,
-        complemento: userRow.complemento || complementoValue,
-        bairro: userRow.bairro || bairroValue,
-        cidade: userRow.cidade || cidadeValue,
-        estado: userRow.estado || estadoValue,
-        avatar_url: userRow.avatar_url || nextAvatar || null,
+      );

+      await pool.query('DELETE FROM email_change_tokens WHERE user_id=?', [userId]);

+      const code = String(Math.floor(100000 + Math.random() * 900000));

+      const codeHash = await bcrypt.hash(code, 10);

+      const expiresAt = new Date(Date.now() + 30 * 60 * 1000);

+      await pool.query('INSERT INTO email_change_tokens (user_id, new_email, code_hash, expires_at) VALUES (?,?,?,?)', [userId, emailNorm, codeHash, expiresAt]);

+      const subject = 'Confirme seu novo email';

+      const html = `<p>Ola!</p><p>Use o código <strong>${code}</strong> para confirmar seu novo email.</p><p>O código expira em 30 minutos.</p>`;

+      try { await notifyEmail(emailNorm, subject, html); } catch (err) { console.error('[auth/me][email]', err); }

+

+      const [[userRow]] = await pool.query("SELECT id, nome, email, telefone, data_nascimento, cpf_cnpj, cep, endereco, numero, complemento, bairro, cidade, estado, avatar_url, tipo, notify_email_estab, notify_whatsapp_estab, plan, plan_status, plan_trial_ends_at, plan_active_until, plan_subscription_id FROM usuarios WHERE id= LIMIT 1", [userId]);

+      if (!userRow) {

+        return res.status(404).json({ error: 'not_found', message: 'Usuario nao encontrado.' });

+      }

+

+      const mergedUser = {

+        ...userRow,

+        nome: userRow.nome || nome,

+        telefone: userRow.telefone || phoneClean,

+        data_nascimento: userRow.data_nascimento || dataNascimentoNext,

+        cpf_cnpj: userRow.cpf_cnpj || cpfCnpjNext,
+        cep: userRow.cep || cepValue,

+        endereco: userRow.endereco || enderecoValue,

+        numero: userRow.numero || numeroValue,

+        complemento: userRow.complemento || complementoValue,

+        bairro: userRow.bairro || bairroValue,

+        cidade: userRow.cidade || cidadeValue,

+        estado: userRow.estado || estadoValue,

+        avatar_url: userRow.avatar_url || nextAvatar || null,

         notify_email_estab: toBool(userRow.notify_email_estab ?? nextNotifyEmail),
         notify_whatsapp_estab: toBool(userRow.notify_whatsapp_estab ?? nextNotifyWhatsapp),
-      };
-      req.user = { ...req.user, ...mergedUser };
-
-      return res.json({
-        ok: true,
-        user: mergedUser,
-        emailConfirmation: { pending: true, newEmail: emailNorm, expiresAt: expiresAt.toISOString() },
-      });
-    }
-
-    await pool.query(
-      'UPDATE usuarios SET nome=?, email=?, telefone=?, data_nascimento=?, cpf_cnpj=?, cep=?, endereco=?, numero=?, complemento=?, bairro=?, cidade=?, estado=?, notify_email_estab=?, notify_whatsapp_estab=?, avatar_url=? WHERE id=?',
+      };

+      req.user = { ...req.user, ...mergedUser };

+

+      return res.json({

+        ok: true,

+        user: mergedUser,

+        emailConfirmation: { pending: true, newEmail: emailNorm, expiresAt: expiresAt.toISOString() },

+      });

+    }

+

+    await pool.query(

+      'UPDATE usuarios SET nome=?, email=?, telefone=?, data_nascimento=?, cpf_cnpj=?, cep=?, endereco=?, numero=?, complemento=?, bairro=?, cidade=?, estado=?, notify_email_estab=?, notify_whatsapp_estab=?, avatar_url= WHERE id=?',

       [nome, email, phoneClean || null, dataNascimentoNext, cpfCnpjNext, cepValue, enderecoValue, numeroValue, complementoValue, bairroValue, cidadeValue, estadoValue, nextNotifyEmail ? 1 : 0, nextNotifyWhatsapp ? 1 : 0, nextAvatar, userId]
-    );
-
-    const [[userRow]] = await pool.query("SELECT id, nome, email, telefone, data_nascimento, cpf_cnpj, cep, endereco, numero, complemento, bairro, cidade, estado, avatar_url, tipo, notify_email_estab, notify_whatsapp_estab, plan, plan_status, plan_trial_ends_at, plan_active_until, plan_subscription_id FROM usuarios WHERE id=? LIMIT 1", [userId]);
-    if (!userRow) {
-      return res.status(404).json({ error: 'not_found', message: 'Usuario nao encontrado.' });
-    }
-
-    const normalizedUser = {
-      ...userRow,
+    );

+

+    const [[userRow]] = await pool.query("SELECT id, nome, email, telefone, data_nascimento, cpf_cnpj, cep, endereco, numero, complemento, bairro, cidade, estado, avatar_url, tipo, notify_email_estab, notify_whatsapp_estab, plan, plan_status, plan_trial_ends_at, plan_active_until, plan_subscription_id FROM usuarios WHERE id= LIMIT 1", [userId]);

+    if (!userRow) {

+      return res.status(404).json({ error: 'not_found', message: 'Usuario nao encontrado.' });

+    }

+

+    const normalizedUser = {

+      ...userRow,

       notify_email_estab: toBool(userRow.notify_email_estab ?? nextNotifyEmail),
       notify_whatsapp_estab: toBool(userRow.notify_whatsapp_estab ?? nextNotifyWhatsapp),
-    };
-
-    req.user = { ...req.user, ...normalizedUser };
-
-    return res.json({ ok: true, user: normalizedUser });
-  } catch (e) {
-    console.error('[auth/me][PUT] erro:', e);
-    return res.status(500).json({ error: 'server_error' });
-  }
-});
-
-
-
-// Recuperação de senha (envio de link com token)
-
-router.post('/me/email-confirm', auth, async (req, res) => {
-  try {
-    const userId = req.user.id;
-    const code = String(req.body?.code || '').trim();
-    if (!/^[0-9]{6}$/.test(code)) {
-      return res.status(400).json({ error: 'codigo_invalido', message: 'Informe o codigo de 6 digitos.' });
-    }
-
-    const [rows] = await pool.query('SELECT id, new_email, code_hash, expires_at FROM email_change_tokens WHERE user_id=? LIMIT 1', [userId]);
-    const token = rows?.[0];
-    if (!token) {
-      return res.status(404).json({ error: 'codigo_expirado', message: 'Nenhum pedido de troca de email encontrado.' });
-    }
-    if (new Date(token.expires_at).getTime() < Date.now()) {
-      await pool.query('DELETE FROM email_change_tokens WHERE id=?', [token.id]);
-      return res.status(400).json({ error: 'codigo_expirado', message: 'Codigo expirado. Solicite novamente.' });
-    }
-
-    const ok = await bcrypt.compare(code, token.code_hash);
-    if (!ok) {
-      return res.status(400).json({ error: 'codigo_invalido', message: 'Codigo invalido.' });
-    }
-
-    const newEmail = String(token.new_email || '').trim();
-    if (!newEmail) {
-      await pool.query('DELETE FROM email_change_tokens WHERE id=?', [token.id]);
-      return res.status(400).json({ error: 'codigo_invalido', message: 'Codigo invalido.' });
-    }
-
-    await pool.query('UPDATE usuarios SET email=? WHERE id=?', [newEmail, userId]);
-    await pool.query('DELETE FROM email_change_tokens WHERE id=?', [token.id]);
-
-    const [[userRow]] = await pool.query("SELECT id, nome, email, telefone, data_nascimento, cpf_cnpj, cep, endereco, numero, complemento, bairro, cidade, estado, avatar_url, tipo, notify_email_estab, notify_whatsapp_estab, plan, plan_status, plan_trial_ends_at, plan_active_until, plan_subscription_id FROM usuarios WHERE id=? LIMIT 1", [userId]);
-    if (!userRow) {
-      return res.status(404).json({ error: 'not_found', message: 'Usuario nao encontrado.' });
-    }
-
-    const normalized = {
-      ...userRow,
-      notify_email_estab: toBool(userRow.notify_email_estab),
-      notify_whatsapp_estab: toBool(userRow.notify_whatsapp_estab),
-    };
-
-    req.user = { ...req.user, ...normalized };
-
-    return res.json({ ok: true, user: normalized });
-  } catch (e) {
-    console.error('[auth/email-confirm]', e);
-    return res.status(500).json({ error: 'server_error' });
-  }
-});
-
-
-router.post('/forgot', async (req, res) => {
-  try{
-    const emailRaw = req.body?.email;
-    if (!emailRaw) return res.status(400).json({ error: 'missing_email' });
-    const email = String(emailRaw).trim().toLowerCase();
-
-    // Busca usuário  mas SEM revelar se existe ou não
-    let user = null;
-    try{
-      const [rows] = await pool.query('SELECT id, nome, email FROM usuarios WHERE LOWER(email)=? LIMIT 1', [email]);
-      user = rows?.[0] || null;
-    }catch{}
-
-    // Monta link com token JWT de uso único por período curto
-    const appUrl = process.env.APP_URL || 'http://localhost:3001';
-    const secret = process.env.JWT_SECRET;
-    let link = `${appUrl.replace(/\/$/,'')}/recuperar-senha`;
-    if (user && secret) {
-      const jti = crypto.randomBytes(16).toString('hex');
-      const expires = new Date(Date.now() + 30 * 60 * 1000);
-      // registra token para invalidação pós-uso
-      try{
-        await pool.query(
-          'INSERT INTO password_resets (user_id, jti, expires_at) VALUES (?,?,?)',
-          [user.id, jti, expires]
-        );
-      }catch(e){
-        console.error('[auth/forgot] falha ao registrar token:', e?.message || e);
-      }
-
-      const token = jwt.sign(
-        { sub: user.id, email: user.email, scope: 'pwd_reset' },
-        secret,
-        { expiresIn: '30m', jwtid: jti }
-      );
-      link = `${appUrl.replace(/\/$/,'')}/definir-senha?token=${encodeURIComponent(token)}`;
-    }
-
-    // Envia email apenas se usuário existir e SMTP estiver configurado; caso contrário, apenas loga
-    if (user) {
-      const subject = 'Recuperação de senha';
-      const html = `
-        <div style="font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;line-height:1.5;color:#111">
-          <h2>Recuperar senha</h2>
-          <p>Olá, ${user.nome?.split(' ')[0] || 'usuário'}.</p>
-          <p>Para redefinir sua senha, acesse o link abaixo:</p>
-          <p><a href="${link}" style="color:#5c5ccc">Redefinir senha</a></p>
-          <p style="color:#555;font-size:12px">Se você não solicitou, ignore este email.</p>
-        </div>`;
-      try{
-        await notifyEmail(email, subject, html);
-      }catch(e){
-        // continua silencioso
-        console.error('[auth/forgot] notifyEmail falhou:', e?.message || e);
-      }
-    } else {
-      console.log('[auth/forgot] pedido para email inexistente (não informado ao cliente)');
-    }
-
-    // Resposta neutra
-    return res.json({ ok: true });
-  }catch(e){
-    console.error('[auth/forgot] erro:', e);
-    return res.status(200).json({ ok: true }); // mantém resposta neutra
-  }
-});
-
-// Redefinição de senha com token
-router.post('/reset', async (req, res) => {
-  try{
-    const token = req.body?.token;
-    const senha = req.body?.senha;
-    if (!token || !senha) return res.status(400).json({ error: 'missing_fields' });
-
-    const secret = process.env.JWT_SECRET;
-    if (!secret) return res.status(500).json({ error: 'server_config', message: 'JWT_SECRET ausente.' });
-
-    let payload;
-    try {
-      payload = jwt.verify(String(token), secret);
-    } catch (e) {
-      return res.status(400).json({ error: 'invalid_token' });
-    }
-
-    if (payload?.scope !== 'pwd_reset' || !payload?.sub || !payload?.jti) {
-      return res.status(400).json({ error: 'invalid_scope' });
-    }
-
-    const userId = Number(payload.sub);
-    if (!Number.isFinite(userId)) return res.status(400).json({ error: 'invalid_token' });
-
-    // Verifica token no banco (não usado/expirado)
-    try{
-      const [rows] = await pool.query(
-        'SELECT id, user_id, used_at, expires_at FROM password_resets WHERE jti=? LIMIT 1',
-        [String(payload.jti)]
-      );
-      const rec = rows?.[0];
-      if (!rec || rec.user_id !== userId) {
-        return res.status(400).json({ error: 'invalid_token' });
-      }
-      if (rec.used_at) {
-        return res.status(400).json({ error: 'token_used' });
-      }
-      if (new Date(rec.expires_at).getTime() < Date.now()) {
-        return res.status(400).json({ error: 'token_expired' });
-      }
-    }catch(e){
-      console.error('[auth/reset] falha ao validar token:', e?.message || e);
-      return res.status(500).json({ error: 'server_error' });
-    }
-
-    const hash = await bcrypt.hash(String(senha), 10);
-    await pool.query('UPDATE usuarios SET senha_hash=? WHERE id=?', [hash, userId]);
-    // marca este token como usado e invalida quaisquer outros abertos do usuário
-    try{
-      await pool.query('UPDATE password_resets SET used_at=NOW() WHERE jti=?', [String(payload.jti)]);
-      await pool.query('UPDATE password_resets SET used_at=NOW() WHERE user_id=? AND used_at IS NULL AND expires_at > NOW()', [userId]);
-    }catch(e){
-      console.error('[auth/reset] falha ao invalidar tokens:', e?.message || e);
-    }
-
-    return res.json({ ok: true });
-  }catch(e){
-    console.error('[auth/reset] erro:', e);
-    return res.status(500).json({ error: 'server_error' });
-  }
-});
-
-export default router;
-
-// Vincular telefone via token (one-time link)
-router.post('/link-phone', auth, async (req, res) => {
-  try {
-    const token = req.body?.token;
-    if (!token) return res.status(400).json({ error: 'missing_token' });
-    const rec = await consumeLinkToken(String(token));
-    if (!rec) return res.status(400).json({ error: 'invalid_token' });
-    const phone = String(rec.phone);
-    if (!/\d{8,}/.test(phone)) return res.status(400).json({ error: 'invalid_phone' });
-    await pool.query('UPDATE usuarios SET telefone=? WHERE id=?', [phone, req.user.id]);
-    return res.json({ ok: true, phone });
-  } catch (e) {
-    console.error('[auth/link-phone] erro', e);
-    return res.status(500).json({ error: 'server_error' });
-  }
-});
+    };

+

+    req.user = { ...req.user, ...normalizedUser };

+

+    return res.json({ ok: true, user: normalizedUser });

+  } catch (e) {

+    console.error('[auth/me][PUT] erro:', e);

+    return res.status(500).json({ error: 'server_error' });

+  }

+});

+

+

+

+// Recuperação de senha (envio de link com token)

+

+router.post('/me/email-confirm', auth, async (req, res) => {

+  try {

+    const userId = req.user.id;

+    const code = String(req.body?.code || '').trim();

+    if (!/^[0-9]{6}$/.test(code)) {

+      return res.status(400).json({ error: 'codigo_invalido', message: 'Informe o codigo de 6 digitos.' });

+    }

+

+    const [rows] = await pool.query('SELECT id, new_email, code_hash, expires_at FROM email_change_tokens WHERE user_id= LIMIT 1', [userId]);

+    const token = rows?.[0];

+    if (!token) {

+      return res.status(404).json({ error: 'codigo_expirado', message: 'Nenhum pedido de troca de email encontrado.' });

+    }

+    if (new Date(token.expires_at).getTime() < Date.now()) {

+      await pool.query('DELETE FROM email_change_tokens WHERE id=?', [token.id]);

+      return res.status(400).json({ error: 'codigo_expirado', message: 'Codigo expirado. Solicite novamente.' });

+    }

+

+    const ok = await bcrypt.compare(code, token.code_hash);

+    if (!ok) {

+      return res.status(400).json({ error: 'codigo_invalido', message: 'Codigo invalido.' });

+    }

+

+    const newEmail = String(token.new_email || '').trim();

+    if (!newEmail) {

+      await pool.query('DELETE FROM email_change_tokens WHERE id=?', [token.id]);

+      return res.status(400).json({ error: 'codigo_invalido', message: 'Codigo invalido.' });

+    }

+

+    await pool.query('UPDATE usuarios SET email= WHERE id=?', [newEmail, userId]);

+    await pool.query('DELETE FROM email_change_tokens WHERE id=?', [token.id]);

+

+    const [[userRow]] = await pool.query("SELECT id, nome, email, telefone, data_nascimento, cpf_cnpj, cep, endereco, numero, complemento, bairro, cidade, estado, avatar_url, tipo, notify_email_estab, notify_whatsapp_estab, plan, plan_status, plan_trial_ends_at, plan_active_until, plan_subscription_id FROM usuarios WHERE id= LIMIT 1", [userId]);

+    if (!userRow) {

+      return res.status(404).json({ error: 'not_found', message: 'Usuario nao encontrado.' });

+    }

+

+    const normalized = {

+      ...userRow,

+      notify_email_estab: toBool(userRow.notify_email_estab),

+      notify_whatsapp_estab: toBool(userRow.notify_whatsapp_estab),

+    };

+

+    req.user = { ...req.user, ...normalized };

+

+    return res.json({ ok: true, user: normalized });

+  } catch (e) {

+    console.error('[auth/email-confirm]', e);

+    return res.status(500).json({ error: 'server_error' });

+  }

+});

+

+

+router.post('/forgot', async (req, res) => {

+  try{

+    const emailRaw = req.body?.email;

+    if (!emailRaw) return res.status(400).json({ error: 'missing_email' });

+    const email = String(emailRaw).trim().toLowerCase();

+

+    // Busca usuário  mas SEM revelar se existe ou não

+    let user = null;

+    try{

+      const [rows] = await pool.query('SELECT id, nome, email FROM usuarios WHERE LOWER(email)= LIMIT 1', [email]);

+      user = rows?.[0] || null;

+    }catch{}

+

+    // Monta link com token JWT de uso único por período curto

+    const appUrl = process.env.APP_URL || 'http://localhost:3001';

+    const secret = process.env.JWT_SECRET;

+    let link = `${appUrl.replace(/\/$/,'')}/recuperar-senha`;

+    if (user && secret) {

+      const jti = crypto.randomBytes(16).toString('hex');

+      const expires = new Date(Date.now() + 30 * 60 * 1000);

+      // registra token para invalidação pós-uso

+      try{

+        await pool.query(

+          'INSERT INTO password_resets (user_id, jti, expires_at) VALUES (?,?,?)',

+          [user.id, jti, expires]

+        );

+      }catch(e){

+        console.error('[auth/forgot] falha ao registrar token:', e?.message || e);

+      }

+

+      const token = jwt.sign(

+        { sub: user.id, email: user.email, scope: 'pwd_reset' },

+        secret,

+        { expiresIn: '30m', jwtid: jti }

+      );

+      link = `${appUrl.replace(/\/$/,'')}/definir-senha?token=${encodeURIComponent(token)}`;

+    }

+

+    // Envia email apenas se usuário existir e SMTP estiver configurado; caso contrário, apenas loga

+    if (user) {

+      const subject = 'Recuperação de senha';

+      const html = `

+        <div style="font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;line-height:1.5;color:#111">

+          <h2>Recuperar senha</h2>

+          <p>Olá, ${user.nome?.split(' ')[0] || 'usuário'}.</p>

+          <p>Para redefinir sua senha, acesse o link abaixo:</p>

+          <p><a href="${link}" style="color:#5c5ccc">Redefinir senha</a></p>

+          <p style="color:#555;font-size:12px">Se você não solicitou, ignore este email.</p>

+        </div>`;

+      try{

+        await notifyEmail(email, subject, html);

+      }catch(e){

+        // continua silencioso

+        console.error('[auth/forgot] notifyEmail falhou:', e?.message || e);

+      }

+    } else {

+      console.log('[auth/forgot] pedido para email inexistente (não informado ao cliente)');

+    }

+

+    // Resposta neutra

+    return res.json({ ok: true });

+  }catch(e){

+    console.error('[auth/forgot] erro:', e);

+    return res.status(200).json({ ok: true }); // mantém resposta neutra

+  }

+});

+

+// Redefinição de senha com token

+router.post('/reset', async (req, res) => {

+  try{

+    const token = req.body?.token;

+    const senha = req.body?.senha;

+    if (!token || !senha) return res.status(400).json({ error: 'missing_fields' });

+

+    const secret = process.env.JWT_SECRET;

+    if (!secret) return res.status(500).json({ error: 'server_config', message: 'JWT_SECRET ausente.' });

+

+    let payload;

+    try {

+      payload = jwt.verify(String(token), secret);

+    } catch (e) {

+      return res.status(400).json({ error: 'invalid_token' });

+    }

+

+    if (payload?.scope !== 'pwd_reset' || !payload?.sub || !payload?.jti) {

+      return res.status(400).json({ error: 'invalid_scope' });

+    }

+

+    const userId = Number(payload.sub);

+    if (!Number.isFinite(userId)) return res.status(400).json({ error: 'invalid_token' });

+

+    // Verifica token no banco (não usado/expirado)

+    try{

+      const [rows] = await pool.query(

+        'SELECT id, user_id, used_at, expires_at FROM password_resets WHERE jti= LIMIT 1',

+        [String(payload.jti)]

+      );

+      const rec = rows?.[0];

+      if (!rec || rec.user_id !== userId) {

+        return res.status(400).json({ error: 'invalid_token' });

+      }

+      if (rec.used_at) {

+        return res.status(400).json({ error: 'token_used' });

+      }

+      if (new Date(rec.expires_at).getTime() < Date.now()) {

+        return res.status(400).json({ error: 'token_expired' });

+      }

+    }catch(e){

+      console.error('[auth/reset] falha ao validar token:', e?.message || e);

+      return res.status(500).json({ error: 'server_error' });

+    }

+

+    const hash = await bcrypt.hash(String(senha), 10);

+    await pool.query('UPDATE usuarios SET senha_hash= WHERE id=?', [hash, userId]);

+    // marca este token como usado e invalida quaisquer outros abertos do usuário

+    try{

+      await pool.query('UPDATE password_resets SET used_at=NOW() WHERE jti=?', [String(payload.jti)]);

+      await pool.query('UPDATE password_resets SET used_at=NOW() WHERE user_id= AND used_at IS NULL AND expires_at > NOW()', [userId]);

+    }catch(e){

+      console.error('[auth/reset] falha ao invalidar tokens:', e?.message || e);

+    }

+

+    return res.json({ ok: true });

+  }catch(e){

+    console.error('[auth/reset] erro:', e);

+    return res.status(500).json({ error: 'server_error' });

+  }

+});

+

+export default router;

+

+// Vincular telefone via token (one-time link)

+router.post('/link-phone', auth, async (req, res) => {

+  try {

+    const token = req.body?.token;

+    if (!token) return res.status(400).json({ error: 'missing_token' });

+    const rec = await consumeLinkToken(String(token));

+    if (!rec) return res.status(400).json({ error: 'invalid_token' });

+    const phone = String(rec.phone);

+    if (!/\d{8,}/.test(phone)) return res.status(400).json({ error: 'invalid_phone' });

+    await pool.query('UPDATE usuarios SET telefone= WHERE id=?', [phone, req.user.id]);

+    return res.json({ ok: true, phone });

+  } catch (e) {

+    console.error('[auth/link-phone] erro', e);

+    return res.status(500).json({ error: 'server_error' });

+  }

+});

diff --git a/backend/src/routes/estabelecimentos.js b/backend/src/routes/estabelecimentos.js
index a833f48..091395c 100644
--- a/backend/src/routes/estabelecimentos.js
+++ b/backend/src/routes/estabelecimentos.js
@@ -76,7 +76,7 @@ const toFiniteOrNull = (value) => {
 
   const num = Number(value);
 
-  return Number.isFinite(num) ? num : null;
+  return Number.isFinite(num)  num : null;
 
 };
 
@@ -102,7 +102,7 @@ function reviewerDisplayName(raw) {
   if (parts.length === 1) return parts[0];
   const first = parts[0];
   const lastInitial = parts[parts.length - 1][0];
-  return lastInitial ? `${first} ${lastInitial.toUpperCase()}.` : first;
+  return lastInitial  `${first} ${lastInitial.toUpperCase()}.` : first;
 }
 
 function reviewerInitials(raw) {
@@ -193,6 +193,29 @@ function normalizeString(value) {
     .replace(/[^a-z0-9]+/g, '');
 }
 
+const CLIENT_TAG_ALIASES = Object.freeze({
+  vip: 'VIP',
+  promocao: 'Promoção',
+  promo: 'Promoção',
+  atrasos: 'Atrasos',
+  atraso: 'Atrasos',
+});
+
+function normalizeClientTags(input) {
+  if (!Array.isArray(input)) return [];
+  const normalized = new Set();
+  for (const raw of input) {
+    if (raw == null) continue;
+    const trimmed = String(raw).trim();
+    if (!trimmed) continue;
+    const key = normalizeString(trimmed);
+    const mapped = CLIENT_TAG_ALIASES[key];
+    if (!mapped) continue;
+    normalized.add(mapped);
+  }
+  return Array.from(normalized);
+}
+
 function normalizeDaySlug(value) {
   const token = normalizeString(value);
   if (!token) return '';
@@ -212,7 +235,7 @@ function sanitizeTimeValue(value) {
   const directMatch = text.match(/^([01]?\d|2[0-3]):?([0-5]\d)?$/);
   if (directMatch) {
     const hours = directMatch[1];
-    const minutes = directMatch[2] ?? '00';
+    const minutes = directMatch[2]  '00';
     return `${hours.padStart(2, '0')}:${minutes.padStart(2, '0')}`;
   }
   const digits = text.replace(/\D/g, '');
@@ -260,9 +283,9 @@ function sanitizeHorariosInput(input) {
       continue;
     }
     if (typeof item === 'object') {
-      const label = String(item.label ?? item.day ?? item.dia ?? '').trim();
+      const label = String(item.label  item.day  item.dia  '').trim();
       let valueText = String(
-        item.value ?? item.horario ?? item.horarios ?? item.hours ?? item.text ?? ''
+        item.value  item.horario  item.horarios  item.hours  item.text  ''
       ).trim();
       if (!valueText && label) valueText = label;
       if (!valueText) continue;
@@ -278,17 +301,17 @@ function sanitizeHorariosInput(input) {
       }
 
       // Keep raw start/end hints when provided.
-      const startLike = item.start ?? item.begin ?? item.from ?? null;
-      const endLike = item.end ?? item.finish ?? item.to ?? null;
+      const startLike = item.start  item.begin  item.from  null;
+      const endLike = item.end  item.finish  item.to  null;
       if (startLike != null) normalizedEntry.start = startLike;
       if (endLike != null) normalizedEntry.end = endLike;
 
       // Preserve block/break metadata.
       const blocks =
         Array.isArray(item.blocks) && item.blocks.length
-          ? item.blocks
+           item.blocks
           : Array.isArray(item.breaks) && item.breaks.length
-          ? item.breaks
+           item.breaks
           : null;
       if (blocks) {
         normalizedEntry.blocks = blocks;
@@ -296,8 +319,8 @@ function sanitizeHorariosInput(input) {
       if (Array.isArray(item.breaks) && item.breaks.length) {
         normalizedEntry.breaks = item.breaks;
       }
-      const blockStart = item.block_start ?? item.blockStart ?? null;
-      const blockEnd = item.block_end ?? item.blockEnd ?? null;
+      const blockStart = item.block_start  item.blockStart  null;
+      const blockEnd = item.block_end  item.blockEnd  null;
       if (blockStart != null) normalizedEntry.block_start = blockStart;
       if (blockEnd != null) normalizedEntry.block_end = blockEnd;
 
@@ -313,14 +336,14 @@ function sanitizeHorariosInput(input) {
     let label = entry.label ? String(entry.label).trim() : '';
     let value = entry.value ? String(entry.value).trim() : '';
     const daySlug =
-      normalizeDaySlug(entry.day ?? entry.key ?? entry.weekday ?? entry.week_day ?? label) || '';
-    const defaultLabel = daySlug ? (WEEKDAY_LABEL_MAP[daySlug] || '') : '';
-    label = label ? label.slice(0, 60) : defaultLabel.slice(0, 60);
+      normalizeDaySlug(entry.day  entry.key  entry.weekday  entry.week_day  label) || '';
+    const defaultLabel = daySlug  (WEEKDAY_LABEL_MAP[daySlug] || '') : '';
+    label = label  label.slice(0, 60) : defaultLabel.slice(0, 60);
     if (!label && !value) continue;
-    value = value ? value.slice(0, 160) : label;
+    value = value  value.slice(0, 160) : label;
     if (!value) continue;
-    let start = sanitizeTimeValue(entry.start ?? entry.begin ?? entry.from ?? null);
-    let end = sanitizeTimeValue(entry.end ?? entry.finish ?? entry.to ?? null);
+    let start = sanitizeTimeValue(entry.start  entry.begin  entry.from  null);
+    let end = sanitizeTimeValue(entry.end  entry.finish  entry.to  null);
     if (start && end && start > end) {
       const temp = start;
       start = end;
@@ -332,21 +355,21 @@ function sanitizeHorariosInput(input) {
     if (end) sanitizedEntry.end = end;
 
     const rawBlocks = Array.isArray(entry.blocks)
-      ? entry.blocks
+       entry.blocks
       : Array.isArray(entry.breaks)
-      ? entry.breaks
+       entry.breaks
       : entry.block_start || entry.blockStart || entry.block_end || entry.blockEnd
-      ? [{
-          start: entry.block_start ?? entry.blockStart ?? null,
-          end: entry.block_end ?? entry.blockEnd ?? null,
+       [{
+          start: entry.block_start  entry.blockStart  null,
+          end: entry.block_end  entry.blockEnd  null,
         }]
       : [];
 
     const sanitizedBlocks = [];
     for (const block of rawBlocks) {
       if (!block) continue;
-      const blockStart = sanitizeTimeValue(block.start ?? block.begin ?? block.from ?? null);
-      const blockEnd = sanitizeTimeValue(block.end ?? block.finish ?? block.to ?? null);
+      const blockStart = sanitizeTimeValue(block.start  block.begin  block.from  null);
+      const blockEnd = sanitizeTimeValue(block.end  block.finish  block.to  null);
       if (!blockStart || !blockEnd) continue;
       if (blockStart >= blockEnd) continue;
       if (start && blockStart < start) continue;
@@ -366,7 +389,7 @@ function sanitizeHorariosInput(input) {
     if (sanitized.length >= 20) break;
   }
 
-  return sanitized.length ? JSON.stringify(sanitized) : null;
+  return sanitized.length  JSON.stringify(sanitized) : null;
 }
 
 function buildProfileUpdatePayload(body = {}) {
@@ -375,46 +398,46 @@ function buildProfileUpdatePayload(body = {}) {
   const sobre = sanitizePlainText(body.sobre, { maxLength: 1200, allowNewLines: true });
 
   const contato_telefone =
-    body.contato_telefone != null ? sanitizePhone(body.contato_telefone) : null;
+    body.contato_telefone != null  sanitizePhone(body.contato_telefone) : null;
   if (body.contato_telefone && !contato_telefone) {
     errors.push({ field: 'contato_telefone', code: 'invalid_phone' });
   }
 
-  const site_url = body.site_url != null ? sanitizeUrl(body.site_url) : null;
+  const site_url = body.site_url != null  sanitizeUrl(body.site_url) : null;
   if (body.site_url && !site_url) {
     errors.push({ field: 'site_url', code: 'invalid_url' });
   }
 
-  const instagram_url = body.instagram_url != null ? sanitizeUrl(body.instagram_url) : null;
+  const instagram_url = body.instagram_url != null  sanitizeUrl(body.instagram_url) : null;
   if (body.instagram_url && !instagram_url) {
     errors.push({ field: 'instagram_url', code: 'invalid_url' });
   }
 
-  const facebook_url = body.facebook_url != null ? sanitizeUrl(body.facebook_url) : null;
+  const facebook_url = body.facebook_url != null  sanitizeUrl(body.facebook_url) : null;
   if (body.facebook_url && !facebook_url) {
     errors.push({ field: 'facebook_url', code: 'invalid_url' });
   }
 
-  const linkedin_url = body.linkedin_url != null ? sanitizeUrl(body.linkedin_url) : null;
+  const linkedin_url = body.linkedin_url != null  sanitizeUrl(body.linkedin_url) : null;
   if (body.linkedin_url && !linkedin_url) {
     errors.push({ field: 'linkedin_url', code: 'invalid_url' });
   }
 
-  const youtube_url = body.youtube_url != null ? sanitizeUrl(body.youtube_url) : null;
+  const youtube_url = body.youtube_url != null  sanitizeUrl(body.youtube_url) : null;
   if (body.youtube_url && !youtube_url) {
     errors.push({ field: 'youtube_url', code: 'invalid_url' });
   }
 
-  const tiktok_url = body.tiktok_url != null ? sanitizeUrl(body.tiktok_url) : null;
+  const tiktok_url = body.tiktok_url != null  sanitizeUrl(body.tiktok_url) : null;
   if (body.tiktok_url && !tiktok_url) {
     errors.push({ field: 'tiktok_url', code: 'invalid_url' });
   }
 
   const horariosInput =
-    body.horarios ??
-    body.horarios_json ??
-    body.horarios_raw ??
-    (typeof body.horarios_text === 'string' ? body.horarios_text : null);
+    body.horarios ?
+    body.horarios_json ?
+    body.horarios_raw ?
+    (typeof body.horarios_text === 'string'  body.horarios_text : null);
   const horarios_json = sanitizeHorariosInput(horariosInput);
 
   return {
@@ -449,7 +472,7 @@ async function resolveViewerFromRequest(req) {
 
     const [rows] = await pool.query(
 
-      "SELECT id, nome, tipo, email FROM usuarios WHERE id=? LIMIT 1",
+      "SELECT id, nome, tipo, email FROM usuarios WHERE id= LIMIT 1",
 
       [userId]
 
@@ -507,38 +530,38 @@ function parseHorarios(value) {
           }
 
           if (typeof item === 'object') {
-            const label = String(item.label ?? item.day ?? item.dia ?? '').trim();
-            const valueText = String(item.value ?? item.horario ?? item.horarios ?? item.hours ?? '').trim();
+            const label = String(item.label  item.day  item.dia  '').trim();
+            const valueText = String(item.value  item.horario  item.horarios  item.hours  '').trim();
             if (!label && !valueText) return null;
             const daySlug = normalizeDaySlug(
-              item.day ?? item.key ?? item.weekday ?? item.week_day ?? label
+              item.day  item.key  item.weekday  item.week_day  label
             );
             let resolvedLabel = label;
             if (!resolvedLabel && daySlug && WEEKDAY_LABEL_MAP[daySlug]) {
               resolvedLabel = WEEKDAY_LABEL_MAP[daySlug];
             }
-            let start = sanitizeTimeValue(item.start ?? item.begin ?? item.from ?? null);
-            let end = sanitizeTimeValue(item.end ?? item.finish ?? item.to ?? null);
+            let start = sanitizeTimeValue(item.start  item.begin  item.from  null);
+            let end = sanitizeTimeValue(item.end  item.finish  item.to  null);
             if (start && end && start > end) {
               const temp = start;
               start = end;
               end = temp;
             }
             const rawBlocks = Array.isArray(item.blocks)
-              ? item.blocks
+               item.blocks
               : Array.isArray(item.breaks)
-              ? item.breaks
+               item.breaks
               : item.block_start || item.blockStart || item.block_end || item.blockEnd
-              ? [{
-                  start: item.block_start ?? item.blockStart ?? null,
-                  end: item.block_end ?? item.blockEnd ?? null,
+               [{
+                  start: item.block_start  item.blockStart  null,
+                  end: item.block_end  item.blockEnd  null,
                 }]
               : [];
             const sanitizedBlocks = [];
             for (const block of rawBlocks) {
               if (!block) continue;
-              const blockStart = sanitizeTimeValue(block.start ?? block.begin ?? block.from ?? null);
-              const blockEnd = sanitizeTimeValue(block.end ?? block.finish ?? block.to ?? null);
+              const blockStart = sanitizeTimeValue(block.start  block.begin  block.from  null);
+              const blockEnd = sanitizeTimeValue(block.end  block.finish  block.to  null);
               if (!blockStart || !blockEnd) continue;
               if (blockStart >= blockEnd) continue;
               if (start && blockStart < start) continue;
@@ -570,7 +593,7 @@ function parseHorarios(value) {
         .map(([key, val]) => {
 
           const label = String(key || '').trim();
-          const valueText = String(val ?? '').trim();
+          const valueText = String(val  '').trim();
           if (!label && !valueText) return null;
           return { label, value: valueText || label, day: normalizeDaySlug(label) || null, start: null, end: null };
         })
@@ -650,7 +673,7 @@ function normalizeProfile(establishmentRow, profileRow) {
 
   }
 
-  const updatedAt = profileRow.updated_at ? new Date(profileRow.updated_at) : null;
+  const updatedAt = profileRow.updated_at  new Date(profileRow.updated_at) : null;
 
   return {
 
@@ -674,7 +697,7 @@ function normalizeProfile(establishmentRow, profileRow) {
 
     horarios_raw: profileRow.horarios_json || null,
 
-    updated_at: updatedAt && !Number.isNaN(updatedAt.getTime()) ? updatedAt.toISOString() : null,
+    updated_at: updatedAt && !Number.isNaN(updatedAt.getTime())  updatedAt.toISOString() : null,
 
   };
 
@@ -688,8 +711,8 @@ function normalizeGalleryImage(row) {
     url: row.file_path,
     titulo: row.titulo || null,
     descricao: row.descricao || null,
-    ordem: Number.isFinite(row.ordem) ? Number(row.ordem) : 0,
-    created_at: row.created_at ? new Date(row.created_at).toISOString() : null,
+    ordem: Number.isFinite(row.ordem)  Number(row.ordem) : 0,
+    created_at: row.created_at  new Date(row.created_at).toISOString() : null,
   };
 }
 
@@ -731,7 +754,7 @@ function sanitizeGalleryText(value, { maxLength = 255 } = {}) {
 function resolveGalleryLimit(planContext) {
   const limit = planContext?.config?.maxGalleryImages;
   if (limit === null || limit === undefined) return null;
-  return Number.isFinite(limit) ? limit : null;
+  return Number.isFinite(limit)  limit : null;
 }
 
 
@@ -748,7 +771,7 @@ async function getRatingSummary(estabelecimentoId) {
 
   const [distRows] = await pool.query(
 
-    "SELECT nota, COUNT(*) AS total FROM estabelecimento_reviews WHERE estabelecimento_id=? GROUP BY nota",
+    "SELECT nota, COUNT(*) AS total FROM estabelecimento_reviews WHERE estabelecimento_id= GROUP BY nota",
 
     [estabelecimentoId]
 
@@ -798,7 +821,7 @@ async function fetchUserReview(estabelecimentoId, clienteId) {
 
   const [rows] = await pool.query(
 
-    "SELECT nota, comentario, updated_at FROM estabelecimento_reviews WHERE estabelecimento_id=? AND cliente_id=? LIMIT 1",
+    "SELECT nota, comentario, updated_at FROM estabelecimento_reviews WHERE estabelecimento_id= AND cliente_id= LIMIT 1",
 
     [estabelecimentoId, clienteId]
 
@@ -810,15 +833,15 @@ async function fetchUserReview(estabelecimentoId, clienteId) {
 
   const nota = Number(row.nota);
 
-  const updatedAt = row.updated_at ? new Date(row.updated_at) : null;
+  const updatedAt = row.updated_at  new Date(row.updated_at) : null;
 
   return {
 
-    nota: Number.isFinite(nota) ? nota : null,
+    nota: Number.isFinite(nota)  nota : null,
 
     comentario: row.comentario || null,
 
-    updated_at: updatedAt && !Number.isNaN(updatedAt.getTime()) ? updatedAt.toISOString() : null,
+    updated_at: updatedAt && !Number.isNaN(updatedAt.getTime())  updatedAt.toISOString() : null,
 
   };
 
@@ -830,7 +853,7 @@ async function isFavoriteFor(estabelecimentoId, clienteId) {
 
   const [rows] = await pool.query(
 
-    "SELECT 1 FROM cliente_favoritos WHERE estabelecimento_id=? AND cliente_id=? LIMIT 1",
+    "SELECT 1 FROM cliente_favoritos WHERE estabelecimento_id= AND cliente_id= LIMIT 1",
 
     [estabelecimentoId, clienteId]
 
@@ -850,7 +873,7 @@ async function ensureEstabelecimento(estabelecimentoId) {
 
   const [rows] = await pool.query(
 
-    "SELECT id, nome, email, telefone FROM usuarios WHERE id=? AND tipo='estabelecimento' LIMIT 1",
+    "SELECT id, nome, email, telefone FROM usuarios WHERE id= AND tipo='estabelecimento' LIMIT 1",
 
     [id]
 
@@ -870,9 +893,9 @@ async function attachCoordinates(rows, includeCoords) {
 
   for (const est of rows) {
 
-    const lat = toFiniteOrNull(est?.latitude ?? est?.lat ?? est?.coord_lat);
+    const lat = toFiniteOrNull(est?.latitude  est?.lat  est?.coord_lat);
 
-    const lng = toFiniteOrNull(est?.longitude ?? est?.lng ?? est?.coord_lng);
+    const lng = toFiniteOrNull(est?.longitude  est?.lng  est?.coord_lng);
 
     if (lat !== null && lng !== null) {
 
@@ -898,9 +921,9 @@ async function attachCoordinates(rows, includeCoords) {
 
       ...est,
 
-      latitude: coords?.lat ?? null,
+      latitude: coords?.lat  null,
 
-      longitude: coords?.lng ?? null,
+      longitude: coords?.lng  null,
 
     });
 
@@ -921,9 +944,9 @@ async function listEstablishmentsHandler(req, res) {
     const pageRaw = Number(req.query?.page);
     const limitRaw = Number(req.query?.limit);
 
-    const page = Number.isFinite(pageRaw) && pageRaw > 0 ? Math.floor(pageRaw) : 1;
+    const page = Number.isFinite(pageRaw) && pageRaw > 0  Math.floor(pageRaw) : 1;
     const limit = Number.isFinite(limitRaw) && limitRaw > 0
-      ? Math.min(Math.floor(limitRaw), MAX_PAGE_SIZE)
+       Math.min(Math.floor(limitRaw), MAX_PAGE_SIZE)
       : DEFAULT_PAGE_SIZE;
     const offset = (page - 1) * limit;
 
@@ -947,20 +970,20 @@ async function listEstablishmentsHandler(req, res) {
       tokens.forEach((token) => {
         const like = `%${token}%`;
         where.push(
-          '(LOWER(u.nome) LIKE ? OR LOWER(u.bairro) LIKE ? OR LOWER(u.cidade) LIKE ? OR LOWER(u.estado) LIKE ? OR LOWER(u.cep) LIKE ? OR LOWER(u.endereco) LIKE ? OR LOWER(u.numero) LIKE ? OR LOWER(u.email) LIKE ?)'
+          '(LOWER(u.nome) LIKE  OR LOWER(u.bairro) LIKE  OR LOWER(u.cidade) LIKE  OR LOWER(u.estado) LIKE  OR LOWER(u.cep) LIKE  OR LOWER(u.endereco) LIKE  OR LOWER(u.numero) LIKE  OR LOWER(u.email) LIKE ?)'
         );
         params.push(like, like, like, like, like, like, like, like);
       });
     }
 
     const whereSql = `WHERE ${where.join(' AND ')}`;
-    const sql = `${LIST_SELECT} ${whereSql} ${LIST_ORDER} LIMIT ? OFFSET ?`;
+    const sql = `${LIST_SELECT} ${whereSql} ${LIST_ORDER} LIMIT  OFFSET ?`;
 
     const [rows] = await pool.query(sql, [...params, limit + 1, offset]);
     const hasMore = rows.length > limit;
     const pageRows = rows.slice(0, limit);
 
-    const includeCoords = String((req.query?.coords ?? '1')).toLowerCase() !== '0';
+    const includeCoords = String((req.query?.coords  '1')).toLowerCase() !== '0';
     const payload = await attachCoordinates(pageRows, includeCoords);
 
     res.json({ items: payload, page, limit, has_more: hasMore });
@@ -1001,7 +1024,7 @@ router.get('/:idOrSlug', async (req, res) => {
 
       [rows] = await pool.query(
 
-        "SELECT id, nome, email, telefone, slug, avatar_url, plan, plan_status, plan_trial_ends_at, plan_active_until, plan_subscription_id FROM usuarios WHERE id=? AND tipo='estabelecimento' LIMIT 1",
+        "SELECT id, nome, email, telefone, slug, avatar_url, plan, plan_status, plan_trial_ends_at, plan_active_until, plan_subscription_id FROM usuarios WHERE id= AND tipo='estabelecimento' LIMIT 1",
 
         [id]
 
@@ -1011,7 +1034,7 @@ router.get('/:idOrSlug', async (req, res) => {
 
       [rows] = await pool.query(
 
-        "SELECT id, nome, email, telefone, slug, avatar_url, plan, plan_status, plan_trial_ends_at, plan_active_until, plan_subscription_id FROM usuarios WHERE slug=? AND tipo='estabelecimento' LIMIT 1",
+        "SELECT id, nome, email, telefone, slug, avatar_url, plan, plan_status, plan_trial_ends_at, plan_active_until, plan_subscription_id FROM usuarios WHERE slug= AND tipo='estabelecimento' LIMIT 1",
 
         [idOrSlug]
 
@@ -1035,7 +1058,7 @@ router.get('/:idOrSlug', async (req, res) => {
 
       pool.query(
 
-        "SELECT estabelecimento_id, sobre, contato_telefone, site_url, instagram_url, facebook_url, linkedin_url, youtube_url, tiktok_url, horarios_json, updated_at FROM estabelecimento_perfis WHERE estabelecimento_id=? LIMIT 1",
+        "SELECT estabelecimento_id, sobre, contato_telefone, site_url, instagram_url, facebook_url, linkedin_url, youtube_url, tiktok_url, horarios_json, updated_at FROM estabelecimento_perfis WHERE estabelecimento_id= LIMIT 1",
 
         [est.id]
 
@@ -1154,9 +1177,9 @@ router.get('/:id/reviews', async (req, res) => {
     if (!est) return res.status(404).json({ error: 'not_found' });
 
     const pageParam = Number(req.query?.page);
-    const limitParam = Number(req.query?.limit ?? req.query?.per_page);
-    const page = Number.isFinite(pageParam) && pageParam > 0 ? Math.floor(pageParam) : 1;
-    const perPageRaw = Number.isFinite(limitParam) && limitParam > 0 ? Math.floor(limitParam) : 10;
+    const limitParam = Number(req.query?.limit  req.query?.per_page);
+    const page = Number.isFinite(pageParam) && pageParam > 0  Math.floor(pageParam) : 1;
+    const perPageRaw = Number.isFinite(limitParam) && limitParam > 0  Math.floor(limitParam) : 10;
     const perPage = Math.max(1, Math.min(perPageRaw, 50));
     const offset = (page - 1) * perPage;
 
@@ -1165,7 +1188,7 @@ router.get('/:id/reviews', async (req, res) => {
       [estabelecimentoId]
     );
     const total = Number(countRow?.total || 0);
-    const totalPages = total > 0 ? Math.ceil(total / perPage) : 0;
+    const totalPages = total > 0  Math.ceil(total / perPage) : 0;
 
     const [rows] = await pool.query(
       `SELECT r.id, r.nota, r.comentario, r.created_at, r.updated_at,
@@ -1174,17 +1197,17 @@ router.get('/:id/reviews', async (req, res) => {
          JOIN usuarios u ON u.id = r.cliente_id
         WHERE r.estabelecimento_id=?
         ORDER BY r.updated_at DESC, r.id DESC
-        LIMIT ? OFFSET ?`,
+        LIMIT  OFFSET ?`,
       [estabelecimentoId, perPage, offset]
     );
 
     const items = rows.map((row) => {
-      const commentRaw = typeof row.comentario === 'string' ? row.comentario.trim() : null;
-      const comment = commentRaw ? commentRaw : null;
+      const commentRaw = typeof row.comentario === 'string'  row.comentario.trim() : null;
+      const comment = commentRaw  commentRaw : null;
       const nota = Number(row.nota);
       return {
         id: row.id,
-        nota: Number.isFinite(nota) ? nota : null,
+        nota: Number.isFinite(nota)  nota : null,
         comentario: comment,
         created_at: toISODate(row.created_at),
         updated_at: toISODate(row.updated_at),
@@ -1265,7 +1288,7 @@ router.put('/:id/profile', auth, isEstabelecimento, async (req, res) => {
               site_url, instagram_url, facebook_url, linkedin_url,
               youtube_url, tiktok_url, horarios_json, updated_at
          FROM estabelecimento_perfis
-        WHERE estabelecimento_id=? LIMIT 1`,
+        WHERE estabelecimento_id= LIMIT 1`,
       [estabelecimentoId]
     );
     const profile = normalizeProfile(est, profileRows?.[0] || null);
@@ -1309,16 +1332,67 @@ router.get('/:id/clients', auth, isEstabelecimento, async (req, res) => {
     const offset = (page - 1) * pageSize;
     const searchRaw = String(req.query.q || '').trim().toLowerCase();
     const searchDigits = searchRaw.replace(/\D/g, '');
+    const statusParam = String(req.query.status || '').trim().toLowerCase();
+    const statusTokens = statusParam
+       statusParam.split(',').map((token) => token.trim()).filter(Boolean)
+      : [];
+    const statusMap = {
+      confirmado: ['confirmado'],
+      cancelado: ['cancelado'],
+      pendente: ['pendente', 'pendente_pagamento'],
+      concluido: ['concluido'],
+    };
+    const allowedStatuses = new Set([
+      'confirmado',
+      'cancelado',
+      'pendente',
+      'pendente_pagamento',
+      'concluido',
+    ]);
+    const statusValues = Array.from(
+      new Set(
+        statusTokens.flatMap((token) => statusMap[token] || (allowedStatuses.has(token)  [token] : []))
+      )
+    );
+    const vipOnly = ['1', 'true', 'sim', 'yes', 'on'].includes(String(req.query.vip || '').toLowerCase());
+    const riskOnly = ['1', 'true', 'sim', 'yes', 'on'].includes(String(req.query.risk || '').toLowerCase());
+    const riskDaysRaw = Number(req.query.riskDays || req.query.risk_days || 60);
+    const riskDays = Number.isFinite(riskDaysRaw)
+       Math.min(3650, Math.max(1, Math.round(riskDaysRaw)))
+      : 60;
+    const sortParam = String(req.query.sort || '').trim().toLowerCase();
+    const dirParam = String(req.query.dir || '').trim().toLowerCase();
+    const sortDir = dirParam === 'asc'  'ASC' : 'DESC';
+    const sortMap = {
+      last: 'stats.last_appointment_at',
+      appointments: 'stats.total_appointments',
+      cancelled: 'stats.total_cancelled',
+      name: 'u.nome',
+    };
+    const sortKey = sortMap[sortParam] || sortMap.last;
+    const orderBy = `${sortKey} ${sortDir}, u.nome ASC`;
+    const riskExpr =
+      `(stats.last_appointment_at < DATE_SUB(NOW(), INTERVAL ${riskDays} DAY)` +
+      ` OR (stats.total_appointments >= 3 AND (stats.total_cancelled / NULLIF(stats.total_appointments, 0)) > 0.4))`;
 
     const searchClauses = [];
     const searchParams = [];
     if (searchRaw) {
       const like = `%${searchRaw}%`;
       const telLike = `%${searchDigits || searchRaw.replace(/\s+/g, '')}%`;
-      searchClauses.push(`(LOWER(u.nome) LIKE ? OR LOWER(u.email) LIKE ? OR REPLACE(REPLACE(REPLACE(u.telefone,'+',''),'-',''),' ','') LIKE ?)`);
+      searchClauses.push(`(LOWER(u.nome) LIKE  OR LOWER(u.email) LIKE  OR REPLACE(REPLACE(REPLACE(u.telefone,'+',''),'-',''),' ','') LIKE ?)`);
       searchParams.push(like, like, telLike);
     }
-    const searchWhere = searchClauses.length ? `WHERE ${searchClauses.join(' AND ')}` : '';
+    const whereClauses = [...searchClauses];
+    const whereParams = [...searchParams];
+    if (statusValues.length) {
+      const placeholders = statusValues.map(() => '?').join(', ');
+      whereClauses.push(`stats.last_status IN (${placeholders})`);
+      whereParams.push(...statusValues);
+    }
+    if (vipOnly) whereClauses.push('vip.is_vip = 1');
+    if (riskOnly) whereClauses.push(riskExpr);
+    const whereSql = whereClauses.length  `WHERE ${whereClauses.join(' AND ')}` : '';
 
     const statsSql = `
       SELECT
@@ -1332,14 +1406,23 @@ router.get('/:id/clients', auth, isEstabelecimento, async (req, res) => {
       WHERE a.estabelecimento_id=?
       GROUP BY a.cliente_id
     `;
+    const vipJoinSql = `
+      LEFT JOIN (
+        SELECT DISTINCT cliente_id, 1 AS is_vip
+        FROM cliente_tags
+        WHERE estabelecimento_id= AND tag='VIP'
+      ) vip ON vip.cliente_id = stats.cliente_id
+    `;
 
     const countSql = `
       SELECT COUNT(*) AS total
       FROM (${statsSql}) stats
       JOIN usuarios u ON u.id = stats.cliente_id
-      ${searchWhere}
+      ${vipJoinSql}
+      ${whereSql}
     `;
-    const [countRows] = await pool.query(countSql, [estabelecimentoId, ...searchParams]);
+    const countParams = [estabelecimentoId, estabelecimentoId, ...whereParams];
+    const [countRows] = await pool.query(countSql, countParams);
     const total = Number(countRows?.[0]?.total || 0);
 
     const dataSql = `
@@ -1360,14 +1443,18 @@ router.get('/:id/clients', auth, isEstabelecimento, async (req, res) => {
         stats.total_cancelled,
         stats.last_appointment_at,
         stats.last_status,
-        stats.last_appointment_id
+        stats.last_appointment_id,
+        IFNULL(vip.is_vip, 0) AS is_vip,
+        CASE WHEN ${riskExpr} THEN 1 ELSE 0 END AS is_at_risk
       FROM (${statsSql}) stats
       JOIN usuarios u ON u.id = stats.cliente_id
-      ${searchWhere}
-      ORDER BY stats.last_appointment_at DESC
-      LIMIT ? OFFSET ?
+      ${vipJoinSql}
+      ${whereSql}
+      ORDER BY ${orderBy}
+      LIMIT  OFFSET ?
     `;
-    const [rows] = await pool.query(dataSql, [estabelecimentoId, ...searchParams, pageSize, offset]);
+    const dataParams = [...countParams, pageSize, offset];
+    const [rows] = await pool.query(dataSql, dataParams);
     const lastAppointmentIds = Array.from(
       new Set(
         (rows || [])
@@ -1399,12 +1486,47 @@ router.get('/:id/clients', auth, isEstabelecimento, async (req, res) => {
       return { ...rest, last_service: serviceLabel };
     });
 
+    const periodParam = String(req.query.period || '').trim().toLowerCase();
+    const PERIOD_DAYS = { '7d': 7, '30d': 30, '90d': 90 };
+    const periodDays = PERIOD_DAYS[periodParam] || null;
+    const periodStart = periodDays  new Date(Date.now() - periodDays * 86400000) : null;
+    const periodFilterSql = periodStart  'a.inicio >= ?' : '1=1';
+    const kpiSql = `
+      SELECT
+        COUNT(DISTINCT CASE WHEN ${periodFilterSql} THEN a.cliente_id END) AS clients,
+        SUM(CASE WHEN ${periodFilterSql} THEN 1 ELSE 0 END) AS appointments,
+        SUM(CASE WHEN ${periodFilterSql} AND a.status='cancelado' THEN 1 ELSE 0 END) AS cancelled,
+        SUM(CASE WHEN ${periodFilterSql} AND a.status<>'cancelado' THEN a.total_centavos ELSE 0 END) AS revenue_centavos,
+        SUM(CASE WHEN ${periodFilterSql} AND a.status<>'cancelado' THEN 1 ELSE 0 END) AS ticket_base
+      FROM agendamentos a
+      WHERE a.estabelecimento_id=?
+    `;
+    const kpiParams = [];
+    if (periodStart) {
+      for (let i = 0; i < 5; i += 1) kpiParams.push(periodStart);
+    }
+    kpiParams.push(estabelecimentoId);
+    const [[kpiRow]] = await pool.query(kpiSql, kpiParams);
+    const appointments = Number(kpiRow?.appointments || 0);
+    const cancelled = Number(kpiRow?.cancelled || 0);
+    const revenueCentavos = Number(kpiRow?.revenue_centavos || 0);
+    const ticketBase = Number(kpiRow?.ticket_base || 0);
+
     return res.json({
       items,
       page,
       pageSize,
       total,
       hasNext: offset + (rows?.length || 0) < total,
+      aggregations: {
+        period: periodDays  periodParam : 'all',
+        clients: Number(kpiRow?.clients || 0),
+        appointments,
+        cancelled,
+        cancel_rate: appointments  Math.round((cancelled / appointments) * 100) : 0,
+        revenue_centavos: revenueCentavos,
+        ticket_medio_centavos: ticketBase  Math.round(revenueCentavos / Math.max(ticketBase, 1)) : null,
+      },
     });
   } catch (err) {
     console.error('GET /establishments/:id/clients', err);
@@ -1412,6 +1534,248 @@ router.get('/:id/clients', auth, isEstabelecimento, async (req, res) => {
   }
 });
 
+// Detalhes do cliente (drawer CRM)
+router.get('/:id/clients/:clientId/details', auth, isEstabelecimento, async (req, res) => {
+  try {
+    const estabelecimentoId = Number(req.params.id);
+    const clientId = Number(req.params.clientId);
+    if (!Number.isFinite(estabelecimentoId) || req.user.id !== estabelecimentoId) {
+      return res.status(403).json({ error: 'forbidden' });
+    }
+    if (!Number.isFinite(clientId)) {
+      return res.status(400).json({ error: 'invalid_client' });
+    }
+
+    const [[clientRow]] = await pool.query(
+      `SELECT u.id, u.nome, u.email, u.telefone, u.data_nascimento,
+              u.cep, u.endereco, u.numero, u.complemento, u.bairro, u.cidade, u.estado
+         FROM usuarios u
+         JOIN agendamentos a ON a.cliente_id = u.id AND a.estabelecimento_id = ?
+        WHERE u.id = ?
+        LIMIT 1`,
+      [estabelecimentoId, clientId]
+    );
+    if (!clientRow) {
+      return res.status(404).json({ error: 'not_found' });
+    }
+
+    const [[notesRow]] = await pool.query(
+      'SELECT notas FROM cliente_notas WHERE estabelecimento_id= AND cliente_id= LIMIT 1',
+      [estabelecimentoId, clientId]
+    );
+    const [tagRows] = await pool.query(
+      'SELECT tag FROM cliente_tags WHERE estabelecimento_id= AND cliente_id= ORDER BY tag ASC',
+      [estabelecimentoId, clientId]
+    );
+    const tags = (tagRows || []).map((row) => row.tag).filter(Boolean);
+
+    const periodParam = String(req.query.period || '').trim().toLowerCase();
+    const PERIOD_DAYS = { '7d': 7, '30d': 30, '90d': 90 };
+    const periodDays = PERIOD_DAYS[periodParam] || null;
+    const periodStart = periodDays  new Date(Date.now() - periodDays * 86400000) : null;
+    const periodFilterSql = periodStart  'a.inicio >= ?' : '1=1';
+
+    const metricsSql = `
+      SELECT
+        COUNT(*) AS total_appointments,
+        SUM(a.status='cancelado') AS total_cancelled,
+        SUM(CASE WHEN ${periodFilterSql} THEN 1 ELSE 0 END) AS period_appointments,
+        SUM(CASE WHEN ${periodFilterSql} AND a.status='cancelado' THEN 1 ELSE 0 END) AS period_cancelled,
+        SUM(CASE WHEN ${periodFilterSql} AND a.status<>'cancelado' THEN a.total_centavos ELSE 0 END) AS period_revenue_centavos,
+        SUM(CASE WHEN ${periodFilterSql} AND a.status<>'cancelado' THEN 1 ELSE 0 END) AS period_ticket_base
+      FROM agendamentos a
+      WHERE a.estabelecimento_id= AND a.cliente_id=?
+    `;
+    const metricsParams = [];
+    if (periodStart) {
+      for (let i = 0; i < 4; i += 1) metricsParams.push(periodStart);
+    }
+    metricsParams.push(estabelecimentoId, clientId);
+    const [[metricsRow]] = await pool.query(metricsSql, metricsParams);
+
+    const historyLimit = Math.min(20, Math.max(10, Number(req.query.limit || 20)));
+    const historySql = `
+      SELECT
+        a.id,
+        a.inicio,
+        a.fim,
+        a.status,
+        a.total_centavos,
+        p.nome AS profissional_nome,
+        COALESCE(NULLIF(GROUP_CONCAT(s.nome ORDER BY ai.ordem SEPARATOR ' + '), ''), s0.nome) AS service_label
+      FROM agendamentos a
+      LEFT JOIN agendamento_itens ai ON ai.agendamento_id = a.id
+      LEFT JOIN servicos s ON s.id = ai.servico_id
+      LEFT JOIN servicos s0 ON s0.id = a.servico_id
+      LEFT JOIN profissionais p ON p.id = a.profissional_id
+      WHERE a.estabelecimento_id= AND a.cliente_id=?
+      GROUP BY a.id, s0.nome, p.nome
+      ORDER BY a.inicio DESC
+      LIMIT ?
+    `;
+    const [historyRows] = await pool.query(historySql, [estabelecimentoId, clientId, historyLimit]);
+    const history = (historyRows || []).map((row) => ({
+      id: row.id,
+      inicio: row.inicio,
+      fim: row.fim,
+      status: row.status,
+      total_centavos: Number(row.total_centavos || 0),
+      profissional: row.profissional_nome || null,
+      servico: row.service_label || null,
+    }));
+
+    const frequencySql = `
+      SELECT
+        COALESCE(s.nome, s0.nome) AS service_label,
+        COUNT(*) AS total
+      FROM agendamentos a
+      LEFT JOIN agendamento_itens ai ON ai.agendamento_id = a.id
+      LEFT JOIN servicos s ON s.id = ai.servico_id
+      LEFT JOIN servicos s0 ON s0.id = a.servico_id
+      WHERE a.estabelecimento_id= AND a.cliente_id=?
+      ${periodStart  'AND a.inicio >= ?' : ''}
+      GROUP BY service_label
+      ORDER BY total DESC, service_label ASC
+      LIMIT 3
+    `;
+    const frequencyParams = periodStart
+       [estabelecimentoId, clientId, periodStart]
+      : [estabelecimentoId, clientId];
+    const [frequencyRows] = await pool.query(frequencySql, frequencyParams);
+    const frequent_services = (frequencyRows || [])
+      .map((row) => ({
+        nome: row.service_label || null,
+        total: Number(row.total || 0),
+      }))
+      .filter((row) => row.nome);
+
+    const totalAppointments = Number(metricsRow?.total_appointments || 0);
+    const totalCancelled = Number(metricsRow?.total_cancelled || 0);
+    const periodAppointments = Number(metricsRow?.period_appointments || 0);
+    const periodCancelled = Number(metricsRow?.period_cancelled || 0);
+    const periodRevenue = Number(metricsRow?.period_revenue_centavos || 0);
+    const periodTicketBase = Number(metricsRow?.period_ticket_base || 0);
+    const baseAppointments = periodStart  periodAppointments : totalAppointments;
+    const baseCancelled = periodStart  periodCancelled : totalCancelled;
+    const cancelRate = baseAppointments  Math.round((baseCancelled / baseAppointments) * 100) : 0;
+    const lastItem = history[0] || null;
+
+    return res.json({
+      cliente: clientRow,
+      notes: notesRow?.notas || null,
+      tags,
+      metrics: {
+        period: periodDays  periodParam : 'all',
+        total_appointments: baseAppointments,
+        total_cancelled: baseCancelled,
+        cancel_rate: cancelRate,
+        last_appointment_at: lastItem?.inicio || null,
+        last_status: lastItem?.status || null,
+        last_service: lastItem?.servico || null,
+        revenue_centavos: periodRevenue,
+        ticket_medio_centavos: periodTicketBase  Math.round(periodRevenue / Math.max(periodTicketBase, 1)) : null,
+      },
+      frequent_services,
+      history,
+    });
+  } catch (err) {
+    console.error('GET /establishments/:id/clients/:clientId/details', err);
+    return res.status(500).json({ error: 'client_details_failed' });
+  }
+});
+
+router.put('/:id/clients/:clientId/notes', auth, isEstabelecimento, async (req, res) => {
+  try {
+    const estabelecimentoId = Number(req.params.id);
+    const clientId = Number(req.params.clientId);
+    if (!Number.isFinite(estabelecimentoId) || req.user.id !== estabelecimentoId) {
+      return res.status(403).json({ error: 'forbidden' });
+    }
+    if (!Number.isFinite(clientId)) {
+      return res.status(400).json({ error: 'invalid_client' });
+    }
+
+    const [[exists]] = await pool.query(
+      'SELECT 1 FROM agendamentos WHERE estabelecimento_id= AND cliente_id= LIMIT 1',
+      [estabelecimentoId, clientId]
+    );
+    if (!exists) return res.status(404).json({ error: 'not_found' });
+
+    const notesRaw = req.body?.notes  req.body?.nota  req.body?.observacao  null;
+    const notes = sanitizePlainText(notesRaw, { maxLength: 1200, allowNewLines: true });
+
+    if (!notes) {
+      await pool.query('DELETE FROM cliente_notas WHERE estabelecimento_id= AND cliente_id=?', [
+        estabelecimentoId,
+        clientId,
+      ]);
+      return res.json({ ok: true, notes: null });
+    }
+
+    await pool.query(
+      `INSERT INTO cliente_notas (estabelecimento_id, cliente_id, notas)
+       VALUES (?,?,?)
+       ON DUPLICATE KEY UPDATE notas=VALUES(notas), updated_at=CURRENT_TIMESTAMP`,
+      [estabelecimentoId, clientId, notes]
+    );
+
+    return res.json({ ok: true, notes });
+  } catch (err) {
+    console.error('PUT /establishments/:id/clients/:clientId/notes', err);
+    return res.status(500).json({ error: 'client_notes_failed' });
+  }
+});
+
+router.put('/:id/clients/:clientId/tags', auth, isEstabelecimento, async (req, res) => {
+  try {
+    const estabelecimentoId = Number(req.params.id);
+    const clientId = Number(req.params.clientId);
+    if (!Number.isFinite(estabelecimentoId) || req.user.id !== estabelecimentoId) {
+      return res.status(403).json({ error: 'forbidden' });
+    }
+    if (!Number.isFinite(clientId)) {
+      return res.status(400).json({ error: 'invalid_client' });
+    }
+
+    const [[exists]] = await pool.query(
+      'SELECT 1 FROM agendamentos WHERE estabelecimento_id= AND cliente_id= LIMIT 1',
+      [estabelecimentoId, clientId]
+    );
+    if (!exists) return res.status(404).json({ error: 'not_found' });
+
+    let tags = normalizeClientTags(req.body?.tags || []);
+    if (tags.length > 8) tags = tags.slice(0, 8);
+
+    const conn = await pool.getConnection();
+    try {
+      await conn.beginTransaction();
+      await conn.query(
+        'DELETE FROM cliente_tags WHERE estabelecimento_id= AND cliente_id=?',
+        [estabelecimentoId, clientId]
+      );
+      if (tags.length) {
+        const placeholders = tags.map(() => '(?,?,?)').join(', ');
+        const params = tags.flatMap((tag) => [estabelecimentoId, clientId, tag]);
+        await conn.query(
+          `INSERT INTO cliente_tags (estabelecimento_id, cliente_id, tag) VALUES ${placeholders}`,
+          params
+        );
+      }
+      await conn.commit();
+    } catch (err) {
+      await conn.rollback();
+      throw err;
+    } finally {
+      conn.release();
+    }
+
+    return res.json({ ok: true, tags });
+  } catch (err) {
+    console.error('PUT /establishments/:id/clients/:clientId/tags', err);
+    return res.status(500).json({ error: 'client_tags_failed' });
+  }
+});
+
 
 
 router.put('/:id/messages', auth, isEstabelecimento, async (req, res) => {
@@ -1422,11 +1786,11 @@ router.put('/:id/messages', auth, isEstabelecimento, async (req, res) => {
 
     if (!Number.isFinite(id) || req.user.id !== id) return res.status(403).json({ error: 'forbidden' });
 
-    const subject = req.body?.email_subject ?? null;
+    const subject = req.body?.email_subject  null;
 
-    const html = req.body?.email_html ?? null;
+    const html = req.body?.email_html  null;
 
-    const wa = req.body?.wa_template ?? null;
+    const wa = req.body?.wa_template  null;
 
     await pool.query(
 
@@ -1470,11 +1834,11 @@ router.put('/:id/slug', auth, isEstabelecimento, async (req, res) => {
 
     // checa unicidade
 
-    const [rows] = await pool.query("SELECT id FROM usuarios WHERE slug=? LIMIT 1", [slugRaw]);
+    const [rows] = await pool.query("SELECT id FROM usuarios WHERE slug= LIMIT 1", [slugRaw]);
 
     if (rows.length && rows[0].id !== id) return res.status(409).json({ error: 'slug_taken' });
 
-    await pool.query('UPDATE usuarios SET slug=? WHERE id=? AND tipo=\'estabelecimento\'', [slugRaw, id]);
+    await pool.query('UPDATE usuarios SET slug= WHERE id= AND tipo=\'estabelecimento\'', [slugRaw, id]);
 
     return res.json({ ok: true, slug: slugRaw });
 
@@ -1652,7 +2016,7 @@ router.put('/:id/plan', auth, isEstabelecimento, async (req, res) => {
 
       const nextSubId = String(req.body.subscriptionId || '').trim();
 
-      subscriptionId = nextSubId ? nextSubId : null;
+      subscriptionId = nextSubId  nextSubId : null;
 
     }
 
@@ -1660,7 +2024,7 @@ router.put('/:id/plan', auth, isEstabelecimento, async (req, res) => {
 
     await pool.query(
 
-      "UPDATE usuarios SET plan=?, plan_status=?, plan_trial_ends_at=?, plan_active_until=?, plan_subscription_id=? WHERE id=? AND tipo='estabelecimento'",
+      "UPDATE usuarios SET plan=?, plan_status=?, plan_trial_ends_at=?, plan_active_until=?, plan_subscription_id= WHERE id= AND tipo='estabelecimento'",
 
       [rawPlan, planStatus, planTrialEndsAt, planActiveUntil, subscriptionId, id]
 
@@ -1686,9 +2050,9 @@ router.put('/:id/plan', auth, isEstabelecimento, async (req, res) => {
 
       plan_status: updatedContext.status,
 
-      plan_trial_ends_at: updatedContext.trialEndsAt ? updatedContext.trialEndsAt.toISOString() : null,
+      plan_trial_ends_at: updatedContext.trialEndsAt  updatedContext.trialEndsAt.toISOString() : null,
 
-      plan_active_until: updatedContext.activeUntil ? updatedContext.activeUntil.toISOString() : null,
+      plan_active_until: updatedContext.activeUntil  updatedContext.activeUntil.toISOString() : null,
 
       plan_subscription_id: updatedContext.subscriptionId,
 
@@ -1822,7 +2186,7 @@ router.delete('/:id/review', auth, isCliente, async (req, res) => {
 
     await pool.query(
 
-      "DELETE FROM estabelecimento_reviews WHERE estabelecimento_id=? AND cliente_id=?",
+      "DELETE FROM estabelecimento_reviews WHERE estabelecimento_id= AND cliente_id=?",
 
       [estabelecimentoId, req.user.id]
 
@@ -1908,7 +2272,7 @@ router.delete('/:id/favorite', auth, isCliente, async (req, res) => {
 
     await pool.query(
 
-      "DELETE FROM cliente_favoritos WHERE cliente_id=? AND estabelecimento_id=?",
+      "DELETE FROM cliente_favoritos WHERE cliente_id= AND estabelecimento_id=?",
 
       [req.user.id, estabelecimentoId]
 
@@ -1946,7 +2310,7 @@ router.post('/:id/images', auth, isEstabelecimento, async (req, res) => {
 
     if (!est) return res.status(404).json({ error: 'not_found' });
 
-    const imageRaw = typeof req.body?.image === 'string' ? req.body.image.trim() : '';
+    const imageRaw = typeof req.body?.image === 'string'  req.body.image.trim() : '';
 
     if (!imageRaw) {
 
@@ -1970,7 +2334,7 @@ router.post('/:id/images', auth, isEstabelecimento, async (req, res) => {
 
         limit === 0
 
-          ? 'Seu plano atual não permite adicionar imagens.'
+           'Seu plano atual não permite adicionar imagens.'
 
           : `Seu plano atual permite cadastrar até ${limit} imagens.`;
 
@@ -2018,7 +2382,7 @@ router.post('/:id/images', auth, isEstabelecimento, async (req, res) => {
 
     const [[row]] = await pool.query(
 
-      'SELECT id, estabelecimento_id, file_path, titulo, descricao, ordem, created_at FROM estabelecimento_imagens WHERE id=? LIMIT 1',
+      'SELECT id, estabelecimento_id, file_path, titulo, descricao, ordem, created_at FROM estabelecimento_imagens WHERE id= LIMIT 1',
 
       [insertedId]
 
@@ -2068,7 +2432,7 @@ router.delete('/:id/images/:imageId', auth, isEstabelecimento, async (req, res)
 
     const [[row]] = await pool.query(
 
-      'SELECT id, estabelecimento_id, file_path FROM estabelecimento_imagens WHERE id=? LIMIT 1',
+      'SELECT id, estabelecimento_id, file_path FROM estabelecimento_imagens WHERE id= LIMIT 1',
 
       [imageId]
 
@@ -2080,7 +2444,7 @@ router.delete('/:id/images/:imageId', auth, isEstabelecimento, async (req, res)
 
     }
 
-    await pool.query('DELETE FROM estabelecimento_imagens WHERE id=? LIMIT 1', [imageId]);
+    await pool.query('DELETE FROM estabelecimento_imagens WHERE id= LIMIT 1', [imageId]);
 
     if (row.file_path) {
 
@@ -2146,7 +2510,7 @@ router.put('/:id/images/reorder', auth, isEstabelecimento, async (req, res) => {
 
     const [rows] = await pool.query(
 
-      'SELECT id FROM estabelecimento_imagens WHERE estabelecimento_id=? ORDER BY ordem ASC, id ASC',
+      'SELECT id FROM estabelecimento_imagens WHERE estabelecimento_id= ORDER BY ordem ASC, id ASC',
 
       [estabelecimentoId]
 
@@ -2184,7 +2548,7 @@ router.put('/:id/images/reorder', auth, isEstabelecimento, async (req, res) => {
 
       finalOrder.map((imageId, index) =>
 
-        pool.query('UPDATE estabelecimento_imagens SET ordem=? WHERE id=? LIMIT 1', [index + 1, imageId])
+        pool.query('UPDATE estabelecimento_imagens SET ordem= WHERE id= LIMIT 1', [index + 1, imageId])
 
       )
 
@@ -2261,9 +2625,3 @@ export default router;
 
 
 
-
-
-
-
-
-
diff --git a/backend/src/routes/profissionais.js b/backend/src/routes/profissionais.js
index 734ca57..bf714cc 100644
--- a/backend/src/routes/profissionais.js
+++ b/backend/src/routes/profissionais.js
@@ -1,227 +1,227 @@
-import { Router } from 'express';
-import { pool } from '../lib/db.js';
-import { auth, isEstabelecimento } from '../middleware/auth.js';
-import {
-  getPlanContext,
-  isDelinquentStatus,
-} from '../lib/plans.js';
-import { saveAvatarFromDataUrl, removeAvatarFile } from '../lib/avatar.js';
-import { ensureWithinProfessionalLimit } from '../middleware/billing.js';
-
-const router = Router();
-
-function toBoolean(value) {
-  if (value === true || value === false) return value;
-  const lower = String(value || '').trim().toLowerCase();
-  if (!lower) return false;
-  return ['1', 'true', 'yes', 'on'].includes(lower);
-}
-
-router.get('/', async (req, res, next) => {
-  const estabId =
-    req.query.establishmentId ||
-    req.query.estabelecimento_id ||
-    req.query.establishment_id ||
-    null;
-
-  if (!estabId) return next();
-
-  try {
-    const [rows] = await pool.query(
-      `SELECT id, estabelecimento_id, nome, descricao, avatar_url, ativo
-       FROM profissionais
-       WHERE estabelecimento_id=? AND (ativo IS NULL OR ativo=1)
-       ORDER BY nome`,
-      [estabId]
-    );
-    res.json(rows || []);
-  } catch (err) {
-    console.error('[profissionais][public] list', err);
-    res.status(500).json({ error: 'list_profissionais_failed' });
-  }
-});
-
-router.get('/', auth, isEstabelecimento, async (req, res) => {
-  try {
-    const estId = req.user.id;
-    const [rows] = await pool.query(
-      `SELECT id, estabelecimento_id, nome, descricao, avatar_url, ativo, created_at
-       FROM profissionais
-       WHERE estabelecimento_id=?
-       ORDER BY nome`,
-      [estId]
-    );
-    res.json(rows || []);
-  } catch (err) {
-    console.error('[profissionais][mine] list', err);
-    res.status(500).json({ error: 'list_profissionais_failed' });
-  }
-});
-
-router.post(
-  '/',
-  auth,
-  isEstabelecimento,
-  ensureWithinProfessionalLimit({
-    isActivating: (req) => toBoolean(req.body?.ativo ?? true) === true,
-  }),
-  async (req, res) => {
-  try {
-    const estId = req.user.id;
-    let { nome, descricao, avatar, ativo = true } = req.body || {};
-    nome = String(nome || '').trim();
+import { Router } from 'express';

+import { pool } from '../lib/db.js';

+import { auth, isEstabelecimento } from '../middleware/auth.js';

+import {

+  getPlanContext,

+  isDelinquentStatus,

+} from '../lib/plans.js';

+import { saveAvatarFromDataUrl, removeAvatarFile } from '../lib/avatar.js';

+import { ensureWithinProfessionalLimit } from '../middleware/billing.js';

+

+const router = Router();

+

+function toBoolean(value) {

+  if (value === true || value === false) return value;

+  const lower = String(value || '').trim().toLowerCase();

+  if (!lower) return false;

+  return ['1', 'true', 'yes', 'on'].includes(lower);

+}

+

+router.get('/', async (req, res, next) => {

+  const estabId =

+    req.query.establishmentId ||

+    req.query.estabelecimento_id ||

+    req.query.establishment_id ||

+    null;

+

+  if (!estabId) return next();

+

+  try {

+    const [rows] = await pool.query(

+      `SELECT id, estabelecimento_id, nome, descricao, avatar_url, ativo

+       FROM profissionais

+       WHERE estabelecimento_id= AND (ativo IS NULL OR ativo=1)

+       ORDER BY nome`,

+      [estabId]

+    );

+    res.json(rows || []);

+  } catch (err) {

+    console.error('[profissionais][public] list', err);

+    res.status(500).json({ error: 'list_profissionais_failed' });

+  }

+});

+

+router.get('/', auth, isEstabelecimento, async (req, res) => {

+  try {

+    const estId = req.user.id;

+    const [rows] = await pool.query(

+      `SELECT id, estabelecimento_id, nome, descricao, avatar_url, ativo, created_at

+       FROM profissionais

+       WHERE estabelecimento_id=?

+       ORDER BY nome`,

+      [estId]

+    );

+    res.json(rows || []);

+  } catch (err) {

+    console.error('[profissionais][mine] list', err);

+    res.status(500).json({ error: 'list_profissionais_failed' });

+  }

+});

+

+router.post(

+  '/',

+  auth,

+  isEstabelecimento,

+  ensureWithinProfessionalLimit({

+    isActivating: (req) => toBoolean(req.body?.ativo  true) === true,

+  }),

+  async (req, res) => {

+  try {

+    const estId = req.user.id;

+    let { nome, descricao, avatar, ativo = true } = req.body || {};

+    nome = String(nome || '').trim();

     descricao = descricao == null ? null : String(descricao).trim();
-    const isActive = toBoolean(ativo);
-
-    if (!nome) {
-      return res.status(400).json({ error: 'nome_obrigatorio', message: 'Informe o nome do profissional.' });
-    }
-
-    const planContext = await getPlanContext(estId);
-    const planStatus = planContext?.status || 'trialing';
-
-    if (isDelinquentStatus(planStatus)) {
-      return res.status(402).json({
-        error: 'plan_delinquent',
-        message: 'Sua assinatura esta em atraso. Regularize o pagamento para cadastrar profissionais.',
-      });
-    }
-
-    let avatarUrl = null;
-    if (avatar) {
-      try {
-        avatarUrl = await saveAvatarFromDataUrl(avatar, estId, null);
-      } catch (err) {
-        if (err?.code === 'AVATAR_TOO_LARGE') {
-          return res.status(400).json({ error: 'avatar_grande', message: 'A imagem deve ter no maximo 2MB.' });
-        }
-        if (err?.code === 'AVATAR_INVALID') {
-          return res.status(400).json({ error: 'avatar_invalido', message: 'Envie uma imagem PNG, JPG ou WEBP.' });
-        }
-        console.error('[profissionais][create] avatar', err);
-        return res.status(500).json({ error: 'avatar_falhou', message: 'Não foi possível salvar a foto.' });
-      }
-    }
-
-    const [insert] = await pool.query(
-      'INSERT INTO profissionais (estabelecimento_id, nome, descricao, avatar_url, ativo) VALUES (?,?,?,?,?)',
-      [estId, nome, descricao || null, avatarUrl, isActive ? 1 : 0]
-    );
-
-    const [[row]] = await pool.query(
-      'SELECT id, estabelecimento_id, nome, descricao, avatar_url, ativo, created_at FROM profissionais WHERE id=?',
-      [insert.insertId]
-    );
-    return res.json(row);
-  } catch (err) {
-    console.error('[profissionais][create]', err);
-    return res.status(500).json({ error: 'create_profissional_failed' });
-  }
-  }
-);
-
-async function loadProfessional(req, res, next) {
-  try {
-    const estId = req.user.id;
-    const { id } = req.params;
-
-    const [[row]] = await pool.query(
-      'SELECT id, nome, descricao, avatar_url, ativo FROM profissionais WHERE id=? AND estabelecimento_id=?',
-      [id, estId]
-    );
-    if (!row) return res.status(404).json({ error: 'not_found' });
-
-    req.professional = row;
-    return next();
-  } catch (err) {
-    console.error('[profissionais][load]', err);
-    return res.status(500).json({ error: 'load_profissional_failed' });
-  }
-}
-
-router.put(
-  '/:id',
-  auth,
-  isEstabelecimento,
-  loadProfessional,
-  ensureWithinProfessionalLimit({
-    isActivating: (req) => {
-      const currentActive = toBoolean(req.professional?.ativo);
-      const nextActive = req.body?.ativo == null ? currentActive : toBoolean(req.body.ativo);
-      return currentActive === false && nextActive === true;
-    },
-  }),
-  async (req, res) => {
-  try {
-    const estId = req.user.id;
-    const { id } = req.params;
-    let { nome, descricao, avatar, avatarRemove, ativo } = req.body || {};
-
-    const row = req.professional;
+    const isActive = toBoolean(ativo);

+

+    if (!nome) {

+      return res.status(400).json({ error: 'nome_obrigatorio', message: 'Informe o nome do profissional.' });

+    }

+

+    const planContext = await getPlanContext(estId);

+    const planStatus = planContext?.status || 'trialing';

+

+    if (isDelinquentStatus(planStatus)) {

+      return res.status(402).json({

+        error: 'plan_delinquent',

+        message: 'Sua assinatura esta em atraso. Regularize o pagamento para cadastrar profissionais.',

+      });

+    }

+

+    let avatarUrl = null;

+    if (avatar) {

+      try {

+        avatarUrl = await saveAvatarFromDataUrl(avatar, estId, null);

+      } catch (err) {

+        if (err?.code === 'AVATAR_TOO_LARGE') {

+          return res.status(400).json({ error: 'avatar_grande', message: 'A imagem deve ter no maximo 2MB.' });

+        }

+        if (err?.code === 'AVATAR_INVALID') {

+          return res.status(400).json({ error: 'avatar_invalido', message: 'Envie uma imagem PNG, JPG ou WEBP.' });

+        }

+        console.error('[profissionais][create] avatar', err);

+        return res.status(500).json({ error: 'avatar_falhou', message: 'Não foi possível salvar a foto.' });

+      }

+    }

+

+    const [insert] = await pool.query(

+      'INSERT INTO profissionais (estabelecimento_id, nome, descricao, avatar_url, ativo) VALUES (?,?,?,?,?)',

+      [estId, nome, descricao || null, avatarUrl, isActive  1 : 0]

+    );

+

+    const [[row]] = await pool.query(

+      'SELECT id, estabelecimento_id, nome, descricao, avatar_url, ativo, created_at FROM profissionais WHERE id=?',

+      [insert.insertId]

+    );

+    return res.json(row);

+  } catch (err) {

+    console.error('[profissionais][create]', err);

+    return res.status(500).json({ error: 'create_profissional_failed' });

+  }

+  }

+);

+

+async function loadProfessional(req, res, next) {

+  try {

+    const estId = req.user.id;

+    const { id } = req.params;

+

+    const [[row]] = await pool.query(

+      'SELECT id, nome, descricao, avatar_url, ativo FROM profissionais WHERE id= AND estabelecimento_id=?',

+      [id, estId]

+    );

+    if (!row) return res.status(404).json({ error: 'not_found' });

+

+    req.professional = row;

+    return next();

+  } catch (err) {

+    console.error('[profissionais][load]', err);

+    return res.status(500).json({ error: 'load_profissional_failed' });

+  }

+}

+

+router.put(

+  '/:id',

+  auth,

+  isEstabelecimento,

+  loadProfessional,

+  ensureWithinProfessionalLimit({

+    isActivating: (req) => {

+      const currentActive = toBoolean(req.professional?.ativo);

+      const nextActive = req.body?.ativo == null  currentActive : toBoolean(req.body.ativo);

+      return currentActive === false && nextActive === true;

+    },

+  }),

+  async (req, res) => {

+  try {

+    const estId = req.user.id;

+    const { id } = req.params;

+    let { nome, descricao, avatar, avatarRemove, ativo } = req.body || {};

+

+    const row = req.professional;

     const nextNome = nome != null ? String(nome).trim() : row.nome;
     const nextDescricao = descricao != null ? String(descricao).trim() : row.descricao;
-    const wantsRemove = avatarRemove === true || avatarRemove === 'true';
-    const hasAvatarData = typeof avatar === 'string' && avatar.startsWith('data:');
-
-    let nextAvatar = row.avatar_url;
-    if (wantsRemove && nextAvatar) {
-      try { await removeAvatarFile(nextAvatar); } catch (err) { if (err?.code !== 'ENOENT') console.warn('[profissionais][avatar remove]', err?.message || err); }
-      nextAvatar = null;
-    }
-    if (hasAvatarData) {
-      try {
-        nextAvatar = await saveAvatarFromDataUrl(avatar, estId, wantsRemove ? null : row.avatar_url);
-      } catch (err) {
-        if (err?.code === 'AVATAR_TOO_LARGE') {
-          return res.status(400).json({ error: 'avatar_grande', message: 'A imagem deve ter no maximo 2MB.' });
-        }
-        if (err?.code === 'AVATAR_INVALID') {
-          return res.status(400).json({ error: 'avatar_invalido', message: 'Envie uma imagem PNG, JPG ou WEBP.' });
-        }
-        console.error('[profissionais][update] avatar', err);
-        return res.status(500).json({ error: 'avatar_falhou', message: 'Não foi possível salvar a foto.' });
-      }
-    }
-
-    const nextAtivo = ativo == null ? row.ativo : (toBoolean(ativo) ? 1 : 0);
-
-    await pool.query(
-      'UPDATE profissionais SET nome=?, descricao=?, avatar_url=?, ativo=? WHERE id=? AND estabelecimento_id=?',
-      [nextNome, nextDescricao || null, nextAvatar, nextAtivo, id, estId]
-    );
-
-    const [[updated]] = await pool.query(
-      'SELECT id, estabelecimento_id, nome, descricao, avatar_url, ativo, created_at FROM profissionais WHERE id=?',
-      [id]
-    );
-    res.json(updated);
-  } catch (err) {
-    console.error('[profissionais][update]', err);
-    res.status(500).json({ error: 'update_profissional_failed' });
-  }
-  }
-);
-
-router.delete('/:id', auth, isEstabelecimento, async (req, res) => {
-  try {
-    const estId = req.user.id;
-    const { id } = req.params;
-    const [[row]] = await pool.query(
-      'SELECT id, avatar_url FROM profissionais WHERE id=? AND estabelecimento_id=?',
-      [id, estId]
-    );
-    if (!row) return res.status(404).json({ error: 'not_found' });
-
-    await pool.query('DELETE FROM servico_profissionais WHERE profissional_id=?', [id]);
-    await pool.query('DELETE FROM profissionais WHERE id=? AND estabelecimento_id=?', [id, estId]);
-    if (row.avatar_url) {
-      await removeAvatarFile(row.avatar_url).catch(() => {});
-    }
-    res.json({ ok: true });
-  } catch (err) {
-    console.error('[profissionais][delete]', err);
-    res.status(500).json({ error: 'delete_profissional_failed' });
-  }
-});
-
-export default router;
+    const wantsRemove = avatarRemove === true || avatarRemove === 'true';

+    const hasAvatarData = typeof avatar === 'string' && avatar.startsWith('data:');

+

+    let nextAvatar = row.avatar_url;

+    if (wantsRemove && nextAvatar) {

+      try { await removeAvatarFile(nextAvatar); } catch (err) { if (err?.code !== 'ENOENT') console.warn('[profissionais][avatar remove]', err?.message || err); }

+      nextAvatar = null;

+    }

+    if (hasAvatarData) {

+      try {

+        nextAvatar = await saveAvatarFromDataUrl(avatar, estId, wantsRemove  null : row.avatar_url);

+      } catch (err) {

+        if (err?.code === 'AVATAR_TOO_LARGE') {

+          return res.status(400).json({ error: 'avatar_grande', message: 'A imagem deve ter no maximo 2MB.' });

+        }

+        if (err?.code === 'AVATAR_INVALID') {

+          return res.status(400).json({ error: 'avatar_invalido', message: 'Envie uma imagem PNG, JPG ou WEBP.' });

+        }

+        console.error('[profissionais][update] avatar', err);

+        return res.status(500).json({ error: 'avatar_falhou', message: 'Não foi possível salvar a foto.' });

+      }

+    }

+

+    const nextAtivo = ativo == null  row.ativo : (toBoolean(ativo)  1 : 0);

+

+    await pool.query(

+      'UPDATE profissionais SET nome=?, descricao=?, avatar_url=?, ativo= WHERE id= AND estabelecimento_id=?',

+      [nextNome, nextDescricao || null, nextAvatar, nextAtivo, id, estId]

+    );

+

+    const [[updated]] = await pool.query(

+      'SELECT id, estabelecimento_id, nome, descricao, avatar_url, ativo, created_at FROM profissionais WHERE id=?',

+      [id]

+    );

+    res.json(updated);

+  } catch (err) {

+    console.error('[profissionais][update]', err);

+    res.status(500).json({ error: 'update_profissional_failed' });

+  }

+  }

+);

+

+router.delete('/:id', auth, isEstabelecimento, async (req, res) => {

+  try {

+    const estId = req.user.id;

+    const { id } = req.params;

+    const [[row]] = await pool.query(

+      'SELECT id, avatar_url FROM profissionais WHERE id= AND estabelecimento_id=?',

+      [id, estId]

+    );

+    if (!row) return res.status(404).json({ error: 'not_found' });

+

+    await pool.query('DELETE FROM servico_profissionais WHERE profissional_id=?', [id]);

+    await pool.query('DELETE FROM profissionais WHERE id= AND estabelecimento_id=?', [id, estId]);

+    if (row.avatar_url) {

+      await removeAvatarFile(row.avatar_url).catch(() => {});

+    }

+    res.json({ ok: true });

+  } catch (err) {

+    console.error('[profissionais][delete]', err);

+    res.status(500).json({ error: 'delete_profissional_failed' });

+  }

+});

+

+export default router;

diff --git a/backend/src/routes/servicos.js b/backend/src/routes/servicos.js
index 33c59ac..18b2496 100644
--- a/backend/src/routes/servicos.js
+++ b/backend/src/routes/servicos.js
@@ -34,7 +34,7 @@ async function validateProfessionalIds(establishmentId, ids) {
   if (!normalized.length) return [];
   const placeholders = normalized.map(() => '?').join(',');
   const [rows] = await pool.query(
-    `SELECT id, ativo FROM profissionais WHERE estabelecimento_id=? AND id IN (${placeholders})`,
+    `SELECT id, ativo FROM profissionais WHERE estabelecimento_id= AND id IN (${placeholders})`,
     [establishmentId, ...normalized]
   );
   const foundIds = rows.map((row) => row.id);
@@ -87,7 +87,7 @@ async function attachProfessionals(services) {
 
 async function fetchService(establishmentId, serviceId) {
   const [[service]] = await pool.query(
-    'SELECT * FROM servicos WHERE id=? AND estabelecimento_id=?',
+    'SELECT * FROM servicos WHERE id= AND estabelecimento_id=?',
     [serviceId, establishmentId]
   );
   if (!service) return null;
@@ -135,7 +135,7 @@ router.get('/', auth, isEstabelecimento, async (req, res) => {
   try {
     const estId = req.user.id;
     const [rows] = await pool.query(
-      'SELECT * FROM servicos WHERE estabelecimento_id=? ORDER BY id DESC',
+      'SELECT * FROM servicos WHERE estabelecimento_id= ORDER BY id DESC',
       [estId]
     );
     await attachProfessionals(rows);
@@ -157,7 +157,7 @@ router.post('/', auth, isEstabelecimento, async (req, res) => {
     const nomeTrim = String(nome || '').trim();
     const descricaoTrim = descricao != null ? String(descricao).trim() : null;
     const duracao = Number(duracao_min);
-    const preco = Number(preco_centavos ?? 0);
+    const preco = Number(preco_centavos  0);
     const isActive = toBoolean(ativo);
     if (!nomeTrim || !duracao) {
       return res.status(400).json({
@@ -182,7 +182,7 @@ router.post('/', auth, isEstabelecimento, async (req, res) => {
       professionalIdsToLink = await validateProfessionalIds(estId, professionalIds);
     } catch (err) {
       if (err?.status) {
-        return res.status(err.status).json({ error: err.code || 'profissional_invalido', message: err.message, ...(err.details ? { details: err.details } : {}) });
+        return res.status(err.status).json({ error: err.code || 'profissional_invalido', message: err.message, ...(err.details  { details: err.details } : {}) });
       }
       throw err;
     }
@@ -221,7 +221,7 @@ router.post('/', auth, isEstabelecimento, async (req, res) => {
 
     const [insert] = await conn.query(
       'INSERT INTO servicos (estabelecimento_id, nome, descricao, imagem_url, duracao_min, preco_centavos, ativo) VALUES (?,?,?,?,?,?,?)',
-      [estId, nomeTrim, descricaoTrim || null, imagemUrl, Number.isFinite(duracao) ? Math.max(0, Math.round(duracao)) : 0, Number.isFinite(preco) ? Math.max(0, Math.round(preco)) : 0, isActive ? 1 : 0]
+      [estId, nomeTrim, descricaoTrim || null, imagemUrl, Number.isFinite(duracao)  Math.max(0, Math.round(duracao)) : 0, Number.isFinite(preco)  Math.max(0, Math.round(preco)) : 0, isActive  1 : 0]
     );
     const serviceId = insert.insertId;
 
@@ -245,7 +245,7 @@ router.post('/', auth, isEstabelecimento, async (req, res) => {
     }
     console.error('[servicos][create]', e);
     if (e?.status) {
-      return res.status(e.status).json({ error: e.code || 'server_error', message: e.message, ...(e.details ? { details: e.details } : {}) });
+      return res.status(e.status).json({ error: e.code || 'server_error', message: e.message, ...(e.details  { details: e.details } : {}) });
     }
     res.status(500).json({ error: 'server_error' });
   }
@@ -264,7 +264,7 @@ router.put('/:id', auth, isEstabelecimento, async (req, res) => {
     }
 
     const [[current]] = await pool.query(
-      'SELECT * FROM servicos WHERE id=? AND estabelecimento_id=?',
+      'SELECT * FROM servicos WHERE id= AND estabelecimento_id=?',
       [serviceId, estId]
     );
     if (!current) return res.status(404).json({ error: 'not_found' });
@@ -272,11 +272,11 @@ router.put('/:id', auth, isEstabelecimento, async (req, res) => {
     const updates = {
       nome: req.body?.nome != null ? String(req.body.nome).trim() : current.nome,
       descricao: Object.prototype.hasOwnProperty.call(req.body || {}, 'descricao')
-        ? (req.body.descricao != null ? String(req.body.descricao).trim() : null)
+         (req.body.descricao != null ? String(req.body.descricao).trim() : null)
         : current.descricao,
-      duracao_min: req.body?.duracao_min != null ? Number(req.body.duracao_min) : current.duracao_min,
-      preco_centavos: req.body?.preco_centavos != null ? Number(req.body.preco_centavos) : current.preco_centavos,
-      ativo: req.body?.ativo != null ? (toBoolean(req.body.ativo) ? 1 : 0) : current.ativo,
+      duracao_min: req.body?.duracao_min != null  Number(req.body.duracao_min) : current.duracao_min,
+      preco_centavos: req.body?.preco_centavos != null  Number(req.body.preco_centavos) : current.preco_centavos,
+      ativo: req.body?.ativo != null  (toBoolean(req.body.ativo)  1 : 0) : current.ativo,
     };
 
     updates.nome = String(updates.nome || '').trim();
@@ -284,8 +284,8 @@ router.put('/:id', auth, isEstabelecimento, async (req, res) => {
       updates.descricao = String(updates.descricao).trim();
       if (!updates.descricao) updates.descricao = null;
     }
-    updates.duracao_min = Number.isFinite(updates.duracao_min) ? Math.max(0, Math.round(updates.duracao_min)) : 0;
-    updates.preco_centavos = Number.isFinite(updates.preco_centavos) ? Math.max(0, Math.round(updates.preco_centavos)) : 0;
+    updates.duracao_min = Number.isFinite(updates.duracao_min)  Math.max(0, Math.round(updates.duracao_min)) : 0;
+    updates.preco_centavos = Number.isFinite(updates.preco_centavos)  Math.max(0, Math.round(updates.preco_centavos)) : 0;
 
     if (!updates.nome || !updates.duracao_min) {
       return res.status(400).json({ error: 'invalid_payload', message: 'Informe nome e duracao.' });
@@ -297,7 +297,7 @@ router.put('/:id', auth, isEstabelecimento, async (req, res) => {
         professionalIdsToLink = await validateProfessionalIds(estId, req.body.professionalIds);
       } catch (err) {
         if (err?.status) {
-          return res.status(err.status).json({ error: err.code || 'profissional_invalido', message: err.message, ...(err.details ? { details: err.details } : {}) });
+          return res.status(err.status).json({ error: err.code || 'profissional_invalido', message: err.message, ...(err.details  { details: err.details } : {}) });
         }
         throw err;
       }
@@ -310,7 +310,7 @@ router.put('/:id', auth, isEstabelecimento, async (req, res) => {
       });
     }
 
-    const rawImage = typeof req.body?.imagem === 'string' ? req.body.imagem.trim() : '';
+    const rawImage = typeof req.body?.imagem === 'string'  req.body.imagem.trim() : '';
     const wantsRemoveImage = req.body?.imagemRemove === true || req.body?.imagemRemove === 'true';
     const hasImageData = !!rawImage && rawImage.startsWith('data:');
 
@@ -324,7 +324,7 @@ router.put('/:id', auth, isEstabelecimento, async (req, res) => {
     }
     if (hasImageData) {
       try {
-        nextImageUrl = await saveServiceImageFromDataUrl(rawImage, estId, wantsRemoveImage ? null : current.imagem_url);
+        nextImageUrl = await saveServiceImageFromDataUrl(rawImage, estId, wantsRemoveImage  null : current.imagem_url);
       } catch (err) {
         if (err?.code === 'SERVICE_IMAGE_TOO_LARGE') {
           return res.status(400).json({ error: 'imagem_grande', message: 'Imagem maior que 2MB.' });
@@ -341,8 +341,8 @@ router.put('/:id', auth, isEstabelecimento, async (req, res) => {
     await conn.beginTransaction();
 
     await conn.query(
-      'UPDATE servicos SET nome=?, descricao=?, imagem_url=?, duracao_min=?, preco_centavos=?, ativo=? WHERE id=? AND estabelecimento_id=?',
-      [updates.nome, updates.descricao, nextImageUrl, updates.duracao_min, updates.preco_centavos, updates.ativo ? 1 : 0, serviceId, estId]
+      'UPDATE servicos SET nome=?, descricao=?, imagem_url=?, duracao_min=?, preco_centavos=?, ativo= WHERE id= AND estabelecimento_id=?',
+      [updates.nome, updates.descricao, nextImageUrl, updates.duracao_min, updates.preco_centavos, updates.ativo  1 : 0, serviceId, estId]
     );
 
     if (professionalIdsToLink !== null) {
@@ -368,7 +368,7 @@ router.put('/:id', auth, isEstabelecimento, async (req, res) => {
     }
     console.error('[servicos][update]', e);
     if (e?.status) {
-      return res.status(e.status).json({ error: e.code || 'server_error', message: e.message, ...(e.details ? { details: e.details } : {}) });
+      return res.status(e.status).json({ error: e.code || 'server_error', message: e.message, ...(e.details  { details: e.details } : {}) });
     }
     res.status(500).json({ error: 'server_error' });
   }
@@ -391,7 +391,12 @@ router.delete('/:id', auth, isEstabelecimento, async (req, res) => {
          JOIN agendamento_itens ai ON ai.agendamento_id = a.id
         WHERE ai.servico_id=?
           AND a.estabelecimento_id=?
-          AND a.status IN ('confirmado','pendente')
+          AND a.status IN ('confirmado','pendente','pendente_pagamento')
+          AND (
+            a.status = 'confirmado'
+            OR (a.status = 'pendente' AND (a.public_confirm_expires_at IS NULL OR a.public_confirm_expires_at >= NOW()))
+            OR (a.status = 'pendente_pagamento' AND (a.deposit_expires_at IS NULL OR a.deposit_expires_at >= NOW()))
+          )
         LIMIT 1`,
       [serviceId, estId]
     );
@@ -403,12 +408,12 @@ router.delete('/:id', auth, isEstabelecimento, async (req, res) => {
     }
 
     const [[row]] = await pool.query(
-      'SELECT id, imagem_url FROM servicos WHERE id=? AND estabelecimento_id=?',
+      'SELECT id, imagem_url FROM servicos WHERE id= AND estabelecimento_id=?',
       [serviceId, estId]
     );
 
     const [result] = await pool.query(
-      'DELETE FROM servicos WHERE id=? AND estabelecimento_id=?',
+      'DELETE FROM servicos WHERE id= AND estabelecimento_id=?',
       [serviceId, estId]
     );
 
diff --git a/backend/src/routes/waConnect.js b/backend/src/routes/waConnect.js
index bf362f9..a7a06ef 100644
--- a/backend/src/routes/waConnect.js
+++ b/backend/src/routes/waConnect.js
@@ -93,8 +93,8 @@ router.post('/connect/disconnect', auth, isEstabelecimento, async (req, res) =>
 });
 
 router.get('/connect/callback', async (req, res) => {
-  const code = typeof req.query?.code === 'string' ? req.query.code : null;
-  const state = typeof req.query?.state === 'string' ? req.query.state : null;
+  const code = typeof req.query?.code === 'string'  req.query.code : null;
+  const state = typeof req.query?.state === 'string'  req.query.state : null;
   if (!code || !state) {
     return res.status(400).send('Missing code/state');
   }
@@ -149,7 +149,7 @@ router.get('/connect/callback', async (req, res) => {
         accessToken,
         { fields: 'id,name', limit: 10 }
       );
-      const wabas = Array.isArray(wabaResp?.data) ? wabaResp.data : [];
+      const wabas = Array.isArray(wabaResp?.data)  wabaResp.data : [];
       rawKeys.waba_keys = Object.keys(wabaResp || {});
       for (const waba of wabas) {
         if (!waba?.id) continue;
@@ -158,7 +158,7 @@ router.get('/connect/callback', async (req, res) => {
           accessToken,
           { fields: 'id,display_phone_number,verified_name', limit: 10 }
         );
-        const phones = Array.isArray(phonesResp?.data) ? phonesResp.data : [];
+        const phones = Array.isArray(phonesResp?.data)  phonesResp.data : [];
         phoneNumbersCount += phones.length;
         rawKeys.phone_keys = Object.keys(phonesResp || {});
         if (!phones.length) continue;
diff --git a/backend/src/services/waGraph.js b/backend/src/services/waGraph.js
index 2d08037..464a180 100644
--- a/backend/src/services/waGraph.js
+++ b/backend/src/services/waGraph.js
@@ -4,7 +4,7 @@ const API_VERSION = process.env.WA_API_VERSION || 'v23.0';
 const GRAPH_BASE = 'https://graph.facebook.com';
 
 function buildUrl(path, params) {
-  const clean = path.startsWith('/') ? path.slice(1) : path;
+  const clean = path.startsWith('/')  path.slice(1) : path;
   const url = new URL(`${GRAPH_BASE}/${API_VERSION}/${clean}`);
   if (params) {
     Object.entries(params).forEach(([key, value]) => {
@@ -31,7 +31,7 @@ async function callGraph({ method, url, token, payload }) {
   const res = await fetch(url, {
     method,
     headers,
-    body: payload ? JSON.stringify(payload) : undefined,
+    body: payload  JSON.stringify(payload) : undefined,
   });
   const data = await parseGraphResponse(res);
   if (!res.ok) {
@@ -157,7 +157,7 @@ export async function sendWhatsAppMessage({ accessToken, phoneNumberId, payload
     if (err?.status >= 400) {
       const error = err?.body?.error;
       const data = (error && typeof error === 'object')
-        ? {
+         {
             message: error.message,
             code: error.code,
             error_data: error.error_data,
diff --git a/backend/src/services/waTenant.js b/backend/src/services/waTenant.js
index af24841..f9a7160 100644
--- a/backend/src/services/waTenant.js
+++ b/backend/src/services/waTenant.js
@@ -13,7 +13,7 @@ export async function getWaAccountByEstabelecimentoId(estabelecimentoId) {
     `SELECT id, estabelecimento_id, waba_id, phone_number_id, display_phone_number, business_id,
             access_token_enc, token_last4, status, connected_at, updated_at
        FROM wa_accounts
-      WHERE estabelecimento_id=? LIMIT 1`,
+      WHERE estabelecimento_id= LIMIT 1`,
     [id]
   );
   return row || null;
@@ -25,7 +25,7 @@ export async function getWaAccountByPhoneNumberId(phoneNumberId) {
     `SELECT id, estabelecimento_id, waba_id, phone_number_id, display_phone_number, business_id,
             access_token_enc, token_last4, status, connected_at, updated_at
        FROM wa_accounts
-      WHERE phone_number_id=? LIMIT 1`,
+      WHERE phone_number_id= LIMIT 1`,
     [String(phoneNumberId)]
   );
   return row || null;
@@ -110,7 +110,7 @@ export async function recordWaMessage({
 }) {
   const id = normalizeId(estabelecimentoId);
   if (!id || !direction) return { ok: false };
-  const payloadJson = payload ? JSON.stringify(payload) : null;
+  const payloadJson = payload  JSON.stringify(payload) : null;
   await pool.query(
     `INSERT INTO wa_messages (
       estabelecimento_id,
